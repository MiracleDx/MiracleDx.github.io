<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常用Dockerfile</title>
    <url>/MiracleDx/2023/11/07/Docker/</url>
    <content><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><h3 id="6-8-23-m1"><a href="#6-8-23-m1" class="headerlink" title="6.8.23-m1"></a>6.8.23-m1</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile-elastic.yml</span></span><br><span class="line"><span class="keyword">FROM</span> arm64v8/openjdk:<span class="number">8</span>-jdk-buster</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /usr</span></span><br><span class="line"><span class="comment"># add a non root user</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m elasticuser</span></span><br><span class="line"><span class="comment"># Download extras</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt install -y curl nano</span></span><br><span class="line"><span class="comment"># Download elasticsearch</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> curl -L -O https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.8.23.tar.gz</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xvf elasticsearch-6.8.23.tar.gz</span></span><br><span class="line"><span class="comment"># Add config</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> elasticsearch.yml /usr/elasticsearch-6.8.23/config/elasticsearch.yml</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R elasticuser: .</span></span><br><span class="line"><span class="keyword">USER</span> elasticuser</span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=/usr/local/openjdk-<span class="number">18</span>/bin/java</span><br><span class="line"><span class="keyword">ENV</span> discovery.type=single-node</span><br><span class="line"><span class="keyword">ENV</span> xpack.security.enabled: false</span><br><span class="line"><span class="keyword">ENV</span> xpack.ml.enabled: false</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> elasticsearch-6.8.23/bin</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> -R elasticuser: elasticsearch-6.8.23</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9200</span> <span class="number">9300</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">cd</span> /usr/elasticsearch-6.8.23/bin/ &amp;&amp; ./elasticsearch</span></span><br></pre></td></tr></table></figure>

<h4 id="编译镜像"><a href="#编译镜像" class="headerlink" title="编译镜像"></a>编译镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/developer/container_repo/docker_repo/elastic</span><br><span class="line">docker build -f Dockerfile -t elastic:6.8.23 .</span><br></pre></td></tr></table></figure>

<h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name es -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms512m -Xmx512m&quot; elasticsearch:8.3.1</span><br></pre></td></tr></table></figure>

<h4 id="启动后进入容器修改配置文件"><a href="#启动后进入容器修改配置文件" class="headerlink" title="启动后进入容器修改配置文件"></a>启动后进入容器修改配置文件</h4><p>容器内没有 vi 命令的可以使用 docker cp 命令进行替换，修改后重启容器即可<br>以下配置文件不一定完全符合启动版本，某些版本中还会有 https 的配置，酌情开启或者关闭</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># elasticsearch.yml</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">xpack.ml.enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">http.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">transport.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br></pre></td></tr></table></figure>

<h3 id="8-8-0"><a href="#8-8-0" class="headerlink" title="8.8.0"></a>8.8.0</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull elasticsearch:8.8.0</span><br></pre></td></tr></table></figure>

<h2 id="Postgresql"><a href="#Postgresql" class="headerlink" title="Postgresql"></a>Postgresql</h2><h3 id="启动命令-1"><a href="#启动命令-1" class="headerlink" title="启动命令"></a>启动命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name postgres -d -p 5432:5432 -e POSTGRES_PASSWORD=123456 postgres:14.1</span><br></pre></td></tr></table></figure>

<h2 id="Nacos-m1"><a href="#Nacos-m1" class="headerlink" title="Nacos-m1"></a>Nacos-m1</h2><h3 id="2-0-3"><a href="#2-0-3" class="headerlink" title="2.0.3"></a>2.0.3</h3><h4 id="官方镜像地址"><a href="#官方镜像地址" class="headerlink" title="官方镜像地址"></a>官方镜像地址</h4><p><a href="https://github.com/nacos-group/nacos-docker/blob/v2.0.3/README_ZH.md">https://github.com/nacos-group/nacos-docker/blob/v2.0.3/README_ZH.md</a></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">8.3</span>.<span class="number">2011</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set environment</span></span><br><span class="line"><span class="keyword">ENV</span> MODE=<span class="string">&quot;cluster&quot;</span> \</span><br><span class="line">   PREFER_HOST_MODE=<span class="string">&quot;ip&quot;</span>\</span><br><span class="line">   BASE_DIR=<span class="string">&quot;/home/nacos&quot;</span> \</span><br><span class="line">   CLASSPATH=<span class="string">&quot;.:/home/nacos/conf:$CLASSPATH&quot;</span> \</span><br><span class="line">   CLUSTER_CONF=<span class="string">&quot;/home/nacos/conf/cluster.conf&quot;</span> \</span><br><span class="line">   FUNCTION_MODE=<span class="string">&quot;all&quot;</span> \</span><br><span class="line">   JAVA_HOME=<span class="string">&quot;/usr/lib/jvm/java-1.8.0-openjdk&quot;</span> \</span><br><span class="line">   NACOS_USER=<span class="string">&quot;nacos&quot;</span> \</span><br><span class="line">   JAVA=<span class="string">&quot;/usr/lib/jvm/java-1.8.0-openjdk/bin/java&quot;</span> \</span><br><span class="line">   JVM_XMS=<span class="string">&quot;1g&quot;</span> \</span><br><span class="line">   JVM_XMX=<span class="string">&quot;1g&quot;</span> \</span><br><span class="line">   JVM_XMN=<span class="string">&quot;512m&quot;</span> \</span><br><span class="line">   JVM_MS=<span class="string">&quot;128m&quot;</span> \</span><br><span class="line">   JVM_MMS=<span class="string">&quot;320m&quot;</span> \</span><br><span class="line">   NACOS_DEBUG=<span class="string">&quot;n&quot;</span> \</span><br><span class="line">   TOMCAT_ACCESSLOG_ENABLED=<span class="string">&quot;false&quot;</span> \</span><br><span class="line">   TIME_ZONE=<span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="keyword">ARG</span> NACOS_VERSION=<span class="number">2.0</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">ARG</span> HOT_FIX_FLAG=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$BASE_DIR</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">set</span> -x \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; sed -i <span class="string">&#x27;s/mirrorlist/#mirrorlist/g&#x27;</span> /etc/yum.repos.d/CentOS-* \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; sed -i <span class="string">&#x27;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&#x27;</span> /etc/yum.repos.d/CentOS-* \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; yum update -y \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; yum install -y java-1.8.0-openjdk java-1.8.0-openjdk-devel wget iputils nc vim libcurl --allowerasing</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://github.com/alibaba/nacos/releases/download/<span class="variable">$&#123;NACOS_VERSION&#125;</span><span class="variable">$&#123;HOT_FIX_FLAG&#125;</span>/nacos-server-<span class="variable">$&#123;NACOS_VERSION&#125;</span>.tar.gz -P /home</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> tar -xzvf /home/nacos-server-<span class="variable">$&#123;NACOS_VERSION&#125;</span>.tar.gz -C /home \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; <span class="built_in">rm</span> -rf /home/nacos-server-<span class="variable">$&#123;NACOS_VERSION&#125;</span>.tar.gz /home/nacos/bin/* /home/nacos/conf/*.properties /home/nacos/conf/*.example /home/nacos/conf/nacos-mysql.sql</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> yum autoremove -y wget \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; <span class="built_in">ln</span> -snf /usr/share/zoneinfo/<span class="variable">$TIME_ZONE</span> /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="variable">$TIME_ZONE</span> &gt; /etc/timezone \</span></span><br><span class="line"><span class="language-bash">   &amp;&amp; yum clean all</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> bin/docker-startup.sh bin/docker-startup.sh</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> conf/application.properties conf/application.properties</span></span><br><span class="line"><span class="comment"># set startup log dir</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p logs \</span></span><br><span class="line"><span class="language-bash">	&amp;&amp; <span class="built_in">cd</span> logs \</span></span><br><span class="line"><span class="language-bash">	&amp;&amp; <span class="built_in">touch</span> start.out \</span></span><br><span class="line"><span class="language-bash">	&amp;&amp; <span class="built_in">ln</span> -sf /dev/stdout start.out \</span></span><br><span class="line"><span class="language-bash">	&amp;&amp; <span class="built_in">ln</span> -sf /dev/stderr start.out</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x bin/docker-startup.sh</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8848</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;bin/docker-startup.sh&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h4 id="编译镜像-1"><a href="#编译镜像-1" class="headerlink" title="编译镜像"></a>编译镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/developer/container_repo/docker_repo/nacos_2.0.3</span><br><span class="line">docker build -f Dockerfile -t nacos:2.0.3 .</span><br></pre></td></tr></table></figure>

<h4 id="启动命令-2"><a href="#启动命令-2" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --env MODE=standalone --name nacos -d -p 8848:8848 -p 9848:9848 -p 9849:9849 nacos:2.0.3</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3"><a href="#2-2-3" class="headerlink" title="2.2.3"></a>2.2.3</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM amd64/buildpack-deps:buster-curl as installer</span><br><span class="line"></span><br><span class="line">ARG NACOS_VERSION=2.2.3</span><br><span class="line">ARG HOT_FIX_FLAG=&quot;&quot;</span><br><span class="line"></span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; curl -SL --output /var/tmp/nacos-server.tar.gz https://github.com/alibaba/nacos/releases/download/$&#123;NACOS_VERSION&#125;$&#123;HOT_FIX_FLAG&#125;/nacos-server-$&#123;NACOS_VERSION&#125;.tar.gz \</span><br><span class="line">    &amp;&amp; tar -xzvf /var/tmp/nacos-server.tar.gz -C /home \</span><br><span class="line">    &amp;&amp; rm -rf /var/tmp/nacos-server.tar.gz /home/nacos/bin/* /home/nacos/conf/*.properties /home/nacos/conf/*.example /home/nacos/conf/nacos-mysql.sql</span><br><span class="line"></span><br><span class="line">FROM adoptopenjdk/openjdk8:jre8u372-b07</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> environment</span></span><br><span class="line">ENV MODE=&quot;cluster&quot; \</span><br><span class="line">    PREFER_HOST_MODE=&quot;ip&quot;\</span><br><span class="line">    BASE_DIR=&quot;/home/nacos&quot; \</span><br><span class="line">    CLASSPATH=&quot;.:/home/nacos/conf:$CLASSPATH&quot; \</span><br><span class="line">    CLUSTER_CONF=&quot;/home/nacos/conf/cluster.conf&quot; \</span><br><span class="line">    FUNCTION_MODE=&quot;all&quot; \</span><br><span class="line">    NACOS_USER=&quot;nacos&quot; \</span><br><span class="line">    JAVA=&quot;/opt/java/openjdk/bin/java&quot; \</span><br><span class="line">    JVM_XMS=&quot;1g&quot; \</span><br><span class="line">    JVM_XMX=&quot;1g&quot; \</span><br><span class="line">    JVM_XMN=&quot;512m&quot; \</span><br><span class="line">    JVM_MS=&quot;128m&quot; \</span><br><span class="line">    JVM_MMS=&quot;320m&quot; \</span><br><span class="line">    NACOS_DEBUG=&quot;n&quot; \</span><br><span class="line">    TOMCAT_ACCESSLOG_ENABLED=&quot;false&quot; \</span><br><span class="line">    TZ=&quot;Asia/Shanghai&quot;</span><br><span class="line"></span><br><span class="line">WORKDIR $BASE_DIR</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">copy nacos bin</span></span><br><span class="line">COPY --from=installer [&quot;/home/nacos&quot;, &quot;/home/nacos&quot;]</span><br><span class="line"></span><br><span class="line">ADD bin/docker-startup.sh bin/docker-startup.sh</span><br><span class="line">ADD conf/application.properties conf/application.properties</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">set</span> startup <span class="built_in">log</span> <span class="built_in">dir</span></span></span><br><span class="line">RUN mkdir -p logs \</span><br><span class="line">    &amp;&amp; cd logs \</span><br><span class="line">    &amp;&amp; touch start.out \</span><br><span class="line">    &amp;&amp; ln -sf /dev/stdout start.out \</span><br><span class="line">    &amp;&amp; ln -sf /dev/stderr start.out</span><br><span class="line">RUN chmod +x bin/docker-startup.sh</span><br><span class="line"></span><br><span class="line">EXPOSE 8848</span><br><span class="line">ENTRYPOINT [&quot;bin/docker-startup.sh&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="编译镜像-2"><a href="#编译镜像-2" class="headerlink" title="编译镜像"></a>编译镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/developer/container_repo/docker_repo/nacos_2.2.3</span><br><span class="line">docker build -f Dockerfile.Slim -t nacos:2.2.3 .</span><br></pre></td></tr></table></figure>

<h4 id="启动命令-3"><a href="#启动命令-3" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Secret key</span></span><br><span class="line">Secret_nacos-server_fabula_haha@</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Secret ket <span class="built_in">base64</span></span></span><br><span class="line">U2VjcmV0X25hY29zLXNlcnZlcl9mYWJ1bGFfaGFoYUA=</span><br><span class="line"></span><br><span class="line">docker run --env MODE=standalone --env NACOS_AUTH_ENABLE=true --env NACOS_AUTH_TOKEN=U2VjcmV0X25hY29zLXNlcnZlcl9mYWJ1bGFfaGFoYUA= --env nacos.core.auth.server.identity.key=nacos --env nacos.core.auth.server.identity.value=nacos --name nacos -d -p 8848:8848 -p 9848:9848 -p 9849:9849 nacos:2.2.3</span><br></pre></td></tr></table></figure>

<h2 id="ShenYu"><a href="#ShenYu" class="headerlink" title="ShenYu"></a>ShenYu</h2><h3 id="默认用户密码"><a href="#默认用户密码" class="headerlink" title="默认用户密码"></a>默认用户密码</h3><p>admin&#x2F;123456</p>
<h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull apache/shenyu-admin:vdocker pull apache/shenyu-admin:2.4.3</span><br></pre></td></tr></table></figure>

<h3 id="h2-模式启动命令"><a href="#h2-模式启动命令" class="headerlink" title="h2 模式启动命令"></a>h2 模式启动命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name shenyu-admin-h2 -d -p 9095:9095 apache/shenyu-admin:2.4.3</span><br><span class="line">docker run --name shenyu-admin-h2 -e &quot;shenyu.sync.nacos.url=localhost:8848&quot; -e &quot;shenyu.sync.nacos.namespace=shenyu-admin&quot; -d -p 9095:9095 apache/shenyu-admin:2.4.3</span><br></pre></td></tr></table></figure>

<h3 id="PG-模式启动命令"><a href="#PG-模式启动命令" class="headerlink" title="PG 模式启动命令"></a>PG 模式启动命令</h3><p>初始化数据库脚本：<a href="https://github.com/apache/shenyu/tree/master/db/init/pg">https://github.com/apache/shenyu/tree/master/db/init/pg</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name shenyu-admin -e &quot;SPRING_PROFILES_ACTIVE=pg&quot; -e &quot;spring.datasource.url=jdbc:postgresql://localhost:5432/shenyu?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot; -e &quot;spring.datasource.username=postgres&quot; -e &quot;spring.datasource.password=123456&quot; -d -p 9095:9095 apache/shenyu-admin:2.4.3</span><br></pre></td></tr></table></figure>

<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p>将 <a href="https://repo1.maven.org/maven2/mysql/mysql-connector-java/8.0.18/mysql-connector-java-8.0.18.jar">mysql-connector.jar</a> 拷贝到 <code>/$&#123;your_work_dir&#125;/ext-lib</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -v /$&#123;your_work_dir&#125;/ext-lib:/opt/shenyu-admin/ext-lib -e &quot;SPRING_PROFILES_ACTIVE=mysql&quot; -e &quot;spring.datasource.url=jdbc:mysql://$&#123;your_ip_port&#125;/shenyu?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot; -e &quot;spring.datasource.username=$&#123;your_username&#125;&quot; -e &quot;spring.datasource.password=$&#123;your_password&#125;&quot; -d -p 9095:9095 --net shenyu apache/shenyu-admin:$&#123;current.version&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name shenyu-admin -v /Users/dongx/developer/shenyu_ext-lib:/opt/shenyu-admin/ext-lib -e &quot;SPRING_PROFILES_ACTIVE=mysql&quot; -e &quot;spring.datasource.url=jdbc:mysql://host.docker.internal:3306/shenyu?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&quot; -e &quot;spring.datasource.username=root&quot; -e &quot;spring.datasource.password=123456&quot; -d -p 9095:9095 apache/shenyu-admin:2.4.3</span><br></pre></td></tr></table></figure>

<h2 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mongo:6.0.6</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--auth 需要密码访问</span></span><br><span class="line">docker run --name mongo -p 27017:27017 -it -d mongo:6.0.6 --auth</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">连接 mongo</span></span><br><span class="line">docker exec -it mongo mongosh admin</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认情况，MongoDB 不包含任何管理员账户或用户账户, 手动创建名为 admin，密码为 123456 的用户。</span></span><br><span class="line">db.createUser(&#123; user:&#x27;admin&#x27;,pwd:&#x27;123456&#x27;,roles:[ &#123; role:&#x27;userAdminAnyDatabase&#x27;, db: &#x27;admin&#x27;&#125;,&quot;readWriteAnyDatabase&quot;]&#125;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用创建的用户信息进行连接。</span></span><br><span class="line">db.auth(&#x27;admin&#x27;, &#x27;123456&#x27;);</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看所有角色</span></span><br><span class="line">show users;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除角色</span></span><br><span class="line">db.dropUser(&#x27;chatterbot&#x27;)</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 use 命令创建数据库</span></span><br><span class="line">use chatterbot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给数据库创建连接用户</span></span><br><span class="line">db.createUser(&#123; user:&#x27;chatterbot&#x27;,pwd:&#x27;123456&#x27;,roles:[ &#123; role:&#x27;readWrite&#x27;, db: &#x27;chatterbot&#x27;&#125;]&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull redis:7.0.11</span><br><span class="line"></span><br><span class="line">docker run -d --name redis -p 6379:6379 redis:7.0.11</span><br></pre></td></tr></table></figure>

<h2 id="Every-size-app"><a href="#Every-size-app" class="headerlink" title="Every size app"></a>Every size app</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull ghcr.io/kibalabs/everysize-app:latest</span><br><span class="line"></span><br><span class="line">docker run --name everysize-app -p 8888:80 -it -d ghcr.io/kibalabs/everysize-app:latest</span><br></pre></td></tr></table></figure>

<h2 id="MinIO"><a href="#MinIO" class="headerlink" title="MinIO"></a>MinIO</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull minio/minio:RELEASE.2023-07-11T21-29-34Z</span><br><span class="line"></span><br><span class="line">docker run --name minio -p 9000:9000 -p 9001:9001 -e &quot;MINIO_ROOT_USER=admin&quot; -e &quot;MINIO_ROOT_PASSWORD=1234567890&quot; -it -d minio/minio:RELEASE.2023-07-11T21-29-34Z server /data --console-address &quot;:9001&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">host address</span></span><br><span class="line">https://hub.docker.com/r/minio/minio</span><br></pre></td></tr></table></figure>

<h2 id="Skywalking"><a href="#Skywalking" class="headerlink" title="Skywalking"></a>Skywalking</h2><h3 id="oap"><a href="#oap" class="headerlink" title="oap"></a>oap</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name skywalking-oap -d -p 1234:1234 -p 11800:11800 -p 12800:12800 apache/skywalking-oap-server:9.0.0</span><br></pre></td></tr></table></figure>

<h3 id="ui"><a href="#ui" class="headerlink" title="ui"></a>ui</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name skywalking-ui -d -e SW_OAP_ADDRESS=http://skywalking-oap:12800 -p 9999:8080 --link skywalking-oap:skywalking-oap apache/skywalking-ui:9.6.0</span><br></pre></td></tr></table></figure>

<h2 id="janusgraph"><a href="#janusgraph" class="headerlink" title="janusgraph"></a>janusgraph</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name janusgraph -p 8182:8182 janusgraph/janusgraph:1.0</span><br></pre></td></tr></table></figure>
<h2 id="禅道"><a href="#禅道" class="headerlink" title="禅道"></a>禅道</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull easysoft/zentao:latest</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[选择适合您的安装方法 - 禅道使用手册 - 禅道开源项目管理软件](https://www.zentao.net/book/zentaopms/455.html)</span></span><br><span class="line">docker run -itd -v $PWD/data:/data -p 80:80 -e MYSQL_INTERNAL=true hub.zentao.net/app/zentao</span><br></pre></td></tr></table></figure>
<h2 id="Habse"><a href="#Habse" class="headerlink" title="Habse"></a>Habse</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name hbase -d --platform linux/amd64 -p 2181:2181 -p 60000:60000 -p 60010:60010 -p 60020:60020 -p 60030:60030 cogniteev/hbase-standalone</span><br></pre></td></tr></table></figure>
<ul>
<li>2181: ZooKeeper 端口，用于协调分布式应用程序的服务发现和配置同步。</li>
<li>8080: HBase 的 Web UI 端口，可以通过浏览器访问，提供集群状态和一些管理功能。</li>
<li>8085: HBase 的 Master Web UI 端口，提供关于 HBase 主节点的信息。</li>
<li>9090: HBase 的主要 API 端口，用于 HBase 的客户端与服务器之间的通信。</li>
<li>9095: HBase 的主要 RPC（远程过程调用）引擎端口。</li>
<li>16000: HBase 的主区域服务器（RegionServer）端口。</li>
<li>16010: HBase 的主区域服务器 Web UI 端口，提供有关特定 RegionServer 的信息。</li>
<li>16201: HBase 的备用区域服务器（RegionServer）端口。</li>
<li>16301: HBase 的备用区域服务器 Web UI 端口，提供有关备用 RegionServer 的信息。</li>
<li>16030: HBase 的主控制台端口，提供有关 HBase 主控制台的信息。</li>
<li>16020: HBase 的主区域服务器信息端口。</li>
</ul>
<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">zookeeper:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-zookeeper:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">ZOO_MY_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_CLIENT_PORT:</span> <span class="number">2181</span></span><br><span class="line">      <span class="attr">ZOOKEEPER_TICK_TIME:</span> <span class="number">2000</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">12181</span><span class="string">:2181</span></span><br><span class="line">  </span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">confluentinc/cp-kafka:latest</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">KAFKA_BROKER_ID:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">KAFKA_ZOOKEEPER_CONNECT:</span> <span class="string">zookeeper:2181</span></span><br><span class="line">      <span class="attr">ALLOW_PLAINTEXT_LISTENER:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENERS:</span> <span class="string">CLIENT://:9092,EXTERNAL://:19092</span></span><br><span class="line">      <span class="attr">KAFKA_LISTENER_SECURITY_PROTOCOL_MAP:</span> <span class="string">CLIENT:PLAINTEXT,EXTERNAL:PLAINTEXT</span></span><br><span class="line">      <span class="attr">KAFKA_ADVERTISED_LISTENERS:</span> <span class="string">CLIENT://:9092,EXTERNAL://127.0.0.1:19092</span></span><br><span class="line">      <span class="attr">KAFKA_INTER_BROKER_LISTENER_NAME:</span> <span class="string">CLIENT</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">9092</span><span class="string">:9092</span>    </span><br><span class="line">      <span class="bullet">-</span> <span class="number">19092</span><span class="string">:19092</span> </span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">zookeeper</span></span><br></pre></td></tr></table></figure>

<h2 id="Gaussdb"><a href="#Gaussdb" class="headerlink" title="Gaussdb"></a>Gaussdb</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name opengauss -p 5432:5432 --rm -e GS_PASSWORD=mtkOP@128 enmotech/opengauss</span><br></pre></td></tr></table></figure>

<h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name cassandra -d -e CASSANDRA_START_RPC=true -p 9160:9160 -p 9042:9042 -p 7199:7199 -p 7001:7001 -p 7000:7000 cassandra:3.11</span><br></pre></td></tr></table></figure>

<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">从宿主机给容器复制</span><br><span class="line">docker cp &#123;&#123;file_path&#125;&#125; &#123;&#123;id/name&#125;&#125;:container_path</span><br><span class="line"></span><br><span class="line">从容器给宿主机复制</span><br><span class="line">docker cp &#123;&#123;container_name&#125;&#125;:&#123;&#123;file_path&#125;&#125;  ~/Downloads</span><br></pre></td></tr></table></figure>

<h2 id="查看容器-ip"><a href="#查看容器-ip" class="headerlink" title="查看容器 ip"></a>查看容器 ip</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h2 id="查看所有容器-ip"><a href="#查看所有容器-ip" class="headerlink" title="查看所有容器 ip"></a>查看所有容器 ip</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;.NetworkSettings.IPAddress &#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>

<h2 id="查看-Docker-容器-IP-地址"><a href="#查看-Docker-容器-IP-地址" class="headerlink" title="查看 Docker 容器 IP 地址"></a>查看 Docker 容器 IP 地址</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect xxx | grep IPAddress</span><br></pre></td></tr></table></figure>

<h2 id="查看-Docker-正在运行的容器的-PID"><a href="#查看-Docker-正在运行的容器的-PID" class="headerlink" title="查看 Docker 正在运行的容器的 PID"></a>查看 Docker 正在运行的容器的 PID</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect --format &#x27;&#123;&#123; .State.Pid &#125;&#125;&#x27; dockerid</span><br></pre></td></tr></table></figure>

<h2 id="启动命令中增加-–-net"><a href="#启动命令中增加-–-net" class="headerlink" title="启动命令中增加 – net"></a>启动命令中增加 – net</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">不为进程启用 Network Namespace ，共享宿主机网络栈</span></span><br><span class="line">--net=host</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动一个容器并”加入“到另一个容器的 Network Namespace 里</span></span><br><span class="line">--net container:dockerid</span><br></pre></td></tr></table></figure>

<h2 id="查看-latest-真实版本"><a href="#查看-latest-真实版本" class="headerlink" title="查看 latest 真实版本"></a>查看 latest 真实版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image inspect imageid:latest | grep -i version</span><br></pre></td></tr></table></figure>

<h2 id="修改-Tag-标签"><a href="#修改-Tag-标签" class="headerlink" title="修改 Tag 标签"></a>修改 Tag 标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">example: docker tag f16c redis:7.0.11</span></span><br><span class="line">docker tag imageid REPOSITORY:TAG</span><br></pre></td></tr></table></figure>

<h2 id="查看-docker-磁盘使用情况"><a href="#查看-docker-磁盘使用情况" class="headerlink" title="查看 docker 磁盘使用情况"></a>查看 docker 磁盘使用情况</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Images</td>
<td>所有镜像占用的空间，包括拉取下来的镜像，和本地构建的。</td>
</tr>
<tr>
<td>Containers</td>
<td>运行的容器占用的空间，表示每个容器的读写层的空间。</td>
</tr>
<tr>
<td>Local Volumes</td>
<td>容器挂载本地数据卷的空间。</td>
</tr>
<tr>
<td>Build Cache</td>
<td>镜像构建过程中产生的缓存空间（只有在使用 BuildKit 时才有，Docker 18.09 以后可用）。</td>
</tr>
<tr>
<td>RECLAIMABLE</td>
<td>表示可回收的大小。</td>
</tr>
<tr>
<td>## 一键清理 Build Cache 命令</td>
<td></td>
</tr>
<tr>
<td>保留最近一定时间的缓存，删除时长更久的缓存，可以通过添加 ​​–filter​​ 参数实现</td>
<td></td>
</tr>
<tr>
<td>&#96;&#96;&#96;shell</td>
<td></td>
</tr>
<tr>
<td>docker builder prune</td>
<td></td>
</tr>
</tbody></table>
<h2 id="拉取指定平台的镜像"><a href="#拉取指定平台的镜像" class="headerlink" title="拉取指定平台的镜像"></a>拉取指定平台的镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--platform linux/amd64</span><br></pre></td></tr></table></figure>

<h2 id="格式化-ps-命令"><a href="#格式化-ps-命令" class="headerlink" title="格式化 ps 命令"></a>格式化 ps 命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps --format &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim ~/.docker/config.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;psFormat&quot;: &quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Names&#125;&#125;\t&#123;&#123;.Image&#125;&#125;\t&#123;&#123;.Status&#125;&#125;\t&#123;&#123;.Ports&#125;&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="保留最近10天的缓存示例命令"><a href="#保留最近10天的缓存示例命令" class="headerlink" title="保留最近10天的缓存示例命令"></a>保留最近10天的缓存示例命令</h1><p>docker builder prune –filter ‘until&#x3D;240h’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及 dangling 镜像（即无 tag 的镜像)</span><br><span class="line">```shell</span><br><span class="line">docker system prune​</span><br><span class="line"># 清理得更加彻底，可以将没有容器使用Docker镜像都删掉</span><br><span class="line">​​docker system prune -a</span><br></pre></td></tr></table></figure>

<h2 id="导出镜像"><a href="#导出镜像" class="headerlink" title="导出镜像"></a>导出镜像</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker save -o openjdk-21.tar openjdk:21-jdk</span><br></pre></td></tr></table></figure>

<h2 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load &lt; openjdk-21.tar</span><br></pre></td></tr></table></figure>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#x27;&#123;&#123;.Name&#125;&#125; - &#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java进阶训练营笔记</title>
    <url>/MiracleDx/2021/01/07/Java%20%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/</url>
    <content><![CDATA[<h1 id="JVM-核心技术-基础知识"><a href="#JVM-核心技术-基础知识" class="headerlink" title="JVM 核心技术-基础知识"></a>JVM 核心技术-基础知识</h1><h2 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h2><p><strong>Java bytecode</strong> 由单字节（byte）的指令组成，理论上最多支持 256 个操作吗，实际上 Java 只使用了 200 左右的操作码，一些操作码保留给调试操作<br>根据指令性质，分为 4 个大类</p>
<ol>
<li>栈操作指令，包括与局部变量交互的指令</li>
<li>程序流程控制指令</li>
<li>对象操作指令，包括方法调用指令</li>
<li>算数运算及类型转换指令</li>
</ol>
<p>编译：<code>javac xxx.java</code><br>查看字节码：<code>javap -c xxx</code><br>进一步查看字节码（可以看到版本号等信息）：<code>javap -c -verbose xxx</code><br>特别注意：</p>
<ul>
<li><p>aload、astore（a表示引用）表示从本地变量表加载到栈中，和运行后把栈中的值写回到本地变量表中</p>
</li>
<li><p>iload、istore 表示把本地变量表中 int 类型的值家在到栈中，和把栈中int类型的值写回到本地变量表中</p>
</li>
<li><p>iconst 表示 int 类型的常量</p>
</li>
<li><p>dstore 表示把 double 类型的变量写回到本地变量表中</p>
</li>
<li><p>i2d 表示把 int 类型转换为 double 类型</p>
</li>
<li><p>if_icmpge 表示条件语句判断 int 大于 for 的范围（cmp 比较、ge 大于）</p>
</li>
<li><p>iinc 表示一个 int 类型的自增 +1</p>
</li>
<li><p>goto 表示跳转</p>
</li>
</ul>
<p>一个 int 32 位 &#x3D; 4 个 byte<br>一个 long 64 位<br>一个 float 32 位<br>一个 double 64 位<br><em>64 位机器处理 int 和 long 类型均为原子操作</em></p>
<p><strong>算数操作</strong></p>
<table>
<thead>
<tr>
<th></th>
<th align="center">add +</th>
<th align="center">Sub -</th>
<th align="center">mult *</th>
<th align="center">divide &#x2F;</th>
<th align="center">remainder %</th>
<th align="center">negate -()</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td align="center">iadd</td>
<td align="center">sub</td>
<td align="center">imul</td>
<td align="center">idiv</td>
<td align="center">irem</td>
<td align="center">ineg</td>
</tr>
<tr>
<td>long</td>
<td align="center">ladd</td>
<td align="center">sub</td>
<td align="center">lmul</td>
<td align="center">ldiv</td>
<td align="center">lrem</td>
<td align="center">lneg</td>
</tr>
<tr>
<td>float</td>
<td align="center">fadd</td>
<td align="center">fsub</td>
<td align="center">f</td>
<td align="center">fdiv</td>
<td align="center">frem</td>
<td align="center">fneg</td>
</tr>
<tr>
<td>double</td>
<td align="center">dadd</td>
<td align="center">dsub</td>
<td align="center">d</td>
<td align="center">ddiv</td>
<td align="center">drem</td>
<td align="center">dneg</td>
</tr>
<tr>
<td><strong>类型转换 （row 代表 to、col 代表 from）</strong></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th align="center">int</th>
<th align="center">long</th>
<th align="center">float</th>
<th align="center">double</th>
<th align="center">byte</th>
<th align="center">char</th>
<th align="center">short</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td align="center">-</td>
<td align="center">i2l</td>
<td align="center">i2f</td>
<td align="center">i2d</td>
<td align="center">i2b</td>
<td align="center">i2c</td>
<td align="center">i2s</td>
</tr>
<tr>
<td>long</td>
<td align="center">l2i</td>
<td align="center">-</td>
<td align="center">l2f</td>
<td align="center">l2d</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td>float</td>
<td align="center">f2i</td>
<td align="center">f2l</td>
<td align="center">-</td>
<td align="center">f2d</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td>double</td>
<td align="center">d2i</td>
<td align="center">d2l</td>
<td align="center">d2f</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
</tbody></table>
<h2 id="字节码的运行时结构"><a href="#字节码的运行时结构" class="headerlink" title="字节码的运行时结构"></a>字节码的运行时结构</h2><p>JVM 是一台基于栈的计算机器<br>每个线程都有一个独属于自己的线程栈（JVM Stack），用于存储栈帧（Frame）<br>每次方法调用，JVM 都会自动创建一个栈帧<br>栈帧由操作数栈、局部变量数组以及一个 Class 引用组成<br>Class 引用指向当前方法在运行时常量池中对应的 Class</p>
<h2 id="方法调用的指令"><a href="#方法调用的指令" class="headerlink" title="方法调用的指令"></a>方法调用的指令</h2><ul>
<li>invokestatic，用于调用某个类的静态方法，是方法滴哦啊用指令中最快的一个</li>
<li>invokespecial，用于调用构造函数，也可以用于调用同一个类中的 private 方法 以及可见的超类方法</li>
<li>invokevirtual，如果是具体类型的目标对象，invokevirtual 用于调用公共，受保护和package级的私有方法</li>
<li>invokeinterface，当通过接口引用调用方法时，将会编译为 invokeinterface 指令</li>
<li>invokeddynamic，JDK7 新增指令，是实现“动态类型语言”（Dynamically Typed Language）支持而进行的升级改造，同时也是 JDK8 支持 lambda 表达式的实现基础</li>
</ul>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><ol>
<li>加载（Loading）：找 class 文件</li>
<li>验证（Verification）：验证格式、依赖</li>
<li>准备（Preparation）：静态字段、方法表</li>
<li>解析（Resolution）：符号解析为引用</li>
<li>初始化（Initialization）：构造器、静态变量赋值、静态代码块</li>
<li>使用（Using）</li>
<li>卸载（Unloading）<br><em>验证、准备、解析</em>可归为链接（Linking）</li>
</ol>
<h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><ol>
<li>虚拟机启动时，初始化用户指定的主类（main 方法所在的类）</li>
<li>遇到新建目标类实例的 new 指令时，初始化 new 指令的目标类（new 一个类的时候需要初始化）</li>
<li>遇到调用静态方式的指令时，初始化该静态方法所在的类</li>
<li>遇到访问静态字段的指令时，初始化该静态字段所在的类</li>
<li>子类的初始化会触发父类的初始化</li>
<li>如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口类的初始化，会触发该接口的初始化</li>
<li>使用反射 API 对某个类进行反射调用时，初始化这个类（反射调用要么是已经有实例，要么是静态方法，都需要初始化）</li>
<li>初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类</li>
</ol>
<h3 id="不会初始化的情况（可能会加载，但不会初始化）"><a href="#不会初始化的情况（可能会加载，但不会初始化）" class="headerlink" title="不会初始化的情况（可能会加载，但不会初始化）"></a>不会初始化的情况（可能会加载，但不会初始化）</h3><ol>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化</li>
<li>定义对象数组，不会触发该类的初始化</li>
<li>常量在编译器间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类</li>
<li>通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始化</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化（该参数是告诉虚拟机，是否要对类进行初始化）。Class.forNzame(“jvm.Hello”) 默认会加载 Hello 类</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载但不初始化）</li>
</ol>
<h3 id="三类加载器"><a href="#三类加载器" class="headerlink" title="三类加载器"></a>三类加载器</h3><ol>
<li>启动类加载器（BootstrapCLassLoader）</li>
</ol>
<ul>
<li>由 C++ 实现（针对 HotSpot），负责加载 <JAVA_HOME>&#x2F;lib 目录或 -Xbootclasspath 参数指定的路径中的类库</li>
</ul>
<ol start="2">
<li>扩展类加载器（ExtClassLoader）</li>
</ol>
<ul>
<li>负责加载  <JAVA_HOME>&#x2F;lib&#x2F;ext 或 java.ext.dirs 系统变量指定的路径中的所有类库</li>
</ul>
<ol start="3">
<li>应用类加载器（AppClassLoader）</li>
</ol>
<ul>
<li>负责加载用户类路径 classpath 上的指定类库，如果没有自定义类加载器，默认使用这个加载器<br>加载器特点：</li>
</ul>
<ol>
<li>双亲委派</li>
</ol>
<ul>
<li>如果一个类加载器收到类加载的请求，首先不会自己去尝试加载该类，而是把这个请求委派给父类加载器完成。每个类加载都是如此，只有当父加载器在自己的搜索范围内找不到指定类时，子加载器才会尝试自己加载。</li>
</ul>
<ol start="2">
<li>负责依赖</li>
<li>缓存加载</li>
</ol>
<p>自定义类加载的应用场景：</p>
<ol>
<li>加解密 Class 文件</li>
<li>资源隔离应用</li>
<li>动态创建定制化构建类</li>
</ol>
<h3 id="添加引用类的几种方式"><a href="#添加引用类的几种方式" class="headerlink" title="添加引用类的几种方式"></a>添加引用类的几种方式</h3><ol>
<li>放到 JDK 的 lib&#x2F;ext 下，或者 -Djava.ext.dirs</li>
<li>java -cp&#x2F;classpath 或者让 class 文件放到当前路径</li>
<li>自定义 ClassLoader 加载</li>
<li>拿到当前执行类的 ClassLoader，反射调用 addUrl 方法添加 Jar 或路径（JDK9 无效）</li>
</ol>
<h2 id="JVM-内存模型"><a href="#JVM-内存模型" class="headerlink" title="JVM 内存模型"></a>JVM 内存模型</h2><h3 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h3><ul>
<li>每个线程都只能访问自己的线程栈</li>
<li>每个线程都不能访问（看不见）其他线程的局部变量</li>
<li>所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的</li>
<li>线程可以将一个原生变量值的副本传给另一个线程，但不能共享局部变量本身</li>
<li>堆内存中包含了 Java 代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型（例如 Byte， Integer， Long）等</li>
<li>不管是创建一个对象并将其复制给局部变量，还是赋值给另一个对象的成员变量，创建的对象都会被保存到堆内存中</li>
<li>如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上</li>
<li>如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中</li>
<li>对象的成员变量与对象本身一起存储在堆上，不管成员变量的类型是原生数值，还是对象引用</li>
<li>类的静态变量则和类定义一样都保存在堆中<br><strong>总结：</strong></li>
</ul>
<ol>
<li>方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上</li>
<li>堆内存被多个线程共享，堆中的所有对象，可以被所有线程访问，只要该线程能拿到对象的引用地址</li>
<li>如果一个线程可以访问某个对象时，也可以访问该对象的成员变量</li>
<li>如果两个线程同时调用某个对象的同一方法，则他们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的</li>
</ol>
<h3 id="JVM-内存整体结构"><a href="#JVM-内存整体结构" class="headerlink" title="JVM 内存整体结构"></a>JVM 内存整体结构</h3><ul>
<li>每启动一个线程， JVM 就会在栈空间栈分配对应的线程栈，比如 1MB 的空间（-Xss1m）</li>
<li>线程栈也叫做 Java 方法栈，如果使用了 JNI 方法，则会分配一个单独的本地方法栈（Native Stack）</li>
<li>线程执行过程中，一般会有多个方法组成调用栈（Stack Trace），比如 A 调用 B， B 调用 C 等，每执行到一个方法，就会创建对应的栈帧（Frame）</li>
<li>栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后能基本确定</li>
</ul>
<p>**-Xmx4g 的 Java 进程实际使用可能会达到 5.x 到 6g 内存（栈、堆、非堆、JVM自身） ** ？？？？？<br>理论上：堆外可以用到和堆一样大的内存，但一般不用了这么多<br>一般 Xmx 不超过系统内存的 70%</p>
<h3 id="JVM-堆内存结构"><a href="#JVM-堆内存结构" class="headerlink" title="JVM 堆内存结构"></a>JVM 堆内存结构</h3><ul>
<li>堆内存是所有线程共用的内存空间，JVM 将 Heap 内存分为年轻代（Young generation）和老年代（Old generation，也叫 Tenured）两部分</li>
<li>年轻代划分为 3 个内存池，新生代（Eden Space）和存活区（Servivor Space），在大部分 GC 算法中有 2 个存活区（S0，S1），在可以观察到的任何时刻，S0 和 S1 总有一个是空的，但一般较小，不浪费空间<ul>
<li>年轻代、老年代的 GC 处理 一般是不同的（分代处理）</li>
</ul>
</li>
<li>Non-Heap 本质上还是 Heap，只是一般不归分为 GC 管理，里面划分为 3 个内存池</li>
<li>Metaspace  元数据区（持久代、永久代 Permanent generation）<ul>
<li>常量池</li>
<li>方法区</li>
</ul>
</li>
<li>CCS（Compressed Class Space）存放 Class 信息，和 Metaspace 有交叉</li>
<li>Code Cache 存放 JIT 编译器编译后的本地机器代码</li>
</ul>
<h3 id="CPU-与内存行为"><a href="#CPU-与内存行为" class="headerlink" title="CPU 与内存行为"></a>CPU 与内存行为</h3><ul>
<li>CPU 乱序执行</li>
<li>volatile 关键字</li>
<li>原子性操作</li>
<li>内存屏障</li>
</ul>
<h2 id="什么是-JMM"><a href="#什么是-JMM" class="headerlink" title="什么是 JMM"></a>什么是 JMM</h2><ul>
<li>JMM 规范对应的是 JSR-133.Java Memory Model and Thread Specifiaction</li>
<li>JMM 规范明确定义不同的线程之间，通过哪些方式，在什么时候可以看见其他线程保存到共享变量中的值，以及在必要时，如何对共享变量的访问进行同步。这样的好处是屏蔽各种硬件平台的内存访问差异，实现 Java 并发程序真正的跨平台</li>
<li>JMM 规范的是线程间的交互操作，而不管线程内部对局部变量进行的操作</li>
<li>所有的对象（包括内部的实例成员变量），static 变量以及数组，都必须放到堆内存中</li>
<li>局部变量，方法的形参&#x2F;入参，异常处理语句的入参不允许在线程之间共享，所以不受内存模型的影响</li>
<li>多个线程同时对一个变量访问时（读取&#x2F;写入），只要有某个线程执行的是写操作，那么这种线程就称为“冲突”</li>
<li>可以被其他线程影响或感知的操作，称为线程间的交互行为，分为：读取、写入、同步操作、外部操作等。<ul>
<li>同步操作包括：对 volatile 变量的读写，对管程（monitor）的锁定与解锁，线程的起始操作与结尾操作，线程启动和结束等</li>
<li>外部操作是指对线程执行环境之外的操作，比如停止其他线程等</li>
</ul>
</li>
</ul>
<h2 id="JVM-启动参数"><a href="#JVM-启动参数" class="headerlink" title="JVM 启动参数"></a>JVM 启动参数</h2><ul>
<li>以 - 开头为标准参数，所有的 JVM 都要实现这些参数，并且向后兼容</li>
<li>-D 设置系统属性</li>
<li>以 -X 开头为非标准实现参数，基本都是传递给 JVM 的，默认 JVM 实现这些参数的功能，但是不保证所有 JVM 实现都满足，且不保证向后兼容。可以使用 java -X 命令查看当前 JVM 支持的非标准参数</li>
<li>以 -XX: 开头为非稳定参数，专门用于控制 JVM 的行为，跟具体的 JVM 实现有关，随时可能会在下个版本取消<ul>
<li>-XX: +-Flags 形式，+-是对布尔值进行开关</li>
<li>-XX: key&#x3D;value 形式，指定某个选项的值</li>
</ul>
</li>
</ul>
<h3 id="JVM-启动参数的作用"><a href="#JVM-启动参数的作用" class="headerlink" title="JVM 启动参数的作用"></a>JVM 启动参数的作用</h3><ol>
<li>系统属性参数</li>
</ol>
<ul>
<li>-Dfile.encoding&#x3D;UTF-8</li>
<li>-Duser.timezone&#x3D;GMT+08</li>
<li>-Dmaven.test.skip&#x3D;true</li>
<li>-Dio.nett.eventLoopThreads&#x3D;8</li>
<li>System.setProperty(“a”, “100”)  String a &#x3D; System.getProperty(“a”)<ul>
<li>Linux 上可以通过 a&#x3D;100 java options 获取</li>
</ul>
</li>
</ul>
<ol start="2">
<li>运行模式参数</li>
</ol>
<ul>
<li>-server，设置 JVM 使用 server 模式，特点是启动速度比较慢，运行时性能和内存管理效率很高，适用于生产环境。在 64 位 JDK 环境下默认启用该模式，忽略 -client 参数</li>
<li>-client，JDK1.7 之前在 x86 机器上的默认值。设置 JVM 使用 client 模式，特点是启动速度较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者 PC 应用开发和调试</li>
<li>-Xint，在解释模式（interpreted mode）下运行，-Xint 标记会强制 JVM 解释执行所有的字节码，会降低运行速度，通常低 10 倍或更多</li>
<li>-Xcomp，-Xcomp 参数与 -Xint 正好相反，JVM 在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化（注意预热）</li>
<li>-Xmixed，-Xmixed 是混合模式，将解释模式和编译模式进行混合使用，由 JVM 自己决定。是 JVM 的默认模式，也是推荐模式。通过 java -version 可以看到 mixed mode 等信息</li>
</ul>
<ol start="3">
<li>堆内存设置参数</li>
</ol>
<ul>
<li>-Xmx，指定最大堆内存。只是限制了 Heap 部分的最大值，该内存不包括栈内存，也不包括堆外使用内存</li>
<li>-Xms，指定堆内存空间的初始大小。指定的内存大小，并不是操作系统实际分配的初始值，而是 GC 先规划好，用到才分配。专用服务器上需要保持 -Xms 和 -Xmx 保持一致，否则当应用刚启动可能会有几个 FullGC，当两者配置不一致时，堆内存扩容可能会导致性能抖动</li>
<li>-Xmn，等价于 -XX:NewSize，使用 G1 垃圾收集器不应该设置该选项，在其他的某些业务场景下可以设置，官方建议设置为 -Xmx 的 1&#x2F;2 ~ 1&#x2F;4</li>
<li>-XX:MaxPermSize&#x3D;size，JDK1.7 之前使用。Java8 默认运行 Meta 空间无限大，此参数无效</li>
<li>-XX:MaxMetaspaceSize&#x3D;size，Java8 默认不限制 Meta空间，一般不允许设置该选项</li>
<li>-XX:MaxDirectMemorySize，系统可以使用的最大堆内存，该参数与 -Dsun.nio.MaxDirectMemorySize 效果相同</li>
<li>-Xss，设置每个线程栈的字节数，该参数与 -XX:ThreadStackSize 效果相同</li>
</ul>
<ol start="4">
<li>GC 设置参数</li>
</ol>
<ul>
<li>JVM 启动参数 – GC 相关</li>
<li>-XX:+UseG1GC，使用 G1 垃圾回收器</li>
<li>-XX:+UseConcMarkSweepGC，使用 CMS 垃圾回收器</li>
<li>-XX:+UseSerialGC，使用串行垃圾回收器</li>
<li>-XX:+UseParallelGC，使用并行垃圾回收器</li>
<li>-XX:+UnlockExperimentalVMOptions -XX:+UseZGC，&#x2F;&#x2F; Java 11+</li>
<li>-XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC &#x2F;&#x2F; Java 12+</li>
</ul>
<ol start="5">
<li>分析诊断参数</li>
</ol>
<ul>
<li>-XX: +-HeapDumpOnOutOfMemoryError 选项，当 OutOfMemoryError 产生，即内存溢出（堆内存或持久代）时，自动 Dump 堆内存</li>
<li>-XX: HeapDumpPath 选项，与 HeapDumpOnOutOfMemoryError 搭配使用，指定内存溢出时 Dump 文件的目录（如果没有指定则默认为启动 Java 程序的工作目录）</li>
<li>自动Dump的 hprof 文件会存储到 &#x2F;usr&#x2F;local&#x2F; 目录下</li>
<li>-XX:OnError 选项，发生致命错误时（fatal error）执行的脚本</li>
<li>例如：通过脚本记录出错时间，执行一些命令或者 curl 某个在线报警的 url</li>
<li>-XX: OnOutOfMemoryError 选项，抛出 OutOfMemoryError 错误时执行的脚本</li>
<li>-XX: ErrorFile&#x3D;filename 选项，致命错误的日志文件名，绝对路径或者相对路径</li>
<li>-XDebug -Xrunjdwp:transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;1506 选成调试</li>
</ul>
<ol start="6">
<li>JavaAgent 参数<br>  Agent 是 JVM 中的黑科技，可以通过无侵入方式做很多事情，比如注入 AOP 代码，执行统计等，权限非常大。<br>  设置 Agent 的语法：</li>
</ol>
<ul>
<li>-agentlib:libname[&#x3D;options] 启用 native 方式的 agent，参考 LD_LIBRARY_PATH 路径</li>
<li>agentpath:pathname[&#x3D;options] 启动 native 方式的 agent</li>
<li>-javaagent:jarpath[&#x3D;options] 启用外部的 agent 库</li>
<li>-Xnoagent 禁用所有 agent</li>
</ul>
<h1 id="Java-命令行工具"><a href="#Java-命令行工具" class="headerlink" title="Java 命令行工具"></a>Java 命令行工具</h1><table>
<thead>
<tr>
<th align="center">工具</th>
<th align="center">简介</th>
</tr>
</thead>
<tbody><tr>
<td align="center">jps 、jinfo</td>
<td align="center">查看 Java 进程</td>
</tr>
<tr>
<td align="center">jstat</td>
<td align="center">查看 JVM 内部 gc 相关信息</td>
</tr>
<tr>
<td align="center">jmap</td>
<td align="center">查看 heap 或 类占用空间统计</td>
</tr>
<tr>
<td align="center">jstack</td>
<td align="center">查看线程信息</td>
</tr>
<tr>
<td align="center">jcmd</td>
<td align="center">执行 JVM 相关分析命令（整合命令）</td>
</tr>
<tr>
<td align="center">jrunscript、jjs</td>
<td align="center">执行 js 命令</td>
</tr>
</tbody></table>
<h1 id="GC-的背景与一般原理"><a href="#GC-的背景与一般原理" class="headerlink" title="GC 的背景与一般原理"></a>GC 的背景与一般原理</h1><p>可以作为 GC Roots 的对象</p>
<ul>
<li>当前正在执行的方法里的局部变量和输入参数</li>
<li>活动线程（Active threads）</li>
<li>所有类的静态子弹（static field）</li>
<li>JNI 引用</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池</title>
    <url>/MiracleDx/2020/01/07/Java%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="CPU-密集型"><a href="#CPU-密集型" class="headerlink" title="CPU 密集型"></a>CPU 密集型</h1><h2 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h2><p>最大线程数 &#x3D; CPU 核心数 + 1<br>额外的线程能确保 CPU 的时钟周期不会被浪费，从而保证 CPU 的利用率。</p>
<h2 id="核心线程数"><a href="#核心线程数" class="headerlink" title="核心线程数"></a>核心线程数</h2><p>核心线程数 &#x3D; CPU 核心数 或 CPU 核心数 + 1</p>
<h1 id="IO-密集型"><a href="#IO-密集型" class="headerlink" title="IO 密集型"></a>IO 密集型</h1><ol>
<li>《Java 虚拟机并发编程》中推荐的计算方法<br> CPU 中可以满负荷运行的最大线程数 &#x3D; CPU 核心数 &#x2F; （1 - 阻塞系数）<br> 阻塞系数 &#x3D; 调用 IO 时间 &#x2F; 请求时长<br> 阻塞系数一般认为在 0.8 ~ 0.9 之间</li>
<li>《Java 并发编程实战》中推荐的计算方法<br> 线程数 &#x3D; CPU 核心数 * （1 + IO 耗时 &#x2F; CPU 耗时）</li>
</ol>
<h2 id="最大线程数-1"><a href="#最大线程数-1" class="headerlink" title="最大线程数"></a>最大线程数</h2><p>最大线程数 &#x3D; CPU 核心数 * 2</p>
<h2 id="核心线程数-1"><a href="#核心线程数-1" class="headerlink" title="核心线程数"></a>核心线程数</h2><p>核心线程数 &#x3D; 最大线程数 * 20%</p>
<h1 id="混合型"><a href="#混合型" class="headerlink" title="混合型"></a>混合型</h1><p>核心线程数 &#x3D; （线程等待时间 &#x2F; 线程 CPU时间 + 1） * CPU 核心数</p>
<h1 id="如何根据实际情况规划线程数"><a href="#如何根据实际情况规划线程数" class="headerlink" title="如何根据实际情况规划线程数"></a>如何根据实际情况规划线程数</h1><ol>
<li>分析当前主机上，有没有其他进程干扰</li>
<li>分析当前 JVM 进程上，有没有其他运行中或可能运行的线程</li>
<li>设定目标</li>
<li>目标 CPU 利用率 - 最高能容忍的 CPU 使用率</li>
<li>目标 GC 频率&#x2F;暂停时间 - 多线程执行后，GC 频率会增高，最大能容忍到什么频率，每次暂停时间多少？</li>
<li>执行效率 - 比如批处理时，单位时间内要开多少线程才能及时处理完毕</li>
<li>……</li>
<li>梳理链路关键点，是否有卡脖子的点，因为如果线程数过多，链路上某些节点资源有限可能会导致大量的线程在等待资源（比如三方接口限流，连接池数量有限，中间件压力过大无法支撑等）</li>
<li>不断的增加&#x2F;减少线程数来测试，按最高的要求去测试，最终获得一个“满足要求”的线程数</li>
</ol>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Llama2 部署</title>
    <url>/MiracleDx/2023/10/18/Llama2%20%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Llama-模型"><a href="#Llama-模型" class="headerlink" title="Llama 模型"></a>Llama 模型</h1><p><a href="https://github.com/FlagAlpha/Llama2-Chinese">FlagAlpha&#x2F;Llama2-Chinese: Llama中文社区，最好的中文Llama大模型，完全开源可商用</a><br><a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca">ymcui&#x2F;Chinese-LLaMA-Alpaca: 中文LLaMA&amp;Alpaca大语言模型+本地CPU&#x2F;GPU训练部署 (Chinese LLaMA &amp; Alpaca LLMs)</a></p>
<h1 id="llama-cpp-部署"><a href="#llama-cpp-部署" class="headerlink" title="llama.cpp 部署"></a>llama.cpp 部署</h1><p>参考文档部署即可<br><a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca">ymcui&#x2F;Chinese-LLaMA-Alpaca: 中文LLaMA&amp;Alpaca大语言模型+本地CPU&#x2F;GPU训练部署 (Chinese LLaMA &amp; Alpaca LLMs)</a><br><strong>模型使用需要进行量化</strong></p>
<h1 id="编程语言实现"><a href="#编程语言实现" class="headerlink" title="编程语言实现"></a>编程语言实现</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><p><a href="https://github.com/kherud/java-llama.cpp">kherud&#x2F;java-llama.cpp: Java Bindings for llama.cpp - A Port of Facebook’s LLaMA model in C&#x2F;C++</a><br>如果部署了 llama.cpp 可以直接通过 java api 进行调用</p>
<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p><a href="https://github.com/abetlen/llama-cpp-python">abetlen&#x2F;llama-cpp-python: Python bindings for llama.cpp</a><br>可以通过 llama-cpp-python[server] 启动 open api 的兼容接口</p>
]]></content>
      <categories>
        <category>AIGC</category>
      </categories>
      <tags>
        <tag>Llama</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven</title>
    <url>/MiracleDx/2020/05/18/Maven/</url>
    <content><![CDATA[<h1 id="scope-provided-和-optional-true-的区别"><a href="#scope-provided-和-optional-true-的区别" class="headerlink" title="scope provided 和 optional &#x3D; true 的区别"></a>scope provided 和 optional &#x3D; true 的区别</h1><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><p>两者都不会将依赖直接打入包中</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>provided 表示某个依赖必须，该依赖通常是由系统或者容器提供</li>
<li>optional 表示某个依赖可选，该依赖是否使用都不会影响服务运行</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka基础</title>
    <url>/MiracleDx/2022/07/08/Kafka%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>是一款开源的消息引擎系统，可以利用该系统在不同系统之间传递语义准确的消息，实现松耦合的异步式数据传递。<br>也是一个分布式流处理平台（Distributed Streaming Platform）<br>在设计之初提供了三个特性：</p>
<ul>
<li>提供一套 API 实现生产者和消费者</li>
<li>降低网络传出和磁盘存储开销</li>
<li>实现高伸缩性架构</li>
</ul>
<h3 id="流处理组件-Kafka-Streams"><a href="#流处理组件-Kafka-Streams" class="headerlink" title="流处理组件 - Kafka Streams"></a>流处理组件 - Kafka Streams</h3><p>Kafka 与其他主流大数据流式计算框架的优势</p>
<ul>
<li>更容易实现到端到端的正确性（Correctness）<br>替代批处理需要具备两点<br>1.要实现正确性和提供能够推导时间的工具</li>
<li>实现正确性的基石：框架提供精确一次处理语义<br>精确一次处理语义：一条消息有且只有一次机会能够影响系统状态<br>2.实现正确性是流处理能够匹敌批处理的基石</li>
<li>Kafka 自身对于流式计算的定位<br>官网标识 Kafka Streams 是一个用于搭建实时流处理的客户端库而不是一个完整的系统</li>
</ul>
<h3 id="连接器-Kafka-Connect"><a href="#连接器-Kafka-Connect" class="headerlink" title="连接器 - Kafka Connect"></a>连接器 - Kafka Connect</h3><p>Kafka Connect 通过一个个具体的连接器（Connector）串联起上下游的外部系统</p>
<h3 id="Kafka-版本"><a href="#Kafka-版本" class="headerlink" title="Kafka 版本"></a>Kafka 版本</h3><h4 id="Apache-Kafka"><a href="#Apache-Kafka" class="headerlink" title="Apache Kafka"></a>Apache Kafka</h4><p>是最 “正宗” 的 Kafka，也被称为社区版 Kafka，是所有其他发行版的基础</p>
<ul>
<li>优势</li>
<li>开发人数最多、 版本迭代速度最快</li>
<li>社区活跃</li>
<li>有更高的把控度</li>
<li>劣势</li>
<li>仅提供最最基础的组件</li>
<li>社区版 Kafka 只提供一种连接器</li>
<li>没有提供任何监控框架或工具<br>如果仅需要一个消息引擎系统或者简单的流处理应用场景，同时需要对系统有较大把控度，推荐使用 Apache Kafka</li>
</ul>
<h4 id="Confluent-Kafka"><a href="#Confluent-Kafka" class="headerlink" title="Confluent Kafka"></a>Confluent Kafka</h4><p>Kafka 的三个创始人创办的公司，专注于提供基于 Kafka 的企业级流处理解决方案</p>
<ul>
<li>优势<br>Kafka 原版人马打造，质量有保证，分为免费版和企业版</li>
<li>社区版</li>
<li>和 Apache Kafka 非常像</li>
<li>提供：Schema 注册中心<br>帮助集中管理 Kafka 消息格式以实现数据向前 &#x2F; 向后兼容</li>
<li>提供：REST Proxy<br>通过开放 HTTP 接口的方式提供网络访问 Kafka 的各种功能<br>包含更多的连接器</li>
<li>企业版</li>
<li>跨数据中心备份</li>
<li>集群监控</li>
<li>等</li>
<li>劣势</li>
<li>相关资料及技术支持都很欠缺</li>
<li>在国内的普及率比较低<br>如果需要用到 Kafka 的一些高级特性，推荐使用 Confluent Kafka</li>
</ul>
<h4 id="Cloudera-Hortonworks-Kafka"><a href="#Cloudera-Hortonworks-Kafka" class="headerlink" title="Cloudera &#x2F; Hortonworks Kafka"></a>Cloudera &#x2F; Hortonworks Kafka</h4><p>Cloudera 提供的 CDH 和 Hortonworks 提供的 HDP 是非常著名的大数据平台，里面集成了目前主流的大数据框架，能够帮助用户实现从分布式存储、集群调度、流处理到机器学习、实时数据库等全方位的数据处理</p>
<ul>
<li>优势</li>
<li>天然集成 Apache Kafka</li>
<li>通过 UI 界面将 Kafka 的安装、运维、管理、监控统一在控制台中</li>
<li>提供监控界面</li>
<li>劣势</li>
<li>降低了对 Kafka 集群的掌控程度</li>
<li>版本滞后性<br>如果需要快速的搭建消息引擎系统，或者需要搭建多框架构成的数据平台且 Kafka 只是其中一个组件，推荐使用大数据云公司提供的 Kafka</li>
</ul>
<h3 id="Kafka-监控工具"><a href="#Kafka-监控工具" class="headerlink" title="Kafka 监控工具"></a>Kafka 监控工具</h3><ul>
<li>Kafka Manager</li>
<li>Kafka eagle</li>
<li>JMXTrans + InfluxDB + Grafana</li>
<li>滴滴开源 Logi-KafkaManager<br><a href="https://github.com/didi/Logi-KafkaManager">https://github.com/didi/Logi-KafkaManager</a></li>
</ul>
<h3 id="Kafka-性能测试工具"><a href="#Kafka-性能测试工具" class="headerlink" title="Kafka 性能测试工具"></a>Kafka 性能测试工具</h3><p>Kafka 自己提供 <code>kafka-producer-pref-test</code> 和 <code>kafka-consumer-perf-test</code> 脚本</p>
<h2 id="基础的消息引擎"><a href="#基础的消息引擎" class="headerlink" title="基础的消息引擎"></a>基础的消息引擎</h2><ul>
<li>传输的对象是消息（Kafka 默认是二进制字节，支持自定义 Serialize 和 DeSerialize）</li>
<li>Google Protocol Buffer</li>
<li>Facebook Thrift</li>
<li>CSV</li>
<li>XML</li>
<li>JSON</li>
<li>消息传输的具体协议</li>
<li>点对点模型</li>
<li>系统 A 发送的消息只能被系统 B 接收，其他系统不能读取 A 发送的消息</li>
<li>举例：电话客服</li>
<li>发布 &#x2F; 订阅模型</li>
<li>消息容器 - Topic</li>
<li>发布者 - Publisher</li>
<li>订阅者 - Subscriber</li>
<li>举例：报纸</li>
</ul>
<h2 id="JMS（Java-Message-Service）"><a href="#JMS（Java-Message-Service）" class="headerlink" title="JMS（Java Message Service）"></a>JMS（Java Message Service）</h2><p>Java 标准协议</p>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Topic-主题"><a href="#Topic-主题" class="headerlink" title="Topic - 主题"></a>Topic - 主题</h3><p>发布订阅的对象</p>
<h3 id="Kafka-客户端-Clients"><a href="#Kafka-客户端-Clients" class="headerlink" title="Kafka 客户端 - Clients"></a>Kafka 客户端 - Clients</h3><p>Producer 和 Consumer 统称为 Clients</p>
<h5 id="Producer-生产者"><a href="#Producer-生产者" class="headerlink" title="Producer - 生产者"></a>Producer - 生产者</h5><ul>
<li>向主题发布消息的客户端应用程序</li>
</ul>
<h5 id="Consumer-消费者"><a href="#Consumer-消费者" class="headerlink" title="Consumer - 消费者"></a>Consumer - 消费者</h5><ul>
<li>订阅主题的客户端应用程序</li>
</ul>
<h6 id="Consumer-Offset-消费者位移"><a href="#Consumer-Offset-消费者位移" class="headerlink" title="Consumer Offset - 消费者位移"></a>Consumer Offset - 消费者位移</h6><p>每个消费者在消费消息的过程中记录当前消费到分区的位置的字段，是随时变化的，每个消费者有自己的消费者位移</p>
<h6 id="ConsumerGroup-消费者组"><a href="#ConsumerGroup-消费者组" class="headerlink" title="ConsumerGroup - 消费者组"></a>ConsumerGroup - 消费者组</h6><p>指多个消费者实例共同组成一个组消费一组主题<br>这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费</p>
<h6 id="为什么要引入消费者组"><a href="#为什么要引入消费者组" class="headerlink" title="为什么要引入消费者组"></a>为什么要引入消费者组</h6><p>为了提升消费者端的吞吐量，多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）</p>
<h5 id="Rebalance-重平衡"><a href="#Rebalance-重平衡" class="headerlink" title="Rebalance - 重平衡"></a>Rebalance - 重平衡</h5><p>当消费者组内的某个消费者实例挂掉以后， Kafka 能够自主检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者，是 Kafka Bug 的主要来源之一</p>
<h3 id="Kafka-服务端-Borker"><a href="#Kafka-服务端-Borker" class="headerlink" title="Kafka 服务端 - Borker"></a>Kafka 服务端 - Borker</h3><p>一个 Kafka 服务端由多个 Broker 服务进程构成<br>Broker 负责接收和处理客户端发送过来的请求，并对消息进行持久化</p>
<h4 id="Kafka-提供高可用的手段之一-集群"><a href="#Kafka-提供高可用的手段之一-集群" class="headerlink" title="Kafka 提供高可用的手段之一 - 集群"></a>Kafka 提供高可用的手段之一 - 集群</h4><p>多个 Broker 的部署在不同服务器上，某一台机器宕机也不影响其他机器上的Broker 对外提供服务</p>
<h4 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h4><p>使用消息日志（Log）保存数据，一个日志是磁盘上的一个只能追加写（Append-only）消息的物理文件</p>
<h5 id="实现-Kafka-高吞吐量特性的重要手段"><a href="#实现-Kafka-高吞吐量特性的重要手段" class="headerlink" title="实现 Kafka 高吞吐量特性的重要手段"></a>实现 Kafka 高吞吐量特性的重要手段</h5><p>因为只能追加写入，使用性能较好的顺序 I&#x2F;O 写操作，避免了缓慢的随机 I&#x2F;O 操作</p>
<h4 id="持久化数据的回收"><a href="#持久化数据的回收" class="headerlink" title="持久化数据的回收"></a>持久化数据的回收</h4><p>通过日志段（Log Segment）机制，在 Kafka 底层，将日志切分成多个日志段，消息被追加写到当前最新的日志段中，当写满一个日志段之后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka 在后台会有定时任定期检查老的日志段是否能够被删除</p>
<h3 id="Replica-副本"><a href="#Replica-副本" class="headerlink" title="Replica - 副本"></a>Replica - 副本</h3><p>把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本，副本的数量是可以配置的，这些副本保存着相同的数据，但却有不同的角色和作用</p>
<ul>
<li>Leader Replica - 领导者副本</li>
<li>与客户端进行交互</li>
<li>Follower Replica - 追随者副本</li>
<li>被动追随领导者副本，不与外界进行交互<br>副本机制可以保证数据的持久化或消息不丢失</li>
</ul>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>生产者向 Leader 写消息，消费者从 Leader 读消息，Follower 向 Leader 发送请求，请求 Leader 同步最新的消息给自己，保持与 Leader 的同步</p>
<h3 id="Partitioning-分片"><a href="#Partitioning-分片" class="headerlink" title="Partitioning - 分片"></a>Partitioning - 分片</h3><p>与 MongoDB ES 中的 Sharding 和 HBase 中的 Region 概念相同</p>
<h4 id="分区（Partition）机制"><a href="#分区（Partition）机制" class="headerlink" title="分区（Partition）机制"></a>分区（Partition）机制</h4><p>分区机制保证了数据的伸缩性，提供了负载均衡的能力<br>指将每个主题划分为多个分区，每个分区是一组有序的消息日志<br>生产者生产的每条消息只会被发送到一个分区中<br>Kafka 的分区编号是从 0 开始计数的<br>每个分区可以有若干个副本，但其中只能有一个 Leader 副本 和 N - 1 个 Folllower 副本</p>
<h4 id="Partition-Offset-分区位移"><a href="#Partition-Offset-分区位移" class="headerlink" title="Partition Offset - 分区位移"></a>Partition Offset - 分区位移</h4><p>生产者向 Partition 写入消息，每条消息在分区中的位置信息用 Offset（位移）表示，一旦消息被成功写入到一个分区上，这个位移值就是固定的</p>
<h2 id="Kafka-的三层消息结构"><a href="#Kafka-的三层消息结构" class="headerlink" title="Kafka 的三层消息结构"></a>Kafka 的三层消息结构</h2><p>客户端程序只能与分区的 Leader 副本进行交互</p>
<h3 id="第一层-主题层"><a href="#第一层-主题层" class="headerlink" title="第一层 - 主题层"></a>第一层 - 主题层</h3><p>每个主题可以配置 M 个分区，每个分区可以配置 N 个副本</p>
<h3 id="第二层-分区层"><a href="#第二层-分区层" class="headerlink" title="第二层 - 分区层"></a>第二层 - 分区层</h3><p>每个分区的 N 个副本中，只能有一个 Leader 副本对外提供服务，其他 N - 1 个副本是 Follower，只提供数据冗余</p>
<h3 id="第三层-消息层"><a href="#第三层-消息层" class="headerlink" title="第三层 - 消息层"></a>第三层 - 消息层</h3><p>分区中包含若干条消息，每条消息的位移从 0 开始，依次递增</p>
<h2 id="Kafka-名词术语"><a href="#Kafka-名词术语" class="headerlink" title="Kafka 名词术语"></a>Kafka 名词术语</h2><p>消息：Record。指 Kafka 处理的主要对象<br>主题：Topic。主题是承载消息的逻辑容器，在实际使用中多用来区分具体的业务<br>分区：Partition。一个有序不变的消息序列，每个主题下可以有多个分区<br>消息位移：Offset。表示分区中每条消息的位置信息，是一个单调递增且不变的值<br>副本：Replica。Kafka 中同一条消息被拷贝到多个地方以提供数据冗余，副本分为领导者副本和追随者副本，各自有不同的角色划分。副本是在分区层级下的，即每个分区可配置多个副本实现高可用<br>生产者：Producer。向主题发布新消息的应用程序<br>消费者：Consumer。从主题订阅新消息的应用程序<br>消费者位移：Consumer Offset。表征消费者消费进度，每个消费者都有自己的消费者位移<br>消费者组：Consumer Group。多个消费者实例共同组成的一个组，同时消费多个分区以实现高吞吐<br>重平衡：Rebalance。消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。Rebalance 是 Kafka 消费者端实现高可用的重要手段</p>
<h2 id="Kafka-版本命名"><a href="#Kafka-版本命名" class="headerlink" title="Kafka 版本命名"></a>Kafka 版本命名</h2><ul>
<li>Scale 2.11 - kafka_2.11-2.2.1.tgz(asc, sha512)</li>
<li>2.11 scale 的编译版本</li>
<li>2.2.1 Kafka版本号</li>
<li>大版本号-小版本号-Patch 号</li>
</ul>
<h3 id="Kafka-版本演进"><a href="#Kafka-版本演进" class="headerlink" title="Kafka 版本演进"></a>Kafka 版本演进</h3><ul>
<li>0.7 版本：只提供最基础的消息队列功能</li>
<li>0.8 版本：引入了副本机制，至此 Kafka 成为一个真正意义上完备的分布式高可靠消息队列解决方案</li>
<li>0.9.0.0 版本：增加基础的安全认证 &#x2F; 权限功能，使用 Java 重写了新版本消费者 API，引入了 Kafka Connect 组件</li>
<li>0.10.0.0 版本：引入了 Kafka Streams，正式升级成分布式流处理平台</li>
<li>0.11.0.0 版本：提供了幂等性 Producer API 以及事务 API，对 Kafka 消息格式做了重构</li>
<li>1.0 和 2.0 版本：主要对 Kafka Streams 的改进</li>
</ul>
<h2 id="Kafka-线上集群部署方案"><a href="#Kafka-线上集群部署方案" class="headerlink" title="Kafka 线上集群部署方案"></a>Kafka 线上集群部署方案</h2><p>Linux 在以下三个方面，优于 Windows Server 和 Mac OS Server</p>
<ul>
<li>I &#x2F; O 模型的使用</li>
<li>数据网络传输效率</li>
<li>社区支持度</li>
</ul>
<h3 id="主流的-I-O-模型"><a href="#主流的-I-O-模型" class="headerlink" title="主流的 I &#x2F; O 模型"></a>主流的 I &#x2F; O 模型</h3><p>按照低级 -&gt; 高级顺序排列</p>
<ul>
<li>阻塞式 I &#x2F; O - Java Socket 对象</li>
<li>非阻塞式 I &#x2F; O - Java Socket 对象<br>-I &#x2F; O 多路复用 - Linux 系统调用 Select 函数</li>
<li>信号驱动 I &#x2F; O</li>
<li>异步 I &#x2F; O - Linux 很少支持，Windows 提供 IOCP 的线程模型<br>epoll 系统调用介于I &#x2F; O 多路复用和信号驱动 I &#x2F; O 之间<br>Kafka 客户端底层使用了 Java 的 Selector，Selector 在 Linux 上的实现机制是 epoll，在 Windows 平台上的实现机制是 select</li>
</ul>
<h3 id="网络传输效率"><a href="#网络传输效率" class="headerlink" title="网络传输效率"></a>网络传输效率</h3><p>Kafka 生产和消费的消息都是通过网络传输的，消息需要保存在磁盘上，所有 Kafka 需要在磁盘和网络之间进行大量数据传输</p>
<h4 id="零拷贝（Zero-Copy）"><a href="#零拷贝（Zero-Copy）" class="headerlink" title="零拷贝（Zero Copy）"></a>零拷贝（Zero Copy）</h4><p>当数据在磁盘和网络进行传输时避免昂贵的内核态数据拷贝从而实现快速的数据传输<br>Linux 平台实现了零拷贝技术，Windows 平台需要等到 Java 8 的 60 更新版本</p>
<h3 id="社区支持度"><a href="#社区支持度" class="headerlink" title="社区支持度"></a>社区支持度</h3><p>Windows 上的 Bug 一般不会修复，Windows 平台上部署 Kafka 只适用于个人测试或用于功能验证</p>
<h3 id="磁盘规划和选择"><a href="#磁盘规划和选择" class="headerlink" title="磁盘规划和选择"></a>磁盘规划和选择</h3><ul>
<li>机械磁盘：成本低容量大，易损坏</li>
<li>固态磁盘：性能优势大，单价高</li>
<li>通常 SSD 的顺序写 TPS 大约是 HDD 的 4 倍<br>建议使用普通机械磁盘：Kafka 使用的方式多是顺序读写操作，一定程度上规避了机械磁盘最大的劣势（随机读写操作慢）</li>
</ul>
<h4 id="磁盘阵列（RAID）"><a href="#磁盘阵列（RAID）" class="headerlink" title="磁盘阵列（RAID）"></a>磁盘阵列（RAID）</h4><p>使用 RAID 的两个优势</p>
<ul>
<li>提供冗余的磁盘存储空间</li>
<li>提供负载均衡<br>追求性价比的公司可以不搭建 RAID，使用普通磁盘组成存储空间即可：Kafka 自己实现了冗余机制提供高可靠性，通过分区的概念在软件层面实现了负载均衡</li>
</ul>
<h3 id="磁盘容量"><a href="#磁盘容量" class="headerlink" title="磁盘容量"></a>磁盘容量</h3><p>规划磁盘容量时，需要考虑</p>
<ul>
<li>新增消息数</li>
<li>消息留存时间</li>
<li>平均消息大小</li>
<li>备份数</li>
<li>是否启用压缩<br>假设每天 1 亿条 1KB 大小的消息，保存两份且留存两周的时间，那么总的空间大小就等于 1 亿 * 1KB * 2 &#x2F; 1000 &#x2F; 1000 &#x3D; 200GB。一般情况下 Kafka 集群除了消息数据还有其他类型的数据，比如索引数据等，故再为这些数据预留出 10% 的磁盘空间，因此总的存储容量就是 220GB。既然要保存两周，那么整体容量即为 220GB * 14，大约 3TB 左右。Kafka 支持数据的压缩，假设压缩比是 0.75，那么最后需要规划的存储空间就是 0.75 * 3 &#x3D; 2.25TB</li>
</ul>
<h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p>带宽资源的规划，实际规划的是所需的 Kafka 服务器的数量<br>假设机房环境是千兆网络，即 1Gbps，业务目标或 SLA 是在 1 个小时内处理 1TB 的业务数据。带宽是 1 Gbps，即 1 秒处理 1 Gb 的数据，假设 Kafka 服务器为专属服务器，没有混布其他服务，只能假设 Kafka 会用到 70% 的带宽资源，因为要为其他应用或进程保留一些资源。根据实际经验，超过 70% 的阈值就有网络丢包的可能，也就说单台 Kafka 服务器最多能使用大约 700Mb 的带宽资源。这是指 Kafka 服务器能使用的最大带宽，常规使用需要额外预留出 2 &#x2F; 3 的资源，即单台服务器使用带宽 700 Mb &#x2F; 3 ≈ 240 Mbps。计算 1 小时处理 1TB 数据所需的服务器数量，即每秒处理数据量：1024 * 1024 &#x2F; 3600 ≈ 291 MB，291 * 8 ≈ 2330 Mbps，除以 240 约等于 10 台服务器，如果每条消息有两个副本，则总服务器数据量还需要 * 3 &#x3D; 30 台</p>
<ul>
<li>带宽资源一般用 Mbps 而不是 MBps 衡量</li>
<li>1 MB &#x3D; 8 Mb</li>
<li>B &#x3D; Byte</li>
<li>b &#x3D; b</li>
</ul>
<h2 id="Kafka-集群参数配置"><a href="#Kafka-集群参数配置" class="headerlink" title="Kafka 集群参数配置"></a>Kafka 集群参数配置</h2><h3 id="Broker-端参数"><a href="#Broker-端参数" class="headerlink" title="Broker 端参数"></a>Broker 端参数</h3><h4 id="存储信息的重要参数"><a href="#存储信息的重要参数" class="headerlink" title="存储信息的重要参数"></a>存储信息的重要参数</h4><p>即 Broker 使用哪些磁盘</p>
<ul>
<li>log.dirs：指定 Broker 需要使用的若干个文件目录路径，没有默认值，必须指定</li>
<li>log.dir：表示单个路径，补充 log.dirs<br>一般只需要设置 log.dirs，不需要设置 log.dir，线上生产环境一定要配置多个路径（以 “，” 分隔），有条件最好挂载到不同的物理磁盘上。这样做的好处：</li>
<li>提升读写性能：多块磁盘同时读写数据有更高的吞吐量</li>
<li>能够实现故障转移：即 Failover。Kafka 1.1 版本引入的强大功能，坏掉的磁盘数据会自动转移到其他正常的磁盘上，而且 Broker 还能正常工作，没有 Failover 只能依靠 RAID 提供保障</li>
<li>Broker 自动在好的路径上重建副本，然后从 Leader 同步</li>
<li>Kafka 支持工具能够将某个路径上的数据拷贝到其他路径上</li>
</ul>
<h4 id="与-Zookeeper-相关的配置"><a href="#与-Zookeeper-相关的配置" class="headerlink" title="与 Zookeeper 相关的配置"></a>与 Zookeeper 相关的配置</h4><p>Zookeeper 是一个分布式协调框架，负责协调管理并保存 Kafka 集群的所有元数据信息</p>
<ul>
<li>哪些 Broker 在运行</li>
<li>创建了哪些 Topic</li>
<li>每个 Topic 都有哪些分区</li>
<li>分区的 Leader 副本都在哪些机器上</li>
<li>等<br>最重要的参数是：zookeeper.connect，用于指定 Kafka 连接的 Zookeeper 集群<br>多个 Kafka 集群使用同一套 Zookeeper 集群，需要使用 chroot（Zookeeper 概念，类似别名），eg：</li>
<li>Kafka 集群1：zk1:2181,zk2:2181,zk3:2181&#x2F;kafka1</li>
<li>Kafka 集群2：zk1:2181,zk2:2181,zk3:2181&#x2F;kafka2</li>
</ul>
<h4 id="与-Broker-连接相关的"><a href="#与-Broker-连接相关的" class="headerlink" title="与 Broker 连接相关的"></a>与 Broker 连接相关的</h4><p>客户端程序或其他 Broker 如何与该 Broker 进行通信的设置</p>
<ul>
<li>listeners：监听器，告诉外部连接着需要通过什么协议访问指定主机名和端口开放的 Kafka 服务</li>
<li>advertised.listeners：advertised 表示宣称的、公开的，表明这组监听器是 Broker 用于对外发布的</li>
<li>host.name &#x2F; port：过期参数，无用</li>
</ul>
<h5 id="监听器概念"><a href="#监听器概念" class="headerlink" title="监听器概念"></a>监听器概念</h5><p>若干个逗号分隔的三元组，每个三元组的格式为：&lt;协议名称，主机名，端口号&gt;，协议名称可能是标准的名字，比如 PLAINTEXT 表示明文传输、SSL 表示使用 SSL 或 TLS 加密传输等，也可以是自定义的协议名称，eg：<code>CONTROLLER: //localhost:9092</code><br>一旦定义了自定义协议名称，还必须指定 listener.security.protocol.map 参数告诉该协议底层使用了哪种安全协议，eg：<code>listener.security.protocol.map=CONTROLLER:PLAINTEXT 表示 CONTROLLER </code>这个自定义协议底层使用明文不加密传输数据<br>三元组中的主机名设置，最好全部使用主机名，即 Broker 和 Client 端应用配置中全部填写主机名，如果在某些地方使用了 IP，可能会发生无法连接的问题</p>
<h4 id="Topic-管理"><a href="#Topic-管理" class="headerlink" title="Topic 管理"></a>Topic 管理</h4><ul>
<li>auto.create.topics.enable：是否允许自动创建 Topic<br>建议设置成 false，Topic 应该严格把控，不能允许自行创建任何 Topic</li>
<li>unclean.leader.election.enable：是否允许 Unclean Leader 选举</li>
<li>设置成 false，坚决不能让数据保存较少的副本成为 Leader</li>
<li>设置成 true，允许从数据保存较少的副本中选出一个 Leader，后果是数据有可能丢失</li>
<li>auto.leader.rebalance.enable：是否允许定期进行 Leader 选举<br>建议设置为 false，如果设置为 true，表示允许 Kafka 定期对一些 Topic 分区进行 Leader 重选举（需要满足一定的条件），与 Leader 选举的不同时，该参数为换 Leader，换一次 Leader 的代价很高</li>
</ul>
<h4 id="数据留存相关参数"><a href="#数据留存相关参数" class="headerlink" title="数据留存相关参数"></a>数据留存相关参数</h4><ul>
<li>log.retention.{hours|minutes|ms}：控制一条消息数据被保存多长时间，优先级：ms &gt; minutes &gt; hours<br>通常设置 hours 多一些，<code>log.retention.hours=168</code> 表示默认保存 7 天的数据，自动删除 7 天前的数据</li>
<li>log.retention.bytes: 指定 Broker 为消息保存的总磁盘容量大小<br>默认值是 -1，表明想在这台 Broker 上保存多少数据都可以，真正发挥作用的场景是在云上构建多租户的 Kafka 集群</li>
<li>message.max.bytes：控制 Broker 能够接收的最大消息大小<br>默认值 1000012 &#x3D; 976k，还不到 1M，在线上环境中设置一个比较大的值是比较保险的做法</li>
</ul>
<h3 id="Topic-级别参数"><a href="#Topic-级别参数" class="headerlink" title="Topic 级别参数"></a>Topic 级别参数</h3><p>Topic 级别的参数会覆盖全局 Broker 参数的值，每个 Topic 都能设置自己的参数值（Topic 参数的优先级高于 Broker 参数）<br>建议：每个 Topic 根据自身业务的需要，设置自己的留存时间和处理最大消息的大小</p>
<h4 id="保存消息的维度"><a href="#保存消息的维度" class="headerlink" title="保存消息的维度"></a>保存消息的维度</h4><ul>
<li>retention.ms：规定 Topic 消息被保存的时长，默认 7 天。</li>
<li>retention.bytes：规定为 Topic 预留多大的磁盘空间。通常在多租户的 Kafka 集群中使用，默认值是 -1，表示可以无限使用磁盘空间</li>
</ul>
<h4 id="处理消息大小的维度"><a href="#处理消息大小的维度" class="headerlink" title="处理消息大小的维度"></a>处理消息大小的维度</h4><ul>
<li>max.message.bytes：决定 Kafka Broker 能够正常接收该 Topic 的最大消息大小</li>
</ul>
<h4 id="设置-Topic-级别参数的情况"><a href="#设置-Topic-级别参数的情况" class="headerlink" title="设置 Topic 级别参数的情况"></a>设置 Topic 级别参数的情况</h4><p>建议使用<strong>修改时设置的方式</strong>修改 Topic 级别的参数</p>
<ul>
<li>创建时进行设置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送最大值是 5MB 的消息</span></span><br><span class="line">bin/kafka-topics.sh --bootstrap-server localhost:9092 --create --topic transaction --partitions 1 --replication-factor 1 --config retention.ms=15552000000 --config max.message.bytes=5242880</span><br></pre></td></tr></table></figure></li>
<li>修改时进设置<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">发送最大值是 10MB 的消息</span></span><br><span class="line">bin/kafka-configs.sh --zookeeper localhost:2181 --entity-type topics --entity-name transaction --alter --add-config max.message.bytes=10485760</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="JVM-参数"><a href="#JVM-参数" class="headerlink" title="JVM 参数"></a>JVM 参数</h3><ul>
<li>JVM 堆<br>无脑的建议：JVM 堆大小设置成 6GB<br>Kafka Broker 在与客户端进行交互时会在 JVM 堆上创建大量的 ByteBuffer 实例，Heap Size 不能太小</li>
<li>垃圾回收器的设置</li>
<li>Java 7</li>
<li>如果 Broker 所在机器的 CPU 资源非常充裕，建议使用 CMS 收集器，启用方法：<code>-XX:+UseCurrentMarkSweepGC</code></li>
<li>否在使用吞吐量收集器，启用方法：<code>-XX:+UseParallelGC</code></li>
<li>Java 8</li>
<li>手动设置 G1 收集器，在没有任何调优的情况下，G1 比 CMS 表现出色</li>
</ul>
<h4 id="设置的方式"><a href="#设置的方式" class="headerlink" title="设置的方式"></a>设置的方式</h4><ul>
<li>设置两个环境变量</li>
<li>KAFKA_HEAP_OPTS：指定堆大小</li>
<li>KAFKA_JVM_PERFORMANCE_OPTS：指定 GC 参数</li>
<li>修改启动脚本</li>
</ul>
<h3 id="操作系统参数"><a href="#操作系统参数" class="headerlink" title="操作系统参数"></a>操作系统参数</h3><ul>
<li>文件描述符限制<br><code>ulimit -n</code>，任何一个 Java 项目都最好调整一下这个值，通常情况需要设置一个超大的值，如果不设置的话，会经常看到 “Too many open files” 的错误</li>
<li>文件系统类型<br>XFS 的性能要高于 ext4，生产环境建议使用 XFS，最近的数据报告中 ZFS 的性能更加强劲</li>
<li>Swappiness<br>建议将 <code>swappniess</code> 配置成一个接近 0 但不为 0 的值，比如 1，因为当设置成 0 时，当物理内存耗尽时，操作系统会触发 OOM killer 组件，这个组件会随机挑选一个进程然后 kill 掉，不会给用户任何的预警，如果设置成一个比较小的值，当开始使用 swap 空间时，至少能够观测到 Broker 性能开始出现急剧下降，从而给出进一步调优和诊断问的时间</li>
<li>提交时间<br>向 Kafka 发送数据并不是需要等数据被写入磁盘才会被认为成功，而是只要数据被写入到操作系统的页缓存（Page Cache）上就可以了，随后操作系统根据 LRU 算法定期将页缓存上的 “脏” 数据落盘到物理磁盘上，定期是由提交时间来确定的，默认是 5 秒。可以适当增加提交间隔来降低物理磁盘的写操作</li>
<li>页缓存属于磁盘缓存（Disk cache）的一种，主要是为了改善系统性能。重复访问磁盘上的磁盘块是常见的操作，把它们保存在内存中可以避免昂贵的磁盘IO操作</li>
<li>既然叫页缓存，它是根据页（page）来组织的内存结构。每一页包含了很多磁盘上的块数据。Linux 使用 Radix 树实现页缓存，主要是加速特定页的查找速度。另外一般使用 LRU 策略来淘汰过期页数据。总之它是一个完全由内核来管理的磁盘缓存，用户应用程序通常是无感知的</li>
</ul>
<h2 id="生产者分区机制原理"><a href="#生产者分区机制原理" class="headerlink" title="生产者分区机制原理"></a>生产者分区机制原理</h2><h3 id="Kafka-的消息组织方式"><a href="#Kafka-的消息组织方式" class="headerlink" title="Kafka 的消息组织方式"></a>Kafka 的消息组织方式</h3><p>主题 - 分区 - 消息</p>
<ul>
<li>分区是实现负载均衡及高吞吐量的关键</li>
<li>对数据进行分区的主要原因是为了实现系统的高伸缩性</li>
<li>主题下的每条消息只会保存在某一个分区中，而不会在多个分区中保存</li>
</ul>
<h3 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h3><h4 id="自定义分区策略"><a href="#自定义分区策略" class="headerlink" title="自定义分区策略"></a>自定义分区策略</h4><p>通过编写 <code>org.apache.kafka.clients.producer.Partitioner</code> 接口实现，显示配置生产者端参数 partitioner.class 为实现类的权限定类名</p>
<ul>
<li>轮训策略（Round - robin）</li>
<li>是 Kafka Java 生产者 API 默认提供的分区策略</li>
<li>具有非常优秀的负载均衡表现，总是能保证消息最大限度地被平均分配到所有分区</li>
<li>随机策略（Randomness）</li>
<li>负载均衡的实际表现要逊色于轮训策略</li>
<li>实现方式  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> ThreadLocalRandom.current().nextInt(partitions.size());</span><br></pre></td></tr></table></figure></li>
<li>按消息键策略（Key - ordering）</li>
<li>Key 可以使一个明确业务含义的字符串，也可以用于表征消息元数据</li>
<li>如果指定了 Key 默认按消息键策略，如果没有指定 Key 则使用轮训策略</li>
<li>实现方式  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;PartitionInfo&gt; partitions = cluster.partitionsForTopic(topic);</span><br><span class="line"><span class="keyword">return</span> Math.abs(key.hashCode()) % partitions.size();</span><br></pre></td></tr></table></figure></li>
<li>基于地理位置分区</li>
<li>只针对大规模的 Kafka 集群</li>
<li>跨城市、跨国家、跨大洲等</li>
</ul>
<h2 id="生产者压缩算法"><a href="#生产者压缩算法" class="headerlink" title="生产者压缩算法"></a>生产者压缩算法</h2><p>一个消息集合包含若干条日志项（真正封装消息的地方），消息是分批次（batch）读写的，batch 是 kafka 读写（网络传输和文件读写）的基本单位，Kafka 共有两大类消息格式，不同版本，叫法不一样<br>V1 Kafka 的消息（message）层次：</p>
<ul>
<li>消息集合 （message set）</li>
<li>消息（message）</li>
<li>每条消息都要计算 CRC 值<br>V2 Kafka 的消息（record）层次：<blockquote>
<p>0.11.0.0 中正式引入</p>
</blockquote>
</li>
<li>消息集合（record batch）</li>
<li>消息（record）</li>
<li>在 batch 层计算 CRC 值<blockquote>
<p>CRC（Cyclic Redundancy Check）循环冗余校验，主要用来检测、校验数据传输或者保存后可能出现的错误。</p>
</blockquote>
</li>
</ul>
<h3 id="何时压缩"><a href="#何时压缩" class="headerlink" title="何时压缩"></a>何时压缩</h3><h4 id="生产者端"><a href="#生产者端" class="headerlink" title="生产者端"></a>生产者端</h4><p>在生产者程序中配置 compression.type 参数，表示启用指定类型的压缩算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line"><span class="comment">// 开启GZIP压缩</span></span><br><span class="line">props.put(<span class="string">&quot;compression.type&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line">Producer&lt;String, String&gt; producer = <span class="keyword">new</span> <span class="title class_">KafkaProducer</span>&lt;&gt;(props);</span><br></pre></td></tr></table></figure>
<h4 id="Broker-端"><a href="#Broker-端" class="headerlink" title="Broker 端"></a>Broker 端</h4><p>大多数情况下，从 Producer 接收到消息后进行原封不动的保存，不会对消息进行修改<br>两种例外情况：</p>
<ol>
<li>Broker 指定了和 Producer 不同的压缩算法</li>
</ol>
<ul>
<li>重新解压缩、压缩会导致 CPU 使用率飙升</li>
</ul>
<ol start="2">
<li>Broker 发生了消息格式转换<br> 主要为了兼容 V1、V2 版本的消息</li>
</ol>
<ul>
<li>该过程涉及到消息的解压缩和重新压缩</li>
<li>使 Kafka 丧失 Zero Copy 特性</li>
</ul>
<h3 id="何时解压缩"><a href="#何时解压缩" class="headerlink" title="何时解压缩"></a>何时解压缩</h3><p>通常发生在消费者程序中，Kafka 会将 Producer 启用了哪种压缩算法封装进消息集合中</p>
<h4 id="Broker-端的解压缩"><a href="#Broker-端的解压缩" class="headerlink" title="Broker 端的解压缩"></a>Broker 端的解压缩</h4><p>每个压缩过的消息集合在 Broker 端写入时都要发生解压缩操作，目的是为了对消息执行各种验证</p>
<ul>
<li>Broker 只需要把数据解压之后进行动态校验，而不需要把解压后的结果保存</li>
<li>这种压缩对 Broker 性能有一定影响，特别是 CPU。<blockquote>
<p>总结：Producer 压缩、Broker 保持、Consumer 解压缩</p>
</blockquote>
</li>
</ul>
<h3 id="压缩算法对比"><a href="#压缩算法对比" class="headerlink" title="压缩算法对比"></a>压缩算法对比</h3><p>Kafka 2.1.0 版本之前，支持 3 种压缩算法 GZIP、Snappy、LZ4，2.1.0 版本后开始正式支持 Zstandard 算法（zstd）</p>
<ul>
<li>zstd 是 Facebook 开源的压缩算法，可以提供超高的压缩比</li>
</ul>
<h4 id="压缩算法的两个重要指标"><a href="#压缩算法的两个重要指标" class="headerlink" title="压缩算法的两个重要指标"></a>压缩算法的两个重要指标</h4><ol>
<li>压缩比，压缩比越高越好</li>
<li>压缩 &#x2F; 解压缩吞吐量 ，吞吐量越高越好</li>
</ol>
<h4 id="在-Kafka-中的表现"><a href="#在-Kafka-中的表现" class="headerlink" title="在 Kafka 中的表现"></a>在 Kafka 中的表现</h4><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>LZ4 &gt; Snappy &gt; ztsd &#x3D; GZIP</p>
<h5 id="压缩比"><a href="#压缩比" class="headerlink" title="压缩比"></a>压缩比</h5><p>ztsd &gt; LZ4 &gt; GZIP &gt; Snappy</p>
<h5 id="物理资源"><a href="#物理资源" class="headerlink" title="物理资源"></a>物理资源</h5><p>Snappy 占用的网络带宽最多，zstd 最少<br>Snappy 压缩时占用的 CPU 多一些，解压缩是 GZIP 占用的 CPU 多一些，其余的算法表现差不多</p>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><p>启用压缩的条件：</p>
<ul>
<li>Producer 程序运行机器上的 CPU 资源要很充足</li>
<li>环境中的带宽资源有限</li>
<li>如果客户端 CPU 资源有富余，强烈建议开启 zstd 压缩，可以极大节省网络资源消耗<br>需要根据实际情况选择合适的压缩算法，以求实现最大的资源利用率</li>
</ul>
<h2 id="无消息丢失配置"><a href="#无消息丢失配置" class="headerlink" title="无消息丢失配置"></a>无消息丢失配置</h2><p>Kafka 只对 “已提交” 的消息做有限度的持久化保证</p>
<ul>
<li>已提交的消息：Kafka 的若干个 Broker 成功接收到一条消息后并写入到日志文件，会通知 Producer 该消息已成功提交</li>
<li>有限度的持久化保证：Kafka 不可能保证在任何情况下都不丢失消息</li>
</ul>
<h3 id="认为消息丢失的误区"><a href="#认为消息丢失的误区" class="headerlink" title="认为消息丢失的误区"></a>认为消息丢失的误区</h3><h4 id="Producer-丢失数据"><a href="#Producer-丢失数据" class="headerlink" title="Producer 丢失数据"></a>Producer 丢失数据</h4><p>误区：调用 producer.send(msg) API，会立即返回，此时不能认为消息已发送成功<br>解决方案：调用 producer.send(msg, callback)，可以根据回调通知确认消息是否已发送成功，并做针对性处理</p>
<h4 id="Consumer-丢失数据"><a href="#Consumer-丢失数据" class="headerlink" title="Consumer 丢失数据"></a>Consumer 丢失数据</h4><h5 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h5><p>误区：先更新了消费位移，消费时因某种原因中断，再次消费，导致中断点到 offset 的位置消息丢失<br>解决方案：先消费消息，再更新消费位移</p>
<h5 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h5><p>误区：多线程异步处理消费消息，Consumer 自动向前更新位移，某个线程运行失败，但位移已更新，对于 Consumer 来说，该消息已丢失<br>解决方案：多线程异步处理消费消息时，Consumer 不能开启自动提交位移，而应由应用程序手动提交</p>
<h3 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li>使用带有回调通知的 producer.send(msg, callback)</li>
<li>设置 Producer 参数 acks &#x3D; all。该参数代表对已提交消息的定义，当 &#x3D; all 时，表示所有 Broker 都要接收到消息，该消息才算是 commited，是最高等级的 “已提交” 定义</li>
<li>设置 Producer 参数 retries 为一个较大的值。该参数代表重试次数，当出现网络抖动时，配置了 retries &gt; 0 的 Producer 可以自动重试消息发送，避免消息丢失</li>
<li>设置 Broker 参数 unclean.leader.election.enable &#x3D; false。该参数控制哪些 Broker 有资格竞选分区的 Leader。如果某个 Broker 落后 Leader 太多，当该 Broker 成为 Leader 后，必然会造成消息丢失。设置成 false，表示不允许该情况的发生</li>
<li>设置 Broker 参数 repliacation.factor &gt;&#x3D; 3。该参数表示将消息多保存几份<blockquote>
<p>防止消息丢失的主要机制就是冗余</p>
</blockquote>
</li>
<li>设置 Broker 参数 min.insync.replicas &gt; 1。该参数表示控制的消息至少被写入到多少个 Broker 才算 “已提交” 。&gt; 1 可以提升消息持久性，实际生产环境不要使用默认值 1。</li>
<li>确保 replication.factor &gt; min.insync.replicas。如果两者相等，只要有一个 Broker 挂机，整个分区就无法正常工作。推荐设置成 replication.factor &#x3D; min.insync.replicas + 1</li>
</ol>
<ul>
<li>replication.factor 的含义是：副本总数</li>
<li>min.insync.replicas 的含义是：至少确保有多少个 replica 写入才算提交成功</li>
<li>replication.factor &gt; min.insync.replicas 是因为如果相等时，只要有一个 Broker 宕机，就永远也无法达到 ack &#x3D; all 的要求</li>
</ul>
<ol start="8">
<li>确保消息消费完成再提交。设置 Consumer 参数 enable.auto.commit &#x3D; false。采用手动提交位移的方式。</li>
</ol>
<h2 id="Kafka-拦截器"><a href="#Kafka-拦截器" class="headerlink" title="Kafka 拦截器"></a>Kafka 拦截器</h2><h3 id="什么是拦截器"><a href="#什么是拦截器" class="headerlink" title="什么是拦截器"></a>什么是拦截器</h3><p>允许应用程序在不修改逻辑的情况下，动态的实现一组可插拔的事件处理逻辑链。它能够在主业务操作前后多个时间点上插入对应的 ”拦截“ 逻辑。</p>
<h3 id="拦截器分类"><a href="#拦截器分类" class="headerlink" title="拦截器分类"></a>拦截器分类</h3><p>支持链的方式，可以将一组拦截器串联成一个大的拦截器，Kafka 会按照添加顺序依次执行拦截器逻辑。</p>
<h4 id="生产者拦截器"><a href="#生产者拦截器" class="headerlink" title="生产者拦截器"></a>生产者拦截器</h4><p>允许在发送消息前及消息提交成功后植入拦截器逻辑。<br>自定义的拦截器要继承 <code>org.apache.kafka.clients.producer.ProducerInterceptor</code> 接口<br>两个核心方法：</p>
<ol>
<li>onSend：在消息发送之前调用</li>
<li>onAcknowledgement：在消息成功提交或发送失败后被调用。onAcknowledgement 的调用要早于 callback 的调用。</li>
</ol>
<h4 id="消费者拦截器"><a href="#消费者拦截器" class="headerlink" title="消费者拦截器"></a>消费者拦截器</h4><p>支持在消息消息前以及提交为以后编写特定逻辑。<br>自定的拦截器要继承 org.apacke.kafka.clients.consumer.ConsumerInterceptor 接口<br>两个核心方法：</p>
<ol>
<li>onConsume：在消息返回给 Consumer 程序之前调用。</li>
<li>onCommit：Consumer 在提交位移之后调用。</li>
</ol>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>注意</strong>：指定拦截器时要指定全限定类名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">List&lt;String&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">interceptors.add(<span class="string">&quot;com.yourcompany.kafkaproject.interceptors.AddTimestampInterceptor&quot;</span>); <span class="comment">// 拦截器1</span></span><br><span class="line">interceptors.add(<span class="string">&quot;com.yourcompany.kafkaproject.interceptors.UpdateCounterInterceptor&quot;</span>); <span class="comment">// 拦截器2</span></span><br><span class="line">props.put(ProducerConfig.INTERCEPTOR_CLASSES_CONFIG, interceptors);</span><br></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h4><ul>
<li>客户端监控</li>
<li>端到端系统性能检测</li>
<li>消息审计</li>
<li>etc</li>
</ul>
<h4 id="端到端性能检测"><a href="#端到端性能检测" class="headerlink" title="端到端性能检测"></a>端到端性能检测</h4><p>功能：在消息一批消息前，从当前的时钟时间减去封装在消息中的创建时间，累计得到该批消息的总端到端处理延迟，再更新到 Redis 中。最后从别从 Redis 中读取更新过的总延迟和总消息数，两者相处即使端到端消息的平均处理延迟。</p>
<h5 id="生产者拦截器实现"><a href="#生产者拦截器实现" class="headerlink" title="生产者拦截器实现"></a>生产者拦截器实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvgLatencyProducerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ProducerInterceptor</span>&lt;String, String&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> Jedis jedis; <span class="comment">// 省略Jedis初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ProducerRecord&lt;String, String&gt; <span class="title function_">onSend</span><span class="params">(ProducerRecord&lt;String, String&gt; record)</span> &#123;</span><br><span class="line">		jedis.incr(<span class="string">&quot;totalSentMessage&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> record;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAcknowledgement</span><span class="params">(RecordMetadata metadata, Exception exception)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费者拦截器实现"><a href="#消费者拦截器实现" class="headerlink" title="消费者拦截器实现"></a>消费者拦截器实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AvgLatencyConsumerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ConsumerInterceptor</span>&lt;String, String&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> Jedis jedis; <span class="comment">//省略Jedis初始化</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ConsumerRecords&lt;String, String&gt; <span class="title function_">onConsume</span><span class="params">(ConsumerRecords&lt;String, String&gt; records)</span> &#123;</span><br><span class="line">		<span class="type">long</span> <span class="variable">lantency</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">		<span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">			lantency += (System.currentTimeMillis() - record.timestamp());</span><br><span class="line">		&#125;</span><br><span class="line">		jedis.incrBy(<span class="string">&quot;totalLatency&quot;</span>, lantency);</span><br><span class="line">		<span class="type">long</span> <span class="variable">totalLatency</span> <span class="operator">=</span> Long.parseLong(jedis.get(<span class="string">&quot;totalLatency&quot;</span>));</span><br><span class="line">		<span class="type">long</span> <span class="variable">totalSentMsgs</span> <span class="operator">=</span> Long.parseLong(jedis.get(<span class="string">&quot;totalSentMessage&quot;</span>));</span><br><span class="line">		jedis.set(<span class="string">&quot;avgLatency&quot;</span>, String.valueOf(totalLatency / totalSentMsgs));</span><br><span class="line">		<span class="keyword">return</span> records;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCommit</span><span class="params">(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(Map&lt;String, ?&gt; configs)</span> &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Kafka-是如何管理-TCP-连接的"><a href="#Kafka-是如何管理-TCP-连接的" class="headerlink" title="Kafka 是如何管理 TCP 连接的"></a>Kafka 是如何管理 TCP 连接的</h2><h3 id="为什么采用-TCP-连接"><a href="#为什么采用-TCP-连接" class="headerlink" title="为什么采用 TCP 连接"></a>为什么采用 TCP 连接</h3><p>Apache Kafka 的所有通信都是基于 TCP 的<br>采用 TCP 而不是 HTTP 的原因：</p>
<ul>
<li>开发客户端时，人们能够利用 TCP 本身提供的一些高级功能</li>
<li>多路复用请求</li>
<li>同时轮询多个连接</li>
<li>目前已知的 HTTP 库在很多编程语言中都略显简陋</li>
</ul>
<h3 id="何时创建-TCP-连接"><a href="#何时创建-TCP-连接" class="headerlink" title="何时创建 TCP 连接"></a>何时创建 TCP 连接</h3><p>TCP 连接是在创建 Kafka Producer 实例时创建的。还可能在两个地方被创建：</p>
<ul>
<li>更新元数据后，发现与某些 Broker 当前没有连接，会创建一个 TCP 连接</li>
<li>消息发送时，发现不存在与目标 Broker 的连接时，会创建一个 TCP 连接<blockquote>
<p>在创建 Kafka Producer 实例时，生产者应用会在后台创建并启动一个名为 Sender 的线程，该 Sender 线程开始运行时首先会创建与 Broker 的连接（连接所有 bootstrap.servers 指定的所有 Broker）<br>实际中，建议指定 3 ~ 4 台即可（服务发现）。<br>更新集群元数据信息得两个场景：</p>
</blockquote>
</li>
<li>当 Producer 尝试给不存在的主题发送消息时，Broker 会告诉 Producer 该主题不存在，此时 Producer 发送 METADATA 请求给 Kafka 集群，尝试获取最新的元数据信息</li>
<li>Producer 通过 metadata.max.age.ms 参数定期更新元数据信息。默认值是 300000（5 分钟）</li>
</ul>
<h3 id="何时关闭-TCP-连接"><a href="#何时关闭-TCP-连接" class="headerlink" title="何时关闭 TCP 连接"></a>何时关闭 TCP 连接</h3><p>关闭TCP 连接的两种方式：</p>
<ul>
<li>用户主动关闭</li>
<li>广义的主动 ”关闭“</li>
<li>包括 kill -9</li>
<li>推荐使用 producer.close 方法关闭</li>
<li>Kafka 自动关闭（TCP 连接在Broker端被关闭，属于被动关闭）</li>
<li>Producer 参数 connections.max.idels.ms 值有关，默认值 9 分钟，如果在 9 分钟内没有任何请求 ”流过“ 某个 TCP 连接，Kafka 会主动关闭该 TCP 连接。如果设置成 -1，该 TCP 连接会成为永久长连接（软件层面）。Kafka 创建的 socket 连接都开启了 keepalive，会遵守 keepalive 探活机制。</li>
<li>被动关闭的后果是产生大量的 CLOSE_WAIT 连接</li>
</ul>
<h2 id="Kafka-消息交付可靠性保障及精确处理一次的语义"><a href="#Kafka-消息交付可靠性保障及精确处理一次的语义" class="headerlink" title="Kafka 消息交付可靠性保障及精确处理一次的语义"></a>Kafka 消息交付可靠性保障及精确处理一次的语义</h2><p>常见的三种消息交付可靠性保障：</p>
<ul>
<li>最多一次（at most once）：消息可能会丢失，但绝不会被重复发送</li>
<li>至少一次（at least once）：消息不会丢失，但有可能被重复发送</li>
<li>精确一次（exactly once）：消息不会丢失，也不会被重复发送<br>Kafka 默认提供第二种，即至少一次。<br>Kafka 配置 Producer 禁止重试，即可提供最多一次交付保障。<br>Kafka 通过幂等性（Idmpotence）和事务（Transaction）可以做到精确一次的交付保障。</li>
</ul>
<h3 id="幂等性-Producer"><a href="#幂等性-Producer" class="headerlink" title="幂等性 Producer"></a>幂等性 Producer</h3><h4 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h4><p>指某些操作或函数能够被执行多次，但每次得到的结果都是不变的。</p>
<ul>
<li>若一个子程序是幂等的，那它必然不能修改系统状态，不管运行多少次，与该子程序相关联的那部分系统状态保持不变。</li>
<li>在函数式编程语言中，纯函数天然幂等，不执行任何的 side effect。<br>幂等性的优势：可以安全的重试任何幂等性操作。</li>
</ul>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>Kafka Producer 默认不是幂等的，可以创建幂等性 Producer（0.11.0.0 版本引入）：</p>
<ul>
<li>设置 <code>props.put(&quot;enable.idempotence&quot;, true)</code> 或 <code>props.put(&quot;ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG&quot;, true)</code></li>
</ul>
<h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>利用空间换时间的优化思路（在 Broker 多存一些字段）</p>
<ul>
<li>ProducerID：在每个新的 Producer 初始化时，会被分配一个唯一的 ProducerID，该 ProducerID 对客户端不可见</li>
<li>SequenceNumber：对于每个 ProducerID，Producer 发送数据的每个 Topic和 Partition 都对应一个从 0 开始单调递增的SequenceNumber 值</li>
</ul>
<h5 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h5><ul>
<li>只能保证单分区上的幂等性</li>
<li>只能实现单会话上的幂等性，不能实现跨会话的幂等性（重启后，幂等性保证消失）</li>
</ul>
<h3 id="事务性-Producer"><a href="#事务性-Producer" class="headerlink" title="事务性 Producer"></a>事务性 Producer</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>类似数据库提供的事务。数据库领域，事务提供的安全性保障是经典的 ACID。</p>
<ul>
<li>原子性（Atomicity）</li>
<li>一致性（Consistency）</li>
<li>隔离性（Isolation）</li>
<li>持久性（Durability）</li>
</ul>
<h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>Kafka 提供对事务的支持（0.11版本），主要作用在 read committed 隔离级别，可以保证多条消息原子性的写入到目标区，同时也能保证 Consumer 只能看到事务提交成功的消息。</p>
<ol>
<li>和幂等性 producer 一样，开启 <code>enable.idempotence = true</code></li>
<li>设置 Producer 端参数 transactional.id</li>
<li><pre><code class="java">
</code></pre>
</li>
</ol>
<p> producer.initTransactions(); &#x2F;&#x2F; 事务初始化<br> try {<br> producer.beginTransaction(); &#x2F;&#x2F; 事务开始<br> producer.send(record1);<br> producer.send(record2);<br> producer.commitTransaction(); &#x2F;&#x2F; 事务提交<br> } catch (KafkaException e) {<br> producer.abortTransaction(); &#x2F;&#x2F; 事务终止<br> }<br> &#x2F;&#x2F; 事务失败的情况，也会被写入到底层的日志中，Kafka 依赖 LSO 等机制设定事务型 Consumer 的可见范围，保证事务的准确性<br>4. Consumer 读取事务型 Producer 的消息需要修改 isolation.level 参数</p>
<ul>
<li>read_uncommitted：默认值，表明 Consumer 可以读取到 Kafka 写入的任何消息</li>
<li>read_committed：表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消息（也可以看到非事务型 Producer 写入的消息）</li>
</ul>
<h5 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h5><p>两阶段提交（2PC）</p>
<h5 id="作用范围-1"><a href="#作用范围-1" class="headerlink" title="作用范围"></a>作用范围</h5><p>比起幂等性 Producer， 事务型 Producer 的性能更差</p>
<ul>
<li>跨分区的幂等性</li>
<li>跨会话的幂等性</li>
</ul>
<h2 id="Consumer-Group-消费者组"><a href="#Consumer-Group-消费者组" class="headerlink" title="Consumer Group 消费者组"></a>Consumer Group 消费者组</h2><p>Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制。</p>
<ul>
<li>Consumer Group 下可以有一个或多个 Consumer 实例。</li>
<li>实例可以是一个单独的进程</li>
<li>也可以是同一进程下的线程</li>
<li>Group ID 是一个字符串，在一个 Kafka 集群中，它标识唯一的 Consumer Group。</li>
<li>Consumer Group 下所有实例订阅的主题的单个分区，只能分配给组内的某个 Conusmer 实例消费。这个分区也可以被其他的 Group 消费</li>
<li>理想情况下，Consumer 实例的数量应该等于该 Group 订阅主题的分区总数。<blockquote>
<p>如果消费者数量大于分区数量时：</p>
<ul>
<li>Consumer &lt; Partition，一个 Consumer 消费多个 Partition</li>
<li>Consumer &#x3D; Partition，一个 Consumer 消费一个 Partition</li>
<li>Consumer &gt; Partition，多个 Consumer 处于空闲状态<br>Kafka 通过 Consumer Group 机制，同时实现了传统消息引擎系统的两大模型：</li>
</ul>
</blockquote>
</li>
<li>消息队列模型：所有实例都属于一个 Group</li>
<li>发布 &#x2F; 订阅模型：所有实例分别属于不同的 Group</li>
</ul>
<h3 id="位移管理"><a href="#位移管理" class="headerlink" title="位移管理"></a>位移管理</h3><h4 id="老版本"><a href="#老版本" class="headerlink" title="老版本"></a>老版本</h4><p>Consumer Group 将 offset 保存在 ZooKeeper 中。但 ZooKeeper 不适合进行频繁的写更新，大量的 offset 写操作会拖慢 ZooKeeper 集群的性能。</p>
<h4 id="新版本"><a href="#新版本" class="headerlink" title="新版本"></a>新版本</h4><p>Consumer Group 将 offset 保存在 Kafka 内部主题中的 __consumer_offsets__ 中</p>
<h3 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h3><p>Rebalance 是一种协议，规定了一个 Conusmer Group 下的所有 Consumer 如何达成一致，来分配订阅 Topic 的每个分区。</p>
<h4 id="Rebalance-的触发条件"><a href="#Rebalance-的触发条件" class="headerlink" title="Rebalance 的触发条件"></a>Rebalance 的触发条件</h4><ol>
<li>组成员数发生变更（有新的 Consumer 加入组或者离开组，或者某个 Consumer 崩溃被 “踢出“ 组）</li>
<li>订阅主题数发生变更。</li>
</ol>
<ul>
<li>支持使用正则表达式的方式订阅主题</li>
</ul>
<ol start="3">
<li>订阅主题的分区数发生变更。</li>
</ol>
<h4 id="Rebalance-的分配策略"><a href="#Rebalance-的分配策略" class="headerlink" title="Rebalance 的分配策略"></a>Rebalance 的分配策略</h4><p>Rebalance 发生时， Group 下的所有 Consumer 会协调在一起共同参与。Kafka 提供了三种分配策略：</p>
<ol>
<li>Range 分配策略：面向每个主题，首先会对同一个主题里面的分区按照序号进行排序，并把消费者线程按照字母顺序进行排序。然后用分区数除以消费者线程数量判断每个消费者线程消费几个分区。如果除不尽，那么前面几个消费者线程将会多消费一个分区。</li>
<li>RoundRobin 策略：是将消费组内所有消费者以及消费者所订阅的所有 topic 的 Partition 按照字典序排序，然后通过轮询算法逐个将分区以此分配给每个消费者。 使用 RoundRobin 分配策略时会出现两种情况： </li>
<li>如果同一消费组内，所有的消费者订阅的消息都是相同的，那么 RoundRobin 策略的分区分配会是均匀的。 </li>
<li>如果同一消费者组内，所订阅的消息是不相同的，那么在执行分区分配的时候，就不是完全的轮询分配，有可能会导致分区分配的不均匀。如果某个消费者没有订阅消费组内的某个 topic，那么在分配分区的时候，此消费者将不会分配到这个 topic 的任何分区。 </li>
<li>Sticky 分配策略：在 Kafka的 0.11.X 版本才开始引入的，是目前最复杂也是最优秀的分配策略。 Sticky 分配策略的原理比较复杂，主要实现了两个目的： </li>
<li>分区的分配要尽可能的均匀； </li>
<li>分区的分配尽可能的与上次分配的保持相同。 如果这两个目的发生了冲突，优先实现第一个目的。</li>
</ol>
<h4 id="Rebalance-臭名昭著的原因"><a href="#Rebalance-臭名昭著的原因" class="headerlink" title="Rebalance 臭名昭著的原因"></a>Rebalance 臭名昭著的原因</h4><ol>
<li>在 Rebalance 的过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成。</li>
<li>Rebalance 中是所有 Consumer 共同参与，全部重新分配。更高效的做法是通过一致性 Hash 消费之前负责的分区，避免重新创建连接其它 Broker 的 Socket 资源。</li>
<li>Rebalance 的过程很慢。</li>
</ol>
<h3 id="避免-Rebalance"><a href="#避免-Rebalance" class="headerlink" title="避免 Rebalance"></a>避免 Rebalance</h3><p>在 Rebalance 过程中，所有 Conusmer 实例共同参与，在协调者组件的帮助下，完成订阅主题分区的分配。</p>
<h4 id="协调者"><a href="#协调者" class="headerlink" title="协调者"></a>协调者</h4><p>Coordinator，专门为 Consumer Group 服务，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理等。<br>所有 Broker 都有各自的 Coordinator 组件， Consumer 在提交位移时，实际是向 Coordinator 所在的 Broker 提交位移，请求同理。<br>Kafka 为某个 Consumer Group 确定 Coordinator 所在的 Broker 的算法有两个步骤（__consumer_offsets）：</p>
<ol>
<li>确定由位移主题的哪个分区来保存该 Group 数据：<code>partitionId = Math.abs(GroupId.hashCode() % offsetsTopicPartitionCount)</code></li>
<li>找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator</li>
</ol>
<h4 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h4><p>当 Consumer Group 出现问题时，需要快速排查 Broker 端日志时，可以根据这个算法准确定位 Coordinator Broker。<br>日志中会有类似 “(Re)join group” 之类的 日志</p>
<h4 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h4><p>在真实的业务场景中，很多 Rebalance 都是计划外的或者说是不必要的。需要从 Rebalance 发生的时机入手，才可能避免 Rebalance。<br>Rebalance 发生的三个时机：</p>
<ul>
<li>组成员数量发生变化</li>
<li>订阅主题数量发生变化</li>
<li>订阅主题的分区数发生变化<br>Coordinator 认定 Consumer 实例已挂需要退组：</li>
</ul>
<ol>
<li>Consumer 端参数：session.timeout.ms，默认值 10 秒。决定了 Consumer 存活的时间间隔。</li>
</ol>
<ul>
<li>Coordinator 在 10 秒内没有收到 Group 下某个 Consumer 实例的心跳，会认为该实例已挂。</li>
</ul>
<ol start="2">
<li>Conusmer 端参数：heartbeat.interval.ms。控制发送心跳请求评率的参数。</li>
</ol>
<ul>
<li>频繁发送心跳会额外消耗带宽资源，但可以快速知晓当前是否开启 Rebalance。</li>
<li>Coordinator 通知 Consumer 实例开启 Rebalance 的方法，是将 REBALANCE_NEEDED 标志位封装进心跳请求的响应体中。</li>
</ul>
<ol start="3">
<li>Consumer 端参数：max.poll.interval.ms，默认值 5 分钟。限定 Consumer 端两次调用 poll 方法的最大时间间隔。</li>
</ol>
<ul>
<li>Conusmer 如果在 5 分钟之内无法消费完 poll 方法返回的消息，Consumer 会主动发起离组请求，Coordinator 会开启新的 Rebalance。</li>
</ul>
<h4 id="不必要的-Rebalance"><a href="#不必要的-Rebalance" class="headerlink" title="不必要的 Rebalance"></a>不必要的 Rebalance</h4><h5 id="未能及时发送心跳"><a href="#未能及时发送心跳" class="headerlink" title="未能及时发送心跳"></a>未能及时发送心跳</h5><p>需要仔细设置 session.timeout.ms 和 heartbeat.interval.ms<br>推荐数值：</p>
<ul>
<li>session.tiemout.ms &#x3D; 6s</li>
<li>Heartbeat.inverval.ms &#x3D; 2s<blockquote>
<p>要保证 Consumer 实例在被判定为 “dead” 之前，能够发送至少 3 轮心跳请求。</p>
<p>session.timeout.ms &gt;&#x3D; 3 * heartbeat.invertval.ms</p>
</blockquote>
</li>
</ul>
<h5 id="Consumer-消费时间过长"><a href="#Consumer-消费时间过长" class="headerlink" title="Consumer 消费时间过长"></a>Consumer 消费时间过长</h5><p>为业务处理逻辑留下充足的时间</p>
<h5 id="Conusmer-端的-GC-表现"><a href="#Conusmer-端的-GC-表现" class="headerlink" title="Conusmer 端的 GC 表现"></a>Conusmer 端的 GC 表现</h5><p>频繁的 Full GC 会引发非预期的 Rebalance</p>
<h2 id="位移主题"><a href="#位移主题" class="headerlink" title="位移主题"></a>位移主题</h2><p>位移主题（__consumer_offsets）是 Kafka 中的内部主题。该主题和 Kafka 中的其他主题一样，可以手动的创建、修改、删除。通常情况下不需要人为的管理。<br>位移主题的消息格式是 Kafka 定义的，不可以进行修改，也不能随意写消息（不符合格式，会无法解析造成 Broker 的崩溃）。<br>Kafka 新版本中 Consumer 的位移管理机制：将 Consumer 的位移数据作为一条条普通的 Kafka 消息，提交到 __consumer_offsets 中。</p>
<h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p>KV 对，在 Kafka 中就是字节数组：</p>
<ul>
<li>Key：消息的键值，包括 &lt;Grouop ID，主题名，分区号&gt;</li>
<li>Value：消息体，有三种消息格式：</li>
</ul>
<ol>
<li>位移值，时间戳，用户自定义数据</li>
<li>用于注册 Consumer Group 消息的数据</li>
<li>用于删除 Group 过期位移、删除 Group 的数据。称为墓碑消息（tombstone 消息，也称 delete mark）。</li>
</ol>
<ul>
<li>主要特点：消息体为 null</li>
<li>何时写入：某个 Conusmer Group 下的所有 Consumer 实例都停止，且位移数据都已被删除时，Kafka 会向位移主题的对应分区写入 tombstone 消息，表明彻底删除该 Group</li>
</ul>
<h3 id="怎么创建的"><a href="#怎么创建的" class="headerlink" title="怎么创建的"></a>怎么创建的</h3><h4 id="自动创建（建议）"><a href="#自动创建（建议）" class="headerlink" title="自动创建（建议）"></a>自动创建（建议）</h4><p>当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建该位移主题，该主题的分区数是 50，副本数是 3。</p>
<ul>
<li>分区数的设置：Broker 端参数 offsets.topic.num.partitions，默认值是 50。</li>
<li>副本数的设置：Broker 端参数 offsets.topic.replication.factor，默认值是 3。</li>
</ul>
<h4 id="手动创建"><a href="#手动创建" class="headerlink" title="手动创建"></a>手动创建</h4><p>在 Kafka 集群未启动任何 Consumer 之前，使用 Kafka API 创建。<br>好处：可以创建满足实际场景需要的位移主题，不必理会 offsets.topic.num.partitions 的值。</p>
<h3 id="Consumer-提交位移的方式"><a href="#Consumer-提交位移的方式" class="headerlink" title="Consumer 提交位移的方式"></a>Consumer 提交位移的方式</h3><h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>Consumer 参数 <code>enable.auto.commit</code> ，如果值为 true，则 Consumer 会在后台定期提交位移，提交间隔由 auto.commit.interval.ms 控制。<br>优点：省事<br>缺点：丧失了很大的灵活性和可控性，不能把控 Consumer 端的位移管理<br>问题：只要 Consumer 一直启动着，就会无限期地向位移主题写入消息（不是基于消费时间的处理，而是周期性的采集当前消息情况进行提交）。</p>
<h4 id="手动提交"><a href="#手动提交" class="headerlink" title="手动提交"></a>手动提交</h4><p>Consumer 参数 <code>enable.auto.commit</code> ，如果值为 false，需要手动提交位移。<br>Consumer API 提供的位移提交的方法：</p>
<ul>
<li>consumer.commitSync</li>
<li>commitAsync</li>
</ul>
<h3 id="过期消息的删除"><a href="#过期消息的删除" class="headerlink" title="过期消息的删除"></a>过期消息的删除</h3><p>通过 Compact 策略。Compact 的过程就是扫描日志的所有消息，剔除过期的消息，然后把剩下的消息整理在一起。</p>
<h4 id="如何定义过期消息"><a href="#如何定义过期消息" class="headerlink" title="如何定义过期消息"></a>如何定义过期消息</h4><p>对于同一个 Key 的两条消息 M1 和 M2，如果 M1 的发送时间早于 M2，那么 M1 就是过期消息。<br>Kafka 提供了专门的后台线程定期巡检待 Compact 的主题，该线程叫 Log Cleaner。如果生产环境中出现位移主题无限膨胀占用过多磁盘空间的问题，通常都是该线程挂掉后导致的，</p>
<h2 id="Consumer-位移提交"><a href="#Consumer-位移提交" class="headerlink" title="Consumer 位移提交"></a>Consumer 位移提交</h2><p>Consumer 向 Kafka 汇报自己的位移数据的过程被称为位移提交（Committing Offsets）。Consumer 需要为分配给他的每个分区提交各自的位移数据。<br><strong>Consumer 的消费位移，记录了 Consumer 要消费的下一条消息的位移，不是目前最新消费消息的位移。</strong><br>位移提交的语义保障是由 Conusmer 应用程序负责的，Kafka 只会 “无脑” 接收提交的位移。</p>
<ol>
<li>用户的角度</li>
</ol>
<ul>
<li>自动提交</li>
<li>手动提交</li>
</ul>
<ol start="2">
<li>Consumer 角度</li>
</ol>
<ul>
<li>同步提交</li>
<li>异步提交</li>
</ul>
<h3 id="设置自动提交位移的方法"><a href="#设置自动提交位移的方法" class="headerlink" title="设置自动提交位移的方法"></a>设置自动提交位移的方法</h3><p>自动提交位移的问题在于：可能会重复消费，只能通过减少 auto.commit.interval.ms 的值提高提交评率，但只能缩小重复消费的窗口，不可能完全消除它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="comment">// 开启自动提交位移，默认值是 true </span></span><br><span class="line">props.put(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"><span class="comment">// 每两秒提交一次位移，默认值是 5 秒</span></span><br><span class="line">props.put(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;2000&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">props.put(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> <span class="title class_">KafkaConsumer</span>&lt;&gt;(props);</span><br><span class="line">consumer.subscribe(Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records)</span><br><span class="line">		System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手动提交位移的方法"><a href="#手动提交位移的方法" class="headerlink" title="手动提交位移的方法"></a>手动提交位移的方法</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>同步提交的问题在于：调用 commitSync 时，Conusmer 程序处于阻塞状态，直到 Broker 返回提交结果，才会结束。会影响整个系统的 TPS。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	ConsumerRecords&lt;String, String&gt; records =consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">	process(records); <span class="comment">// 处理消息</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		consumer.commitSync();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (CommitFailedException e) &#123;</span><br><span class="line">		handle(e); <span class="comment">// 处理提交失败异常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>异步提交的问题在于：出现问题时不会自动重试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">	process(records); <span class="comment">// 处理消息</span></span><br><span class="line">	consumer.commitAsync((offsets, exception) -&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (exception != <span class="literal">null</span>)</span><br><span class="line">			handle(exception);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h4><p>组合使用可以达到最理想的效果，原因：</p>
<ol>
<li>可以利用 commitSync 的自动重试规避瞬时错误，例如：网络的瞬时抖动、Broker 端 GC。</li>
<li>不希望程序总处于阻塞状态，影响 TPS<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">		ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">		process(records); <span class="comment">// 处理消息</span></span><br><span class="line">		commitAysnc(); <span class="comment">// 使用异步提交规避阻塞</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">	handle(e); <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	consumer.commitSync(); <span class="comment">// 最后一次提交使用同步阻塞式提交</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	consumer.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>常规性、阶段性的手动提交，通过 commitAsync 避免程序阻塞</li>
<li>在 Consumer 关闭前，通过commitSync 执行同步阻塞式的位移提交，确保 Consumer 关闭前能够保存正确的位移数据</li>
</ul>
<h3 id="更精细化的位移提交"><a href="#更精细化的位移提交" class="headerlink" title="更精细化的位移提交"></a>更精细化的位移提交</h3><p>通过 commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt;) 和 commitAsync(Map&lt;TopicPartition, OffsetAndMetadata&gt; 在消费的中间进行位移提交。Map 对象的键是消费的分区，值对象中主要是位移数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	ConsumerRecords&lt;String, String&gt; records = </span><br><span class="line">	consumer.poll(Duration.ofSeconds(<span class="number">1</span>));</span><br><span class="line">	<span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record: records) &#123;</span><br><span class="line">		process(record);<span class="comment">// 处理消息</span></span><br><span class="line">		offsets.put(<span class="keyword">new</span> <span class="title class_">TopicPartition</span>(record.topic(), record.partition()), <span class="keyword">new</span> <span class="title class_">OffsetAndMetadata</span>(record.offset() + <span class="number">1</span>)； <span class="comment">// 提交下一条消息的位移</span></span><br><span class="line">		<span class="keyword">if</span>（count % <span class="number">100</span> == <span class="number">0</span>）</span><br><span class="line">			consumer.commitAsync(offsets, <span class="literal">null</span>); <span class="comment">// 回调处理逻辑是null</span></span><br><span class="line">			count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="削峰填谷"><a href="#削峰填谷" class="headerlink" title="削峰填谷"></a>削峰填谷</h2><blockquote>
<p>Q：为什么系统 A 不能直接发送消息给系统 B，还需要隔一个消息引擎<br>A：<br>1.削峰填谷 -&gt; 指缓冲上下游瞬时突发流量，使其更平滑，如果没有消息引擎的保护，下游系统可能会直接被压垮导致全链路服务雪崩<br>2.发送方和接收方的解耦，一定程度上简化了应用的开发</p>
<p>Q：如何使用 Kafka 解决实时相应问题<br>A：使用 Kafka Streams，是为 read-process-write 场景服务的</p>
<p>Q：MQ 和 RPC 调用的区别<br>A：常见的数据流有三种：</p>
<pre><code>    1. 通过数据库
    2. 通过服务调用（REST / RPC）
    3. 通过异步消息传递（消息引擎）
</code></pre>
<p>不同之处在于：<br>1.MQ 有自己的 buffer，能够对抗过载和不可用场景<br>2.MQ 支持重试<br>3.允许发布 &#x2F; 订阅模式<br>RPC 是介于通过数据库和通过 MQ 之间的数据流模式</p>
<p>Q：什么时候用 Kafka，什么时候用其他消息引擎<br>A：传统消息中间件支持的消息传输协议：AMQP、STOMP、MQTT，都支持比较复杂的消息路由（如 RabbitMQ），Kafka 并不具备<br>如果应用要支持这些协议或者是用于 SOA 中的应用互联，适合使用传统消息中间件，RocketMQ 擅长主打金融业务领域<br>如果应用场景是大数据方面的，可以考虑使用 Kakfa，它有较好的容错性、高伸缩性以及存储特性</p>
<p>Q：如何避免 Rebalance<br>A：使用 standalone consumer 可以完全避免，大多数主流大数据框架（Spark、Flink）就是这么做的</p>
<p>Q：Kafka 为什么不像 MySQL 那样允许 Follower 副本对外提供读服务<br>A：<br>1.因为 Kafka 的分区已经考虑了负载均衡<br>2.Leader 副本和 Follower 副本之间是有延迟的，如果 Follower 对外提供服务，需要进行同步，延迟更大<br>3.即便满足了《2》点的同步，Follower 提供读服务时，可能会导致不均衡的现象，因为 Leader 副本本身就尽量分摊到不同的 Broker 上</p>
<p>Q：Kafka 是按照什么规则将消息划分到各个分区的<br>A：<br>1.如果 Producer 指定了要发送的目标分区，消息则发送到指定的分区；否则按照 Producer 端参数 partitioner.class 指定的分区策略决定<br>2.如果没有指定过 partitioner.class，默认的规则是：消息如果包含 Key，则计算 Key 的murmur2 哈希值 % topic 分区数；不包含 Key，则按照轮询的方式确定分区</p>
<p>Q：Kafka 如何保证全局的消息顺序<br>A：目前 Kafka 的设计中多个分区无法保证全局的消息顺序，如果一定要实现，只能使用单分区</p>
</blockquote>
<h2 id="ISR"><a href="#ISR" class="headerlink" title="ISR"></a>ISR</h2><p>同步复制：只有所有的 follower 把数据拿过去后才commit，一致性好，可用性不高。<br>异步复制：只要 leader 拿到数据立即 commit，等 follower 慢慢去复制，可用性高，立即返回，一致性差一些。<br>Commit：是指 leader 告诉客户端，这条数据写成功了。kafka尽量保证 commit 后立即 leader 挂掉，其他 flower 都有该条数据。<br>kafka不是完全同步，也不是完全异步，是一种ISR机制：</p>
<ol>
<li>leader会维护一个与其基本保持同步的 Replica 列表，该列表称为 ISR(in-sync Replica)，每个 Partition 都会有一个 ISR，而且是由leader 动态维护</li>
<li>如果一个 flower 比一个 leader 落后太多，或者超过一定时间未发起数据复制请求，则 leader 将其重 ISR 中移除</li>
<li>当 ISR 中所有 Replica 都向 Leader 发送 ACK 时，leader 才 commit</li>
</ol>
<h2 id="消息经常堆积，不能消费"><a href="#消息经常堆积，不能消费" class="headerlink" title="消息经常堆积，不能消费"></a>消息经常堆积，不能消费</h2><p>产生的原因可能如下：</p>
<ol>
<li>生产速度大于消费速度，可以适当增加分区，增加 Consumer 输血量，提升消费 TPS</li>
<li>Consumer 消费性能偏低，排查是否有很重的消费逻辑，是否可以优化 Consumer 的 TPS</li>
<li>确保 Conusumer 没有因为异常而导致消费 Hang 住</li>
<li>如果使用的是消费者组，确保没有频繁发生 rebalance</li>
</ol>
<h2 id="针对消息去重"><a href="#针对消息去重" class="headerlink" title="针对消息去重"></a>针对消息去重</h2><p>Redis 缓存 Topic + Partition + Group 的偏移量，使精度提升到每一条消息。</p>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>M1 Pro 环境配置</title>
    <url>/MiracleDx/2021/11/18/M1%20Pro%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、软件安装"><a href="#一、软件安装" class="headerlink" title="一、软件安装"></a>一、软件安装</h1><table>
<thead>
<tr>
<th>软件名称</th>
<th>功能</th>
<th>下载渠道</th>
</tr>
</thead>
<tbody><tr>
<td>Typora</td>
<td>MarkDown 编辑工具</td>
<td>官网</td>
</tr>
<tr>
<td>超级右键</td>
<td>右键菜单编辑工具</td>
<td>App Store</td>
</tr>
<tr>
<td>Alfred 4</td>
<td>键盘工作流</td>
<td>官网（需破解）</td>
</tr>
<tr>
<td>INNA</td>
<td>视频播放软件</td>
<td>官网</td>
</tr>
<tr>
<td>Downie 4</td>
<td>视频下载</td>
<td>官网（需破解）</td>
</tr>
<tr>
<td>Tencent Lemon</td>
<td>系统清理工具</td>
<td>官网</td>
</tr>
<tr>
<td>Bartender</td>
<td>菜单栏管理</td>
<td>官网（需破解）</td>
</tr>
<tr>
<td>WPS</td>
<td>文档工具</td>
<td>App Store</td>
</tr>
<tr>
<td>幕布</td>
<td>思维导图工具</td>
<td>官网</td>
</tr>
<tr>
<td>有道云笔记</td>
<td>云笔记工具</td>
<td>App Store</td>
</tr>
<tr>
<td>Dash</td>
<td>API 工具</td>
<td>官网</td>
</tr>
<tr>
<td>Chrome</td>
<td>谷歌浏览器</td>
<td>官网</td>
</tr>
<tr>
<td>Keka</td>
<td>压缩工具</td>
<td>官网</td>
</tr>
<tr>
<td>vscode</td>
<td>轻量级 IDE</td>
<td>官网</td>
</tr>
<tr>
<td>sublime</td>
<td>文本编辑器</td>
<td>官网</td>
</tr>
<tr>
<td>Iterm2</td>
<td>终端工具</td>
<td>官网</td>
</tr>
<tr>
<td>Ishot</td>
<td>截图工具</td>
<td>App Store</td>
</tr>
<tr>
<td>AnotherDesktopManager</td>
<td>Redis 连接工具</td>
<td>GitHub</td>
</tr>
<tr>
<td>PrettyZoo</td>
<td>Zookeeper 连接工具（需要转译，未下载）</td>
<td>GitHub</td>
</tr>
<tr>
<td>Spark</td>
<td>邮件</td>
<td>App Store</td>
</tr>
<tr>
<td>滴答清单</td>
<td>时间规划</td>
<td>App Store</td>
</tr>
<tr>
<td>欧路词典</td>
<td>英语翻译软件</td>
<td>App Store</td>
</tr>
<tr>
<td>TopNotch</td>
<td>状态栏黑化</td>
<td>官网</td>
</tr>
<tr>
<td>自动切换输入法 Lite</td>
<td>自动切换输入法</td>
<td>App Store</td>
</tr>
<tr>
<td>ScrollReverser</td>
<td>翻转鼠标滚动方向与 windows 一致</td>
<td>官网</td>
</tr>
<tr>
<td>CatchMouse</td>
<td>快速切屏</td>
<td>官网</td>
</tr>
</tbody></table>
<h1 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h1><p>破解 APP 下载地址（需搭梯子）：<a href="https://appstorrent.ru/">https://appstorrent.ru/</a></p>
<h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">外观 -&gt; 字数统计 -&gt; 总是显示字数统计 </span><br><span class="line">外观 -&gt; 侧边栏 -&gt; 侧边栏的大纲允许折叠和展开 </span><br><span class="line">编辑器 -&gt; 默认缩进 4 -&gt; 对齐缩进 </span><br><span class="line">图像 -&gt; 插入图片时 复制到指定路径 -&gt; ./$&#123;filename&#125;.images -&gt; 对本地位置的图片应用上述规则 / 优先使用相对路径</span><br><span class="line">图床设置参考：https://zhuanlan.zhihu.com/p/365829157</span><br><span class="line">Markdown -&gt; 代码块 -&gt; 显示行号 / 代码块自动换行 -&gt; 代码缩进 4</span><br></pre></td></tr></table></figure>
<h2 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a>Homebrew</h2><p>官网：<a href="https://brew.sh/index_zh-cn">https://brew.sh/index_zh-cn</a><br>原生下载需要搭梯子</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用 Gitee 脚本，选择中科大下载源镜像，根据提示安装</span></span><br><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></pre></td></tr></table></figure>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</span><br></pre></td></tr></table></figure>
<h2 id="配置日历（未配置）"><a href="#配置日历（未配置）" class="headerlink" title="配置日历（未配置）"></a>配置日历（未配置）</h2><p>增加法定节假日</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Terminal 执行 二选一</span></span><br><span class="line">webcal://p10-calendars.icloud.com/published/2/MTI3Njk0MTQxNzEyNzY5NFRvxM53AOH-Px17vHeUETlZdUggoyEt2KnFiIqHg40FkRXfcQJjYoa2dULRarI9z4UlbHxK-kLOohfiRVSSP7Q</span><br><span class="line">webcal://p22-calendars.icloud.com/published/2/RL1JwQQtKFudYOiicAG_adz9DdrozFeZzv5Uyrs4s3gyWobdzL1NZFH-ZHAsTfuAevtnzdqVdYmcRO_Y_dWtxeIdmzUA1TNkAt5RuotJmsg</span><br></pre></td></tr></table></figure>
<h2 id="Parallels-Desktop"><a href="#Parallels-Desktop" class="headerlink" title="Parallels Desktop"></a>Parallels Desktop</h2><p>下载破解工具 <a href="https://github.com/lihaoyun6/PD-Runner">https://github.com/lihaoyun6/PD-Runner</a><br>官网下载 Parallels Desktop<br>按照提示下载 Windows 11 安装</p>
<h2 id="Iterm2"><a href="#Iterm2" class="headerlink" title="Iterm2"></a>Iterm2</h2><p>官网下载 Iterm2</p>
<h3 id="配置左右键跳转-option-←-→"><a href="#配置左右键跳转-option-←-→" class="headerlink" title="配置左右键跳转 option + ←|→"></a>配置左右键跳转 option + ←|→</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211117083522625.png" alt="image-20211117083522625"></p>
<h3 id="快速显示和隐藏"><a href="#快速显示和隐藏" class="headerlink" title="快速显示和隐藏"></a>快速显示和隐藏</h3><p>按住 <code>commamnd + ,</code> 打开 <code>Preferences</code> 配置界面，然后 <code>Keys → Hoykey</code><br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211117083322056.png" alt="image-20211117083322056"></p>
<h3 id="配置-cmd-→-←"><a href="#配置-cmd-→-←" class="headerlink" title="配置 cmd + → | ←"></a>配置 cmd + → | ←</h3><p>按住 <code>commamnd + ,</code> 打开 <code>Preferences</code> 配置界面，然后 <code>Profiles → keys</code> 添加两个快捷键</p>
<ul>
<li>录入：cmd + ←</li>
<li>录入 cmd + →<img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211117083828842.png" alt="image-20211117083828842"></li>
</ul>
<h3 id="iTerm2-快捷命令"><a href="#iTerm2-快捷命令" class="headerlink" title="iTerm2 快捷命令"></a>iTerm2 快捷命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>command + t</td>
<td>新建标签</td>
</tr>
<tr>
<td>command + w</td>
<td>关闭标签</td>
</tr>
<tr>
<td>command + 数字 command + 左右方向键</td>
<td>切换标签</td>
</tr>
<tr>
<td>command + enter</td>
<td>切换全屏</td>
</tr>
<tr>
<td>command + f</td>
<td>查找</td>
</tr>
<tr>
<td>command + d</td>
<td>垂直分屏</td>
</tr>
<tr>
<td>command + shift + d</td>
<td>水平分屏</td>
</tr>
<tr>
<td>command + option + 方向键 command + [ 或 command + ]</td>
<td>切换屏幕</td>
</tr>
<tr>
<td>command + ;</td>
<td>查看历史命令</td>
</tr>
<tr>
<td>command + shift + h</td>
<td>查看剪贴板历史</td>
</tr>
<tr>
<td>ctrl + u</td>
<td>清除当前行</td>
</tr>
<tr>
<td>ctrl + l</td>
<td>清屏</td>
</tr>
<tr>
<td>ctrl + a</td>
<td>到行首</td>
</tr>
<tr>
<td>ctrl + e</td>
<td>到行尾</td>
</tr>
<tr>
<td>ctrl + f&#x2F;b</td>
<td>前进后退</td>
</tr>
<tr>
<td>ctrl + p</td>
<td>上一条命令</td>
</tr>
<tr>
<td>ctrl + r</td>
<td>搜索命令历</td>
</tr>
</tbody></table>
<h2 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>网络原因，直接 <code>vim install.sh</code>，复制以下代码，<code>sh install.sh</code> 完成安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># This script should be run via curl:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or via wget:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh -c <span class="string">&quot;<span class="subst">$(wget -qO- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or via fetch:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh -c <span class="string">&quot;<span class="subst">$(fetch -o - https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># As an alternative, you can first download the install script and run it afterwards:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh install.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># You can tweak the install behavior by setting variables when running the script. For</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">example, to change the path to the Oh My Zsh repository:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZSH=~/.zsh sh install.sh</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Respects the following environment variables:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ZSH - path to the Oh My Zsh repository folder (default: <span class="variable">$HOME</span>/.oh-my-zsh)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">REPO- name of the GitHub repo to install from (default: ohmyzsh/ohmyzsh)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">REMOTE- full remote URL of the git repo to install (default: GitHub via HTTPS)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">BRANCH- branch to check out immediately after install (default: master)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Other options:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CHSH - <span class="string">&#x27;no&#x27;</span> means the installer will not change the default shell (default: <span class="built_in">yes</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RUNZSH - <span class="string">&#x27;no&#x27;</span> means the installer will not run zsh after the install (default: <span class="built_in">yes</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">KEEP_ZSHRC - <span class="string">&#x27;yes&#x27;</span> means the installer will not replace an existing .zshrc (default: no)</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># You can also pass some arguments to the install script to set some these options:</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--skip-chsh: has the same behavior as setting CHSH to <span class="string">&#x27;no&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--unattended: sets both CHSH and RUNZSH to <span class="string">&#x27;no&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--keep-zshrc: sets KEEP_ZSHRC to <span class="string">&#x27;yes&#x27;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For example:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh install.sh --unattended</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">or:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span> <span class="string">&quot;&quot;</span> --unattended</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="built_in">set</span> -e</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default settings</span></span><br><span class="line">ZSH=$&#123;ZSH:-~/.oh-my-zsh&#125;</span><br><span class="line">REPO=$&#123;REPO:-ohmyzsh/ohmyzsh&#125;</span><br><span class="line">REMOTE=$&#123;REMOTE:-https://github.com/$&#123;REPO&#125;.git&#125;</span><br><span class="line">BRANCH=$&#123;BRANCH:-master&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Other options</span></span><br><span class="line">CHSH=$&#123;CHSH:-yes&#125;</span><br><span class="line">RUNZSH=$&#123;RUNZSH:-yes&#125;</span><br><span class="line">KEEP_ZSHRC=$&#123;KEEP_ZSHRC:-no&#125;</span><br><span class="line">command_exists() &#123;</span><br><span class="line">	command -v &quot;$@&quot; &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">&#125;</span><br><span class="line">error() &#123;</span><br><span class="line">	echo $&#123;RED&#125;&quot;Error: $@&quot;$&#123;RESET&#125; &gt;&amp;2</span><br><span class="line">&#125;</span><br><span class="line">underline() &#123;</span><br><span class="line">	echo &quot;$(printf &#x27;\033[4m&#x27;)$@$(printf &#x27;\033[24m&#x27;)&quot;</span><br><span class="line">&#125;</span><br><span class="line">setup_color() &#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Only use colors <span class="keyword">if</span> connected to a terminal</span></span><br><span class="line">	if [ -t 1 ]; then</span><br><span class="line">		RED=$(printf &#x27;\033[31m&#x27;)</span><br><span class="line">		GREEN=$(printf &#x27;\033[32m&#x27;)</span><br><span class="line">		YELLOW=$(printf &#x27;\033[33m&#x27;)</span><br><span class="line">		BLUE=$(printf &#x27;\033[34m&#x27;)</span><br><span class="line">		BOLD=$(printf &#x27;\033[1m&#x27;)</span><br><span class="line">		RESET=$(printf &#x27;\033[m&#x27;)</span><br><span class="line">	else</span><br><span class="line">		RED=&quot;&quot;</span><br><span class="line">		GREEN=&quot;&quot;</span><br><span class="line">		YELLOW=&quot;&quot;</span><br><span class="line">		BLUE=&quot;&quot;</span><br><span class="line">		BOLD=&quot;&quot;</span><br><span class="line">		RESET=&quot;&quot;</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line">setup_ohmyzsh() &#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Prevent the cloned repository from having insecure permissions. Failing to <span class="keyword">do</span></span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">so causes compinit() calls to fail with <span class="string">&quot;command not found: compdef&quot;</span> errors</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="keyword">for</span> <span class="built_in">users</span> with insecure umasks (e.g., <span class="string">&quot;002&quot;</span>, allowing group writability). Note</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">that this will be ignored under Cygwin by default, as Windows ACLs take</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">precedence over umasks except <span class="keyword">for</span> filesystems mounted with option <span class="string">&quot;noacl&quot;</span>.</span></span><br><span class="line">	umask g-w,o-w</span><br><span class="line">	echo &quot;$&#123;BLUE&#125;Cloning Oh My Zsh...$&#123;RESET&#125;&quot;</span><br><span class="line">	command_exists git || &#123;</span><br><span class="line">		error &quot;git is not installed&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	&#125;</span><br><span class="line">	if [ &quot;$OSTYPE&quot; = cygwin ] &amp;&amp; git --version | grep -q msysgit; then</span><br><span class="line">		error &quot;Windows/MSYS Git is not supported on Cygwin&quot;</span><br><span class="line">		error &quot;Make sure the Cygwin git package is installed and is first on the \$PATH&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line">	git clone -c core.eol=lf -c core.autocrlf=false \</span><br><span class="line">		-c fsck.zeroPaddedFilemode=ignore \</span><br><span class="line">		-c fetch.fsck.zeroPaddedFilemode=ignore \</span><br><span class="line">		-c receive.fsck.zeroPaddedFilemode=ignore \</span><br><span class="line">		--depth=1 --branch &quot;$BRANCH&quot; &quot;$REMOTE&quot; &quot;$ZSH&quot; || &#123;</span><br><span class="line">		error &quot;git clone of oh-my-zsh repo failed&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	&#125;</span><br><span class="line">	echo</span><br><span class="line">&#125;</span><br><span class="line">setup_zshrc() &#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Keep most recent old .zshrc at .zshrc.pre-oh-my-zsh, and older ones</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">with datestamp of installation that moved them aside, so we never actually</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">destroy a user<span class="string">&#x27;s original zshrc</span></span></span><br><span class="line">	echo &quot;$&#123;BLUE&#125;Looking for an existing zsh config...$&#123;RESET&#125;&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">Must use this exact name so uninstall.sh can find it</span></span></span><br><span class="line">	OLD_ZSHRC=~/.zshrc.pre-oh-my-zsh</span><br><span class="line">	if [ -f ~/.zshrc ] || [ -h ~/.zshrc ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">Skip this if the user doesn&#x27;</span>t want to replace an existing .zshrc</span></span><br><span class="line">		if [ $KEEP_ZSHRC = yes ]; then</span><br><span class="line">			echo &quot;$&#123;YELLOW&#125;Found ~/.zshrc.$&#123;RESET&#125; $&#123;GREEN&#125;Keeping...$&#123;RESET&#125;&quot;</span><br><span class="line">			return</span><br><span class="line">		fi</span><br><span class="line">		if [ -e &quot;$OLD_ZSHRC&quot; ]; then</span><br><span class="line">			OLD_OLD_ZSHRC=&quot;$&#123;OLD_ZSHRC&#125;-$(date +%Y-%m-%d_%H-%M-%S)&quot;</span><br><span class="line">			if [ -e &quot;$OLD_OLD_ZSHRC&quot; ]; then</span><br><span class="line">				error &quot;$OLD_OLD_ZSHRC exists. Can&#x27;t back up $&#123;OLD_ZSHRC&#125;&quot;</span><br><span class="line">				error &quot;re-run the installer again in a couple of seconds&quot;</span><br><span class="line">				exit 1</span><br><span class="line">			fi</span><br><span class="line">			mv &quot;$OLD_ZSHRC&quot; &quot;$&#123;OLD_OLD_ZSHRC&#125;&quot;</span><br><span class="line">			echo &quot;$&#123;YELLOW&#125;Found old ~/.zshrc.pre-oh-my-zsh.&quot; \</span><br><span class="line">				&quot;$&#123;GREEN&#125;Backing up to $&#123;OLD_OLD_ZSHRC&#125;$&#123;RESET&#125;&quot;</span><br><span class="line">		fi</span><br><span class="line">		echo &quot;$&#123;YELLOW&#125;Found ~/.zshrc.$&#123;RESET&#125; $&#123;GREEN&#125;Backing up to $&#123;OLD_ZSHRC&#125;$&#123;RESET&#125;&quot;</span><br><span class="line">		mv ~/.zshrc &quot;$OLD_ZSHRC&quot;</span><br><span class="line">	fi</span><br><span class="line">	echo &quot;$&#123;GREEN&#125;Using the Oh My Zsh template file and adding it to ~/.zshrc.$&#123;RESET&#125;&quot;</span><br><span class="line">	sed &quot;/^export ZSH=/ c\\</span><br><span class="line">export ZSH=\&quot;$ZSH\&quot;</span><br><span class="line">&quot; &quot;$ZSH/templates/zshrc.zsh-template&quot; &gt; ~/.zshrc-omztemp</span><br><span class="line">	mv -f ~/.zshrc-omztemp ~/.zshrc</span><br><span class="line">	echo</span><br><span class="line">&#125;</span><br><span class="line">setup_shell() &#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Skip setup <span class="keyword">if</span> the user wants or stdin is closed (not running interactively).</span></span><br><span class="line">	if [ $CHSH = no ]; then</span><br><span class="line">		return</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">If this user<span class="string">&#x27;s login shell is already &quot;zsh&quot;, do not attempt to switch.</span></span></span><br><span class="line">	if [ &quot;$(basename &quot;$SHELL&quot;)&quot; = &quot;zsh&quot; ]; then</span><br><span class="line">		return</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">If this platform doesn&#x27;</span>t provide a <span class="string">&quot;chsh&quot;</span> <span class="built_in">command</span>, bail out.</span></span><br><span class="line">	if ! command_exists chsh; then</span><br><span class="line">		cat &lt;&lt;-EOF</span><br><span class="line">			I can&#x27;t change your shell automatically because this system does not have chsh.</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash">&#123;BLUE&#125;Please manually change your default shell to zsh<span class="variable">$&#123;RESET&#125;</span></span></span><br><span class="line">		EOF</span><br><span class="line">		return</span><br><span class="line">	fi</span><br><span class="line">	echo &quot;$&#123;BLUE&#125;Time to change your default shell to zsh:$&#123;RESET&#125;&quot;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Prompt <span class="keyword">for</span> user choice on changing the default login shell</span></span><br><span class="line">	printf &quot;$&#123;YELLOW&#125;Do you want to change your default shell to zsh? [Y/n]$&#123;RESET&#125; &quot;</span><br><span class="line">	read opt</span><br><span class="line">	case $opt in</span><br><span class="line">		y*|Y*|&quot;&quot;) echo &quot;Changing the shell...&quot; ;;</span><br><span class="line">		n*|N*) echo &quot;Shell change skipped.&quot;; return ;;</span><br><span class="line">		*) echo &quot;Invalid choice. Shell change skipped.&quot;; return ;;</span><br><span class="line">	esac</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Check <span class="keyword">if</span> we<span class="string">&#x27;re running on Termux</span></span></span><br><span class="line">	case &quot;$PREFIX&quot; in</span><br><span class="line">		*com.termux*) termux=true; zsh=zsh ;;</span><br><span class="line">		*) termux=false ;;</span><br><span class="line">	esac</span><br><span class="line">	if [ &quot;$termux&quot; != true ]; then</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">Test for the right location of the &quot;shells&quot; file</span></span></span><br><span class="line">		if [ -f /etc/shells ]; then</span><br><span class="line">			shells_file=/etc/shells</span><br><span class="line">		elif [ -f /usr/share/defaults/etc/shells ]; then # Solus OS</span><br><span class="line">			shells_file=/usr/share/defaults/etc/shells</span><br><span class="line">		else</span><br><span class="line">			error &quot;could not find /etc/shells file. Change your default shell manually.&quot;</span><br><span class="line">			return</span><br><span class="line">		fi</span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">Get the path to the right zsh binary</span></span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash"><span class="string">1. Use the most preceding one based on $PATH, then check that it&#x27;</span>s <span class="keyword">in</span> the shells file</span></span><br><span class="line"><span class="meta prompt_">		# </span><span class="language-bash">2. If that fails, get a zsh path from the shells file, <span class="keyword">then</span> check it actually exists</span></span><br><span class="line">		if ! zsh=$(which zsh) || ! grep -qx &quot;$zsh&quot; &quot;$shells_file&quot;; then</span><br><span class="line">			if ! zsh=$(grep &#x27;^/.*/zsh$&#x27; &quot;$shells_file&quot; | tail -1) || [ ! -f &quot;$zsh&quot; ]; then</span><br><span class="line">				error &quot;no zsh binary found or not present in &#x27;$shells_file&#x27;&quot;</span><br><span class="line">				error &quot;change your default shell manually.&quot;</span><br><span class="line">				return</span><br><span class="line">			fi</span><br><span class="line">		fi</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">We<span class="string">&#x27;re going to change the default shell, so back up the current one</span></span></span><br><span class="line">	if [ -n &quot;$SHELL&quot; ]; then</span><br><span class="line">		echo $SHELL &gt; ~/.shell.pre-oh-my-zsh</span><br><span class="line">	else</span><br><span class="line">		grep &quot;^$USER:&quot; /etc/passwd | awk -F: &#x27;&#123;print $7&#125;&#x27; &gt; ~/.shell.pre-oh-my-zsh</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">Actually change the default shell to zsh</span></span></span><br><span class="line">	if ! chsh -s &quot;$zsh&quot;; then</span><br><span class="line">		error &quot;chsh command unsuccessful. Change your default shell manually.&quot;</span><br><span class="line">	else</span><br><span class="line">		export SHELL=&quot;$zsh&quot;</span><br><span class="line">		echo &quot;$&#123;GREEN&#125;Shell successfully changed to &#x27;$zsh&#x27;.$&#123;RESET&#125;&quot;</span><br><span class="line">	fi</span><br><span class="line">	echo</span><br><span class="line">&#125;</span><br><span class="line">main() &#123;</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">Run as unattended if stdin is closed</span></span></span><br><span class="line">	if [ ! -t 0 ]; then</span><br><span class="line">		RUNZSH=no</span><br><span class="line">		CHSH=no</span><br><span class="line">	fi</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash"><span class="string">Parse arguments</span></span></span><br><span class="line">	while [ $# -gt 0 ]; do</span><br><span class="line">		case $1 in</span><br><span class="line">			--unattended) RUNZSH=no; CHSH=no ;;</span><br><span class="line">			--skip-chsh) CHSH=no ;;</span><br><span class="line">			--keep-zshrc) KEEP_ZSHRC=yes ;;</span><br><span class="line">		esac</span><br><span class="line">		shift</span><br><span class="line">	done</span><br><span class="line">	setup_color</span><br><span class="line">	if ! command_exists zsh; then</span><br><span class="line">		echo &quot;$&#123;YELLOW&#125;Zsh is not installed.$&#123;RESET&#125; Please install zsh first.&quot;</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line">	if [ -d &quot;$ZSH&quot; ]; then</span><br><span class="line">		cat &lt;&lt;-EOF</span><br><span class="line"><span class="meta prompt_">			$</span><span class="language-bash"><span class="string">&#123;YELLOW&#125;You already have Oh My Zsh installed.$&#123;RESET&#125;</span></span></span><br><span class="line">			You&#x27;ll need to remove &#x27;$ZSH&#x27; if you want to reinstall.</span><br><span class="line">		EOF</span><br><span class="line">		exit 1</span><br><span class="line">	fi</span><br><span class="line">	setup_ohmyzsh</span><br><span class="line">	setup_zshrc</span><br><span class="line">	setup_shell</span><br><span class="line">	printf &quot;$GREEN&quot;</span><br><span class="line">	cat &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">		 __ __</span><br><span class="line">		____/ /_ ____ _______ _________/ /_</span><br><span class="line">		 / __ \/ __ \ / __ `__ \/ / / //_/ / ___/ __ \</span><br><span class="line">		/ /_/ / / / // / / / / / /_/ // /_(__) / / /</span><br><span class="line">		\____/_/ /_//_/ /_/ /_/\__, //___/____/_/ /_/</span><br><span class="line">		/____/ ....is now installed!</span><br><span class="line">	EOF</span><br><span class="line">	cat &lt;&lt;-EOF</span><br><span class="line">		Before you scream Oh My Zsh! please look over the ~/.zshrc file to select plugins, themes, and options.</span><br><span class="line">		• Follow us on Twitter: $(underline https://twitter.com/ohmyzsh)</span><br><span class="line">		• Join our Discord server: $(underline https://discord.gg/ohmyzsh)</span><br><span class="line">		• Get stickers, shirts, coffee mugs and other swag: $(underline https://shop.planetargon.com/collections/oh-my-zsh)</span><br><span class="line">	EOF</span><br><span class="line">	printf &quot;$RESET&quot;</span><br><span class="line">	if [ $RUNZSH = no ]; then</span><br><span class="line">		echo &quot;$&#123;YELLOW&#125;Run zsh to try it out.$&#123;RESET&#125;&quot;</span><br><span class="line">		exit</span><br><span class="line">	fi</span><br><span class="line">	exec zsh -l</span><br><span class="line">&#125;</span><br><span class="line">main &quot;$@&quot;</span><br></pre></td></tr></table></figure>
<h3 id="配置-zsh-主题"><a href="#配置-zsh-主题" class="headerlink" title="配置 zsh 主题"></a>配置 zsh 主题</h3><p>可以在 GitHub 仓库中选择其它主题<strong><a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">https://github.com/ohmyzsh/ohmyzsh/wiki/Themes</a></strong><br>编辑 <code>vim ~/.zshrc</code> 修改主题为 <code>ZSH_THEME=&quot;ys&quot;</code></p>
<h3 id="zsh-提示权限问题"><a href="#zsh-提示权限问题" class="headerlink" title="zsh 提示权限问题"></a>zsh 提示权限问题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 755 /opt/homebrew/share/zsh</span><br><span class="line">chmod 755 /opt/homebrew/share/zsh/site-functions</span><br></pre></td></tr></table></figure>
<h3 id="声明高亮"><a href="#声明高亮" class="headerlink" title="声明高亮"></a>声明高亮</h3><p><code>brew install zsh-syntax-highlighting</code><br>安装完成后，编辑 <code>vim ~/.zshrc</code>，在最后一行添加配置 <code>source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</code></p>
<h3 id="自动建议填充"><a href="#自动建议填充" class="headerlink" title="自动建议填充"></a>自动建议填充</h3><p>克隆到指定目录 <code>brew install zsh-autosuggestions</code><br>安装完成后，编辑 <code>vim ~/.zshrc</code>，在最后一行添加配置 <code>source /opt/homebrew/share/zsh-syntax-highlighting/zsh-autosuggestions.zsh</code></p>
<h3 id="目录快速跳转"><a href="#目录快速跳转" class="headerlink" title="目录快速跳转"></a>目录快速跳转</h3><p>安装 <code>brew install autojump</code><br>编辑 <code>vim ~/.zshrc</code> 在 <code>plugins</code> 中添加 <code>autojump</code><br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211117090245694.png" alt="image-20211117090245694"></p>
<h3 id="history-命令时间格式"><a href="#history-命令时间格式" class="headerlink" title="history 命令时间格式"></a>history 命令时间格式</h3><p>编辑 <code>vim ~/.zshrc</code> 修改 <code>HIST_STAMPS=&quot;yyyy-mm-dd&quot;</code></p>
<h3 id="bat-代替-cat"><a href="#bat-代替-cat" class="headerlink" title="bat 代替 cat"></a>bat 代替 cat</h3><p>安装：<code>brew install bat</code><br>支持行号显示</p>
<h3 id="配置-vim"><a href="#配置-vim" class="headerlink" title="配置 vim"></a>配置 vim</h3><p>编辑 <code>vim ~/.vimrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot; 设定默认解码 </span><br><span class="line">set fenc=utf-8 </span><br><span class="line">set fencs=utf-8,usc-bom,euc-jp,gb18030,gbk,gb2312,cp936 </span><br><span class="line">&quot; 不要使用vi的键盘模式，而是vim自己的</span><br><span class="line">set nocompatible</span><br><span class="line">&quot; 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位） </span><br><span class="line">set mouse=a </span><br><span class="line">set selection=exclusive </span><br><span class="line">set selectmode=mouse,key</span><br><span class="line">&quot; 光标移动到buffer的顶部和底部时保持3行距离</span><br><span class="line">set scrolloff=3</span><br><span class="line">&quot; 设置颜色主题</span><br><span class="line">colorscheme ron</span><br><span class="line">&quot; 语法高亮</span><br><span class="line">:syntax on</span><br><span class="line">&quot; 状态行颜色 </span><br><span class="line">highlight StatusLine guifg=SlateBlue guibg=Yellow </span><br><span class="line">highlight StatusLineNC guifg=Gray guibg=White </span><br><span class="line">&quot; 在状态行上显示光标所在位置的行号和列号 </span><br><span class="line">set ruler </span><br><span class="line">set rulerformat=%20(%2*%&lt;%f%=\ %m%r\ %3l\ %c\ %p%%%) </span><br><span class="line">&quot; 高亮显示匹配的括号</span><br><span class="line">set showmatch</span><br><span class="line">&quot; 匹配括号高亮的时间（单位是十分之一秒）</span><br><span class="line">set matchtime=1</span><br><span class="line">&quot; 我的状态行显示的内容（包括文件类型和解码）</span><br><span class="line">set statusline=%F%m%r%h%w\ [FORMAT=%&#123;&amp;ff&#125;]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %&#123;strftime(\&quot;%y/%m/%d\ -\ %H:%M\&quot;)&#125;</span><br><span class="line">&quot; 总是显示状态行 </span><br><span class="line">set laststatus=2</span><br><span class="line">&quot; 继承前一行的缩进方式，特别适用于多行注释</span><br><span class="line">set autoindent</span><br><span class="line">&quot; 提供自动缩进 </span><br><span class="line">set smartindent</span><br><span class="line">&quot; 在搜索的时候忽略大小写</span><br><span class="line">set ignorecase</span><br><span class="line">&quot; 检测文件类型</span><br><span class="line">filetype on</span><br><span class="line">&quot; 载入文件类型插件</span><br><span class="line">filetype plugin on</span><br><span class="line">&quot; 为特定文件类型载入相关缩进文件 </span><br><span class="line">filetype indent on</span><br><span class="line">&quot; 统一缩进为4</span><br><span class="line">set sts=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">&quot; 使回格键（backspace）正常处理indent, eol, start等</span><br><span class="line">set backspace=2</span><br><span class="line">&quot; 制表符为4</span><br><span class="line">set tabstop=4</span><br><span class="line">set showmode</span><br><span class="line">&quot; 设定行号</span><br><span class="line">set nu</span><br><span class="line">&quot; 不高亮被搜索的句子</span><br><span class="line">set nohlsearch</span><br><span class="line">&quot; 不让vim发出讨厌的滴滴声</span><br><span class="line">set noerrorbells</span><br><span class="line">&quot; 不要用空格代替制表符</span><br><span class="line">set noexpandtab</span><br><span class="line">&quot; 在行和段开始处使用制表符</span><br><span class="line">set smarttab</span><br><span class="line">&quot; history文件中需要记录的行数</span><br><span class="line">set history=100</span><br></pre></td></tr></table></figure>
<h2 id="Chrome-开启标签预览"><a href="#Chrome-开启标签预览" class="headerlink" title="Chrome 开启标签预览"></a>Chrome 开启标签预览</h2><p>Chrome 浏览器中的「标签预览」属于实验性功能，需要手动开启<br>在谷歌浏览器地址栏中输入 <code>chrome://flags/#tab-hover-cards</code><br>然后将 <code>Tab Hover Cards</code> 和 <code>Tab Hover Cards Images</code> 后面的选项，都调整为 <code>Enabled</code> 即可</p>
<h2 id="多-JDK-环境配置"><a href="#多-JDK-环境配置" class="headerlink" title="多 JDK 环境配置"></a>多 JDK 环境配置</h2><h3 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h3><p>Zulu 官网下载 JDK，通过 dmg 格式安装默认配置好环境变量<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211118110913122.png" alt="image-20211118110913122">配置多环境变量<br>在 <code>vim ~/.zshrc</code> 中添加以下配置，保存后 <code>source ~/.zshrc</code> 使环境变量生效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 JDK Home</span></span><br><span class="line">export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home</span><br><span class="line">export JAVA_11_HOME=/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home</span><br><span class="line">export JAVA_17_HOME=/Library/Java/JavaVirtualMachines/zulu-17.jdk/Contents/Home</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认 JDK 版本</span></span><br><span class="line">export JAVA_HOME=$JAVA_8_HOME</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">多版本切换</span></span><br><span class="line">alias jdk8=&quot;export JAVA_HOME=$JAVA_8_HOME&quot;</span><br><span class="line">alias jdk11=&quot;export JAVA_HOME=$JAVA_11_HOME&quot;</span><br><span class="line">alias jdk17=&quot;export JAVA_HOME=$JAVA_17_HOME&quot;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211118110651455.png" alt="image-20211118110651455"></p>
<h3 id="可以通过别名快速切换当前-JDK-版本"><a href="#可以通过别名快速切换当前-JDK-版本" class="headerlink" title="可以通过别名快速切换当前 JDK 版本"></a>可以通过别名快速切换当前 JDK 版本</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211118111416224.png" alt="image-20211118111416224"></p>
<h2 id="配置-Maven"><a href="#配置-Maven" class="headerlink" title="配置 Maven"></a>配置 Maven</h2><ol>
<li>在 Mavne 官网中下载 maven</li>
<li>在 <code>vim ~/.zshrc</code> 中添加以下配置，保存后 <code>source ~/.zshrc</code> 使环境变量生效<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> MAVEN_HOME=/opt/apache-maven-3.6.3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$MAVEN_HOME</span>/bin</span><br></pre></td></tr></table></figure></li>
<li>验证<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211118111528178.png" alt="image-20211118111528178"></li>
</ol>
<h2 id="Intellj-IDEA"><a href="#Intellj-IDEA" class="headerlink" title="Intellj IDEA"></a>Intellj IDEA</h2><h3 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h3><ol>
<li>适用于 2021前所有版本</li>
<li>Plugins 中增加 Repository <a href="https://plugins.zhile.io/">https://plugins.zhile.io</a></li>
<li>在 Marketplace 中搜索 IDE Eal Reset</li>
<li>在IDE Eal Reset 选项卡中勾选 reload reset 即可</li>
</ol>
<h3 id="IDEA-插件"><a href="#IDEA-插件" class="headerlink" title="IDEA 插件"></a>IDEA 插件</h3><table>
<thead>
<tr>
<th>插件名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>.ignore</td>
<td>git ignore 插件</td>
</tr>
<tr>
<td>Alibaba Java Coding Guidelines</td>
<td>阿里巴巴编码规范</td>
</tr>
<tr>
<td>Alibaba Cloud AI Coding Assistant</td>
<td>阿里巴巴 AI 编码助手插件</td>
</tr>
<tr>
<td>Translation</td>
<td>翻译插件</td>
</tr>
<tr>
<td>arthas idea</td>
<td>arthas 插件</td>
</tr>
<tr>
<td>POJO to Json</td>
<td>POJO 转换 Json 插件</td>
</tr>
<tr>
<td>GsonFormatPlus</td>
<td>Jsonn 转换 POJO 插件</td>
</tr>
<tr>
<td>Maven Helper</td>
<td>Maven 依赖助手</td>
</tr>
<tr>
<td>Nyan Progress Bar</td>
<td>进度条样式插件</td>
</tr>
<tr>
<td>Rainbow Brackets</td>
<td>彩色括号插件</td>
</tr>
<tr>
<td>RestfulToolkit</td>
<td>快速查询 RestFul API 插件</td>
</tr>
<tr>
<td>String Manipulation</td>
<td>字符串处理插件</td>
</tr>
<tr>
<td>CamelCase</td>
<td>驼峰转换工具</td>
</tr>
<tr>
<td>jclasslib Bytecode viewer</td>
<td>字节码查看插件</td>
</tr>
<tr>
<td>Auto filling Java call arguments</td>
<td>自动填充 Java 方法默认参数插件</td>
</tr>
<tr>
<td>Vue</td>
<td>Vue 支持插件</td>
</tr>
<tr>
<td>Git Commit Template</td>
<td>Git 提交模板插件</td>
</tr>
<tr>
<td>GitToolBox</td>
<td>Git 工具箱插件</td>
</tr>
<tr>
<td>Extra Icons</td>
<td>图标插件</td>
</tr>
<tr>
<td>Atom Material Icons</td>
<td>图标插件</td>
</tr>
<tr>
<td>Easy javadoc</td>
<td>一键生成 Java 注释插件</td>
</tr>
<tr>
<td>Grep Console</td>
<td>对控制台日志进行分组显示插件</td>
</tr>
<tr>
<td>CodeGlance2</td>
<td>仿 Sublime Mini Map 插件</td>
</tr>
<tr>
<td>MybatisX</td>
<td>MybatisPlus 插件</td>
</tr>
<tr>
<td>Key Promoter X</td>
<td>快捷键提示插件</td>
</tr>
<tr>
<td>MapStruct Support</td>
<td>MapStruct 支持插件</td>
</tr>
<tr>
<td>GenerateAllSetter</td>
<td>一键生成对象的所有 Setter 方法插件</td>
</tr>
<tr>
<td>GenerateSerialVersionId</td>
<td>一键生成 SerialVersionId 插件</td>
</tr>
<tr>
<td>CharAutoReplace</td>
<td>自动切换中英文标点符号插件</td>
</tr>
<tr>
<td>Mybatis Smart Code Help</td>
<td>Mybatis Smart Code Help</td>
</tr>
<tr>
<td>show comment</td>
<td>显示备注</td>
</tr>
<tr>
<td>GitHub Copilot</td>
<td>Github 提示插件</td>
</tr>
</tbody></table>
<h3 id="修改全局配置"><a href="#修改全局配置" class="headerlink" title="修改全局配置"></a>修改全局配置</h3><p>其余 IntellJ 软件配置类似<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119105317905.png" alt="image-20211119105317905"></p>
<h4 id="配置-Maven-1"><a href="#配置-Maven-1" class="headerlink" title="配置 Maven"></a>配置 Maven</h4><p>仅限 Idea<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119105928640.png" alt="image-20211119105928640"></p>
<h4 id="修改文件字符集编码"><a href="#修改文件字符集编码" class="headerlink" title="修改文件字符集编码"></a>修改文件字符集编码</h4><p>其余 IntellJ 软件也可以修改该配置<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119110130041.png" alt="image-20211119110130041"></p>
<h4 id="修改-Tab-栏多行显示"><a href="#修改-Tab-栏多行显示" class="headerlink" title="修改 Tab 栏多行显示"></a>修改 Tab 栏多行显示</h4><p>其余 IntellJ 软件也可以修改该配置<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119110325236.png" alt="image-20211119110325236"></p>
<h3 id="修改最多打开的-Tab-数量"><a href="#修改最多打开的-Tab-数量" class="headerlink" title="修改最多打开的 Tab 数量"></a>修改最多打开的 Tab 数量</h3><p>其余 IntellJ 软件也可以修改该配置<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119110709107.png" alt="image-20211119110709107"></p>
<h3 id="打开鼠标放大字体和关闭鼠标拖拽"><a href="#打开鼠标放大字体和关闭鼠标拖拽" class="headerlink" title="打开鼠标放大字体和关闭鼠标拖拽"></a>打开鼠标放大字体和关闭鼠标拖拽</h3><p>其余 IntellJ 软件也可以修改该配置<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119111911055.png" alt="image-20211119111911055"></p>
<h3 id="修改默认文件头"><a href="#修改默认文件头" class="headerlink" title="修改默认文件头"></a>修改默认文件头</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119112351391.png" alt="image-20211119112351391"></p>
<h3 id="修改注释顶格"><a href="#修改注释顶格" class="headerlink" title="修改注释顶格"></a>修改注释顶格</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211130085556311.png" alt="image-20211130085556311"><br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211130090019220.png" alt="image-20211130090019220"></p>
<h3 id="忽略大小写配置"><a href="#忽略大小写配置" class="headerlink" title="忽略大小写配置"></a>忽略大小写配置</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211130095454588.png" alt="image-20211130095454588"></p>
<h3 id="自动引入-优化包"><a href="#自动引入-优化包" class="headerlink" title="自动引入&#x2F;优化包"></a>自动引入&#x2F;优化包</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211130100526376.png" alt="image-20211130100526376"></p>
<h3 id="调整快速选中单词的快捷键"><a href="#调整快速选中单词的快捷键" class="headerlink" title="调整快速选中单词的快捷键"></a>调整快速选中单词的快捷键</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211201112207303.png" alt="image-20211201112207303"></p>
<h2 id="PyCharm"><a href="#PyCharm" class="headerlink" title="PyCharm"></a>PyCharm</h2><h3 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h3><ol>
<li>mac 自带 python，python 在以下目录，current 代表当前使用的 python 版本 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/System/Library/Frameworks/Python.framework/Version</span><br></pre></td></tr></table></figure></li>
<li>通过 homebrew 搜索 python，打对钩的是已存在的包<br> <img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119140222225.png" alt="image-20211119140222225"></li>
<li>安装 Python <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 python3.9</span></span><br><span class="line">brew install python@3.9</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 python3.9 的信息</span></span><br><span class="line">brew info python@3.9</span><br></pre></td></tr></table></figure>
 <img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119140503967.png" alt="image-20211119140503967"></li>
</ol>
<h3 id="配置-Python-Interpreter"><a href="#配置-Python-Interpreter" class="headerlink" title="配置 Python Interpreter"></a>配置 Python Interpreter</h3><p>可配置多个 Python Interpreter 供不同的项目使用<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119134641175.png" alt="image-20211119134641175"></p>
<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><h3 id="打开扩展商店"><a href="#打开扩展商店" class="headerlink" title="打开扩展商店"></a>打开扩展商店</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119141006557.png" alt="image-20211119141006557"></p>
<h3 id="配置汉化"><a href="#配置汉化" class="headerlink" title="配置汉化"></a>配置汉化</h3><p>install 以后需要重新启动 vscode<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119141217655.png" alt="image-20211119141217655"></p>
<h3 id="配置-Idea-快捷键映射"><a href="#配置-Idea-快捷键映射" class="headerlink" title="配置 Idea 快捷键映射"></a>配置 Idea 快捷键映射</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119141641664.png" alt="image-20211119141641664"></p>
<h3 id="其余插件"><a href="#其余插件" class="headerlink" title="其余插件"></a>其余插件</h3><table>
<thead>
<tr>
<th>插件名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Code Runner</td>
<td>代码允许插件</td>
</tr>
<tr>
<td>Better Comments</td>
<td>帮助书写更人性化的注释插件</td>
</tr>
<tr>
<td>Auto Rename Tag</td>
<td>同步更改标签名称插件</td>
</tr>
<tr>
<td>Code Spell Checker</td>
<td>代码拼写检查插件</td>
</tr>
<tr>
<td>Color Picker</td>
<td>css 颜色选择器插件</td>
</tr>
<tr>
<td>colorize</td>
<td>使颜色在 css 中可视化插件</td>
</tr>
<tr>
<td>CSS Peek</td>
<td>css 跳转插件</td>
</tr>
<tr>
<td>Debugger For Java</td>
<td>Java Debugger 插件</td>
</tr>
<tr>
<td>Extension Pack for Java</td>
<td>Java 扩展包插件</td>
</tr>
<tr>
<td>Git History</td>
<td>查看 Git 日志插件</td>
</tr>
<tr>
<td>gitignore</td>
<td>gitignore 插件</td>
</tr>
<tr>
<td>Image preview</td>
<td>Image 预览插件</td>
</tr>
<tr>
<td>indent-rainbow</td>
<td>使缩进更易读插件</td>
</tr>
<tr>
<td>JavaScript(ES6) code snippets</td>
<td>JS ES6 支持插件</td>
</tr>
<tr>
<td>Lombok Annotations Support for VS Code</td>
<td>Lombok 支持插件</td>
</tr>
<tr>
<td>Path Intellisense</td>
<td>文件路径自动补全插件</td>
</tr>
<tr>
<td>Prettier</td>
<td>代码格式化插件</td>
</tr>
<tr>
<td>Python</td>
<td>Python 支持插件</td>
</tr>
<tr>
<td>Rainbow Brackets</td>
<td>彩色括号插件</td>
</tr>
<tr>
<td>Spring Boot Tools</td>
<td>Spring Boot 工具支持插件</td>
</tr>
<tr>
<td>Todo Tree</td>
<td>显示全部 Todo 插件</td>
</tr>
<tr>
<td>View In Browser</td>
<td>在浏览器中打开 HTML 插件</td>
</tr>
<tr>
<td>Vscode Google Translate</td>
<td>vscode 谷歌翻译插件</td>
</tr>
<tr>
<td>Vetur</td>
<td>vue 支持插件</td>
</tr>
<tr>
<td>GitLens</td>
<td>Git 增强插件</td>
</tr>
<tr>
<td>Git graph</td>
<td>Git 图表插件</td>
</tr>
<tr>
<td>Git Extension Pack</td>
<td>Git 增强插件</td>
</tr>
<tr>
<td>Npm Intellisense</td>
<td>NPM 自动完成插件</td>
</tr>
<tr>
<td>NPM</td>
<td>NPM 支持插件</td>
</tr>
</tbody></table>
<h3 id="设置文件自动保存"><a href="#设置文件自动保存" class="headerlink" title="设置文件自动保存"></a>设置文件自动保存</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119165833927.png" alt="image-20211119165833927"></p>
<h3 id="配置-Java"><a href="#配置-Java" class="headerlink" title="配置 Java"></a>配置 Java</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119171303474.png" alt="image-20211119171303474"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;editor.suggestSelection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;first&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;vsintellicode.modify.editor.suggestSelection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;automaticallyOverrodeDefaultValue&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;files.autoSave&quot;</span><span class="punctuation">:</span> <span class="string">&quot;afterDelay&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;java.home&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home&quot;</span><span class="punctuation">,</span> <span class="comment">//JAVA_HOME</span></span><br><span class="line"><span class="comment">// 指定 maven 的配置文件位置</span></span><br><span class="line"><span class="attr">&quot;java.configuration.maven.userSettings&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/opt/apache-maven-3.8.3/conf/settings.xml&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// maven 环境变量，指定为 mvn</span></span><br><span class="line"><span class="attr">&quot;maven.executable.path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;mvn&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="comment">// 自动更新影响的pom</span></span><br><span class="line"><span class="attr">&quot;maven.pomfile.autoUpdateEffectivePOM&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> </span><br><span class="line"><span class="comment">// 跳过测试, 不需要跳过可删除</span></span><br><span class="line"><span class="attr">&quot;maven.executable.options&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-DskipTests&quot;</span><span class="punctuation">,</span> </span><br><span class="line"><span class="comment">// 当此值设为 true 时，且配置了 java.home 时，</span></span><br><span class="line"><span class="comment">// 新建终端会自动添加环境 JDK 环境变量 为 java.home 的值</span></span><br><span class="line"><span class="attr">&quot;maven.terminal.useJavaHome&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 指定 maven 所用 jdk </span></span><br><span class="line"><span class="attr">&quot;maven.terminal.customEnv&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;environmentVariable&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JAVA_HOME&quot;</span><span class="punctuation">,</span> <span class="comment">//环境变量名</span></span><br><span class="line"><span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home&quot;</span><span class="punctuation">,</span> <span class="comment">//JDK 安装 路径</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">//在构建时，自动修改 java 项目的配置信息 ,classpath 信息</span></span><br><span class="line"><span class="attr">&quot;java.configuration.updateBuildConfiguration&quot;</span><span class="punctuation">:</span> <span class="string">&quot;automatic&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;java.configuration.runtimes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JavaSE-11&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Library/Java/JavaVirtualMachines/zulu-11.jdk/Contents/Home&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JavaSE-1.8&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;java.jdt.ls.vmargs&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-noverify -Xmx1G -XX:+UseG1GC -XX:+UseStringDeduplication -javaagent:\&quot;/Users/dongx/.vscode/extensions/gabrielbb.vscode-lombok-1.0.1/server/lombok.jar\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;files.exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;**/.classpath&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;**/.project&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;**/.settings&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;**/.factorypath&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;java.semanticHighlighting.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;redhat.telemetry.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;workbench.editor.enablePreview&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span> <span class="comment">//关闭预览模式（单击覆盖 Tab）</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="打开多-Tab-显示"><a href="#打开多-Tab-显示" class="headerlink" title="打开多 Tab 显示"></a>打开多 Tab 显示</h3><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211206110731250.png" alt="image-20211206110731250"></p>
<h3 id="打开设置同步"><a href="#打开设置同步" class="headerlink" title="打开设置同步"></a>打开设置同步</h3><p>按照提示操作<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211119165930365.png" alt="image-20211119165930365"></p>
<h2 id="Alfred-4"><a href="#Alfred-4" class="headerlink" title="Alfred 4"></a>Alfred 4</h2><p>参考：<a href="https://juejin.cn/post/6844904062484217863">https://juejin.cn/post/6844904062484217863</a><br>如果出现无法使用剪贴板功能，需要重新开启<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211122140956693.png" alt="image-20211122140956693"></p>
<h2 id="Karabiner"><a href="#Karabiner" class="headerlink" title="Karabiner"></a>Karabiner</h2><p>增加自定义按键映射（目前会导致锁屏界面点击 ESC 键，黑屏后立马闪亮的情况）</p>
<ol>
<li>在该目录 <code> ~/.config/karabiner/assets/complex_modifications</code> 下增加 json 配置文件<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Change key Map like poker.&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;rules&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Change Control + WASD to Arrow up,left,down,right&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;manipulators&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;w&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;mandatory&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;right_control&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;any&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;up_arrow&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;a&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;mandatory&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;right_control&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;any&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;left_arrow&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;s&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;mandatory&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;right_control&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;any&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;down_arrow&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;basic&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;from&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;d&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;modifiers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;mandatory&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;right_control&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;optional&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;any&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;to&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;key_code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;right_arrow&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li>添加 Profile，方便切换配置<br> <img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211206151028231.png" alt="image-20211206151028231"></li>
<li>增加映射文件<br> <img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211206151214349.png" alt="image-20211206151214349"></li>
</ol>
<h3 id="卸载-1"><a href="#卸载-1" class="headerlink" title="卸载"></a>卸载</h3><ul>
<li>终端执行 <code>sudo &#39;/Library/Application Support/org.pqrs/Karabiner-Elements/uninstall.sh&#39;</code></li>
<li>在 Preferences 中 选择 Misc 选项卡，再选择 Unistall Karakbienr Elements 进行卸载</li>
</ul>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认安装后无密码</span></span><br><span class="line">brew install mysql</span><br></pre></td></tr></table></figure>
<h3 id="启、停"><a href="#启、停" class="headerlink" title="启、停"></a>启、停</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启</span></span><br><span class="line">brew services start mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停</span></span><br><span class="line">brew services stop mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">brew services restart mysql</span><br></pre></td></tr></table></figure>
<h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql_secure_installation</span><br></pre></td></tr></table></figure>
<h3 id="查看当前的-data-目录"><a href="#查看当前的-data-目录" class="headerlink" title="查看当前的 data 目录"></a>查看当前的 data 目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p variables | grep datadir</span><br></pre></td></tr></table></figure>
<h2 id="ScrollReverser"><a href="#ScrollReverser" class="headerlink" title="ScrollReverser"></a>ScrollReverser</h2><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20211217110243713.png" alt="image-20211217110243713"></p>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;builder&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;gc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;defaultKeepStorage&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20GB&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;features&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;buildkit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;https://d87rvvlc.mirror.aliyuncs.com&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="string">&quot;http://hub-mirror.c.163.com&quot;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20220119090508249.png" alt="image-20220119090508249"><br>出现 <code>Error response from daemon: Get https://registry-1.docker.io/</code> 时</p>
<ol>
<li>通过 <code>dig @114.114.114.114 registry-1.docker.io </code>找到可用IP地址<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20220119092415084.png" alt="image-20220119092415084"></li>
<li>修改 <code>/etc/hosts</code>强制 docker.io 相关的域名解析到其它可用 IP<br><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/image-20220119092513941.png" alt="image-20220119092513941"></li>
<li>重新 pull 镜像</li>
</ol>
<h2 id="picgo"><a href="#picgo" class="headerlink" title="picgo"></a>picgo</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;current&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;github&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;smms&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;github&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/MiracleDx/images_repo&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;main&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;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&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;shortKey&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;picgo:upload&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;enable&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CommandOrControl+Shift+P&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;upload&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;QUICK_UPLOAD&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;showUpdateTip&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;needReload&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;picgo-plugin-auto-delete&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="三、修改启动台图标大小"><a href="#三、修改启动台图标大小" class="headerlink" title="三、修改启动台图标大小"></a>三、修改启动台图标大小</h1><p>调整排列方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-columns -int 10</span><br><span class="line">defaults write com.apple.dock springboard-rows -int 8</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
<p>恢复默认的排列方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">defaults write com.apple.dock springboard-rows Default</span><br><span class="line">defaults write com.apple.dock springboard-columns Default</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure>
<p>Dock 显示隐藏缓慢的原因，是因为 OS X 隐藏和显示 Dock 的动画持续时间被设置成了 1 秒，想要改变这一时间，只需要打开终端，选择以下代码的其中一项执行就可以实现：</p>
<ul>
<li><code>defaults write com.apple.dock autohide-delay -int 0</code>（时间设为最短）</li>
<li><code>defaults write com.apple.dock autohide-delay -int 0.5</code>（时间设为 0.5s）<br>以上两个选项是比较推荐的设置，执行完上述命令后，你还需要再执行 <code>killall Dock</code> 这条命令才算完（注意大小写）。设置好之后，快看看效果吧。</li>
</ul>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos</title>
    <url>/MiracleDx/2020/06/28/Nacos/</url>
    <content><![CDATA[<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><h2 id="Config"><a href="#Config" class="headerlink" title="Config"></a>Config</h2><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>与配置中心相关的配置应放在 bootstrap.properties 或 bootstrap.yml 中</p>
<blockquote>
<p>放在 application.properties 或者 application.yml 配置会失效</p>
</blockquote>
<h3 id="动态刷新"><a href="#动态刷新" class="headerlink" title="动态刷新"></a>动态刷新</h3><ul>
<li>A：通过内部规则拼接出来的配置 <code>Config dataId = $&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</code> prefix默认为 spring.application.name</li>
<li>B：通过 <code>spring.cloud.nacos.config.extension-configs</code> 定义的配置</li>
<li>C：通过 <code>spring.cloud.nacos.config.shared-configss </code> 定义的共享配置</li>
</ul>
<blockquote>
<p>配置文件加载存在优先级问题：A &gt; B &gt; C</p>
<ul>
<li>会优先读取主配置文件（默认的 DataId）默认的 DataId 配置，越符合的优先级越高</li>
<li>当主配置文件不存在该属性时，才会读取 extendsion-config[n] 配置的信息（n 的值越大，优先级越高）</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ Docker 镜像制作</title>
    <url>/MiracleDx/2022/03/24/RocketMQ%20Docker%20%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="预准备"><a href="#预准备" class="headerlink" title="预准备"></a>预准备</h1><h2 id="替换-runbroker-sh-中-JAVA-OPT-参数"><a href="#替换-runbroker-sh-中-JAVA-OPT-参数" class="headerlink" title="替换 runbroker.sh 中 JAVA_OPT 参数"></a>替换 runbroker.sh 中 JAVA_OPT 参数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将以下参数替换为</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g&quot;</span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原因：个人电脑多集群下无法支撑多个节点 8g 内存且open jdk 不支持 G1</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512m -Xmx512m -Xmn256m&quot;</span><br></pre></td></tr></table></figure>
<h2 id="查看-linux-版本"><a href="#查看-linux-版本" class="headerlink" title="查看 linux 版本"></a>查看 linux 版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 centos 版本</span></span><br><span class="line">cat /etc/redhat-release </span><br></pre></td></tr></table></figure>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>以下 centos 及 jdk 均基于 arm 架构，x86 需替换相应资源</li>
<li>volume 中，除启动的配置文件外，还需要放置以下文件<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">logback_broker.xml</span><br><span class="line">logback_namesrv.xml</span><br><span class="line">logback_tools.xml</span><br><span class="line">plain_acl.yml</span><br><span class="line">tools.yml</span><br></pre></td></tr></table></figure></li>
<li>Broker 启动文件需要配置 brokerIP1，指定连接 IP</li>
</ol>
<h1 id="1-Dockerfile-basic"><a href="#1-Dockerfile-basic" class="headerlink" title="1. Dockerfile-basic"></a>1. Dockerfile-basic</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建 centos java8 环境</span></span><br><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> MAINTAINER Dongx dongxiang@sinosoft.com.cn</span></span><br><span class="line"><span class="comment"># 设置 Java 环境变量</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u301-linux-aarch64.tar.gz /opt/java/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/java</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=/opt/java/jdk1.<span class="number">8.0</span>_301</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="comment"># 设置 RocketMQ 环境</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> rocketmq-4.9.2.tar.gz /opt/rocketmq/</span></span><br></pre></td></tr></table></figure>
<h1 id="2-Dockerfile-NameSrv"><a href="#2-Dockerfile-NameSrv" class="headerlink" title="2. Dockerfile-NameSrv"></a>2. Dockerfile-NameSrv</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> rocketmq-basic:v1</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> MAINTAINER Dongx dongxiang@sinosoft.com.cn</span></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/rocketmq/rocketmq-4.9.2/bin</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">9876</span></span><br><span class="line"><span class="comment"># 启动 namesrc</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./mqnamesrv -n <span class="variable">$&#123;NAMESRV_ADDR&#125;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="3-Dockerfile-Broker"><a href="#3-Dockerfile-Broker" class="headerlink" title="3.Dockerfile-Broker"></a>3.Dockerfile-Broker</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> rocketmq-basic:v1</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> MAINTAINER Dongx dongxiang@sinosoft.com.cn</span></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/rocketmq/rocketmq-4.9.2/bin</span></span><br><span class="line"><span class="comment"># ROCKETMQ_HOME</span></span><br><span class="line"><span class="keyword">ENV</span> ROCKETMQ_HOME=/opt/rocketmq/rocketmq-<span class="number">4.9</span>.<span class="number">2</span></span><br><span class="line"><span class="comment"># NameServer 地址</span></span><br><span class="line"><span class="keyword">ENV</span> NAMESRV_ADDR=localhost:<span class="number">9876</span></span><br><span class="line"><span class="comment"># conf 地址</span></span><br><span class="line"><span class="keyword">ENV</span> CONF_PATH=broker.conf</span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10909</span> <span class="number">10911</span> <span class="number">10912</span></span><br><span class="line"><span class="comment">#启动 Broker</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> ./mqbroker -n <span class="variable">$&#123;NAMESRV_ADDR&#125;</span> -c <span class="variable">$&#123;ROCKETMQ_HOME&#125;</span>/conf/<span class="variable">$&#123;CONF_PATH&#125;</span> autoCreateTopicEnable=<span class="literal">true</span></span></span><br></pre></td></tr></table></figure>
<h1 id="4-构建镜像"><a href="#4-构建镜像" class="headerlink" title="4. 构建镜像"></a>4. 构建镜像</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基础镜像</span></span><br><span class="line">docker build -f Dockerfile-Basic -t rocketmq-basic:v1 .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">NameServer 镜像</span></span><br><span class="line">docker build -f Dockerfile-NameSrv -t rocketmq-namesrv:v1 .</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Broker 镜像</span></span><br><span class="line">docker build -f Dockerfile-Broker -t rocketmq-broker:v1 .</span><br></pre></td></tr></table></figure>
<h1 id="5-启动"><a href="#5-启动" class="headerlink" title="5. 启动"></a>5. 启动</h1><h2 id="5-1-NameServer"><a href="#5-1-NameServer" class="headerlink" title="5.1 NameServer"></a>5.1 NameServer</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">docker run -d -e NAMESRV_ADDR=192.168.8.102:9876 -v /Users/dongx/developer/docker_repo/rocketmq/logs/namesrv:/root/logs/rocketmqlogs -p 9876:9876 --name rocketmq-namesrv rocketmq-namesrv:v1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器验证</span></span><br><span class="line">docker exec -it $&#123;containerId&#125; bash</span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure>
<h2 id="5-2-Broker"><a href="#5-2-Broker" class="headerlink" title="5.2 Broker"></a>5.2 Broker</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动</span></span><br><span class="line">docker run -d -e NAMESRV_ADDR=192.168.8.102:9876 -e CONF_PATH=customer/broker.conf -v /Users/dongx/developer/docker_repo/rocketmq/logs/broker:/root/logs/rocketmqlogs -v /Users/dongx/developer/docker_repo/rocketmq/conf:/opt/rocketmq/rocketmq-4.9.2/conf/customer -p 10909:10909 -p 10911:10911 -p 10912:10912 --name rocketmq-broker rocketmq-broker:v1</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入容器验证</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br></pre></td></tr></table></figure>
<h1 id="6-RocketMQ-Dashboard"><a href="#6-RocketMQ-Dashboard" class="headerlink" title="6. RocketMQ-Dashboard"></a>6. RocketMQ-Dashboard</h1><h2 id="6-1-Dockerfile"><a href="#6-1-Dockerfile" class="headerlink" title="6.1 Dockerfile"></a>6.1 Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> MAINTAINER Dongx dongxiang@sinosoft.com.cn</span></span><br><span class="line"><span class="comment"># 设置 Java 环境变量</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> jdk-8u301-linux-aarch64.tar.gz /opt/java/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/java</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME=/opt/java/jdk1.<span class="number">8.0</span>_301</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">ENV</span> PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt/rocketmq/</span></span><br><span class="line"><span class="comment"># 设置 Dashboard 环境</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> rocketmq-dashboard-*.jar rocketmq-dashboard.jar</span></span><br><span class="line"><span class="comment"># jvm 参数</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_OPTS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 暴露端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [ <span class="string">&quot;sh&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;java <span class="variable">$JAVA_OPTS</span> -jar rocketmq-dashboard.jar&quot;</span> ]</span></span><br></pre></td></tr></table></figure>
<h2 id="6-2-构建"><a href="#6-2-构建" class="headerlink" title="6.2 构建"></a>6.2 构建</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -f Dockerfile-Dashboard -t rocketmq-dashboard:v1 .</span><br></pre></td></tr></table></figure>
<h2 id="6-3-启动"><a href="#6-3-启动" class="headerlink" title="6.3 启动"></a>6.3 启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -e JAVA_OPTS=&quot;-Dlogging.level.root=info -Drocketmq.namesrv.addr=192.168.8.102:9876&quot; -p 8080:8080 --name rocketmq-dashboard rocketmq-dashboard:v1</span><br></pre></td></tr></table></figure>
<h1 id="7-Docker-Compose"><a href="#7-Docker-Compose" class="headerlink" title="7. Docker-Compose"></a>7. Docker-Compose</h1><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="attr">namesrv:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">rocketmq-namesrv:v1</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">rocketmq-namesrv-compose</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;9876:9876&quot;</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">NAMESRV_ADDR=192.168.8.102:9876</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/Users/dongx/developer/docker_repo/rocketmq/logs/namesrv:/root/logs/rocketmqlogs</span></span><br><span class="line"><span class="attr">broker:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">rocketmq-broker:v1</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">rocketmq-broker-compose</span></span><br><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;10909:10909&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;10911:10911&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">&quot;10912:10912&quot;</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">NAMESRV_ADDR=192.168.8.102:9876</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">CONF_PATH=customer/broker.conf</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">/Users/dongx/developer/docker_repo/rocketmq/logs/broker:/root/logs/rocketmqlogs</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">/Users/dongx/developer/docker_repo/rocketmq/conf:/opt/rocketmq/rocketmq-4.9.2/conf/customer</span></span><br><span class="line"><span class="attr">dashboard:</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">rocketmq-dashboard:v1</span></span><br><span class="line"><span class="attr">container_name:</span> <span class="string">rocketmq-dashbaord</span></span><br><span class="line"><span class="attr">depends_on:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">namesrv</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">JAVA_OPTS=-Dlogging.level.root=info</span> <span class="string">-Drocketmq.namesrv.addr=namesrv:9876</span></span><br></pre></td></tr></table></figure>
<h2 id="6-1-启动"><a href="#6-1-启动" class="headerlink" title="6.1 启动"></a>6.1 启动</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RockerMQ 容器</tag>
      </tags>
  </entry>
  <entry>
    <title>常用指令</title>
    <url>/MiracleDx/2024/03/12/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h1><h2 id="删代码注释的正则"><a href="#删代码注释的正则" class="headerlink" title="删代码注释的正则"></a>删代码注释的正则</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+/|[ \t]*<span class="comment">//.*)</span></span><br></pre></td></tr></table></figure>

<h2 id="匹配中文的正则"><a href="#匹配中文的正则" class="headerlink" title="匹配中文的正则"></a>匹配中文的正则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 匹配单字节</span><br><span class="line">[\u4e00-\u9fa5]</span><br><span class="line"># 匹配双字节</span><br><span class="line">[^\x00-\xff]</span><br></pre></td></tr></table></figure>

<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="查看是否为-Linux-OOM-Killer-杀掉的进程"><a href="#查看是否为-Linux-OOM-Killer-杀掉的进程" class="headerlink" title="查看是否为 Linux OOM Killer 杀掉的进程"></a>查看是否为 Linux OOM Killer 杀掉的进程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo egrep -i -r &#x27;Out Of&#x27; /var/log</span><br></pre></td></tr></table></figure>

<h2 id="查看进程直接杀掉"><a href="#查看进程直接杀掉" class="headerlink" title="查看进程直接杀掉"></a>查看进程直接杀掉</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep filebeat-sfzt-s.yml | awk -F &quot;[ ]+&quot; &#x27;NR==1&#123;print $2&#125;&#x27; | xargs kill -9</span><br></pre></td></tr></table></figure>

<h2 id="文件大小排序"><a href="#文件大小排序" class="headerlink" title="文件大小排序"></a>文件大小排序</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">du -hsx * | sort -rh | head -6</span><br><span class="line">du – 估计文件的空间使用情况</span><br><span class="line">-hsx – （-h）更易读的格式，（-s）汇总输出，（-x）跳过其他文件系统的文件</span><br><span class="line">sort – 对文本文件按行排序</span><br><span class="line">-rf – （-r）将比较的结果逆序输出，（-f）忽略大小写</span><br><span class="line">head – 输出文件的头几行</span><br></pre></td></tr></table></figure>

<h2 id="查看每个文件的行数"><a href="#查看每个文件的行数" class="headerlink" title="查看每个文件的行数"></a>查看每个文件的行数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ -type f -name cilogPlatform*.log|awk &#x27;&#123;print &quot;echo \&quot;&quot;$1&quot;\&quot;;cat &quot;$1&quot;|wc -l&quot;&#125;&#x27;|sh &gt; cilogPlatform_info.txt</span><br></pre></td></tr></table></figure>

<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Rebase-历史丢失"><a href="#Rebase-历史丢失" class="headerlink" title="Rebase 历史丢失"></a>Rebase 历史丢失</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找变更记录</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到rebase前的<span class="built_in">hash</span> 创建一个备份分支</span></span><br><span class="line">git checkout -b branch-bak d1ccec7</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一顿操作。能不能恢复看自己发挥了</span></span><br></pre></td></tr></table></figure>

<h2 id="查看每个人提交的行数"><a href="#查看每个人提交的行数" class="headerlink" title="查看每个人提交的行数"></a>查看每个人提交的行数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --format=&#x27;%aN&#x27; | sort -u | while read name; do echo -en &quot;$name\t&quot;; git log --author=&quot;$name&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27; -; done</span><br></pre></td></tr></table></figure>

<h2 id="统计代码总行数"><a href="#统计代码总行数" class="headerlink" title="统计代码总行数"></a>统计代码总行数</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git ls-files | xargs cat | wc -l</span><br></pre></td></tr></table></figure>

<h1 id="K8s"><a href="#K8s" class="headerlink" title="K8s"></a>K8s</h1><h2 id="查询所有运行时的容器"><a href="#查询所有运行时的容器" class="headerlink" title="查询所有运行时的容器"></a>查询所有运行时的容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure>

<h2 id="查看所有-pods-的命名空间"><a href="#查看所有-pods-的命名空间" class="headerlink" title="查看所有 pods 的命名空间"></a>查看所有 pods 的命名空间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure>

<h2 id="创建命名空间"><a href="#创建命名空间" class="headerlink" title="创建命名空间"></a>创建命名空间</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl create namespace xxx</span><br></pre></td></tr></table></figure>

<h2 id="实时查看-Deployment-对象的状态变化"><a href="#实时查看-Deployment-对象的状态变化" class="headerlink" title="实时查看 Deployment 对象的状态变化"></a>实时查看 Deployment 对象的状态变化</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl rollout status</span><br></pre></td></tr></table></figure>

<h2 id="回滚-Deployment"><a href="#回滚-Deployment" class="headerlink" title="回滚 Deployment"></a>回滚 Deployment</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回滚到上一次</span></span><br><span class="line">kubectl rollout undo deployment_name</span><br></pre></td></tr></table></figure>

<h2 id="查看每次-Deployment-变更对应版本"><a href="#查看每次-Deployment-变更对应版本" class="headerlink" title="查看每次 Deployment 变更对应版本"></a>查看每次 Deployment 变更对应版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看全部版本</span></span><br><span class="line">kubectl rollout history deployment_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看每个版本的细节</span></span><br><span class="line">kubectl rollout history deployment_name --revision=version_number</span><br></pre></td></tr></table></figure>

<h2 id="回滚-Deployment-到指定版本"><a href="#回滚-Deployment-到指定版本" class="headerlink" title="回滚 Deployment 到指定版本"></a>回滚 Deployment 到指定版本</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubuctl rollout undo deployment_nmame --to-revision=version_number</span><br></pre></td></tr></table></figure>

<h2 id="防止每次更新-Deployment，生成多个-ReplicaSet-对象"><a href="#防止每次更新-Deployment，生成多个-ReplicaSet-对象" class="headerlink" title="防止每次更新 Deployment，生成多个 ReplicaSet 对象"></a>防止每次更新 Deployment，生成多个 ReplicaSet 对象</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl rollout pause deployment_name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">update deployment</span></span><br><span class="line">kubectl rollout resume deployment_name</span><br></pre></td></tr></table></figure>

<h2 id="Dns-测试"><a href="#Dns-测试" class="headerlink" title="Dns 测试"></a>Dns 测试</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl run -i --tty --image busybox:1.28.4 dns-test --restart=Never --rm /bin/sh </span><br></pre></td></tr></table></figure>

<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="MySQL-增加-on-update-语句"><a href="#MySQL-增加-on-update-语句" class="headerlink" title="MySQL 增加 on update 语句"></a>MySQL 增加 on update 语句</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sys_summary CHANGE update_time update_time <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">on</span> <span class="keyword">update</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sys_summary CHANGE update_time update_time <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> comment <span class="string">&#x27;更新时间&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="去除回车和空行"><a href="#去除回车和空行" class="headerlink" title="去除回车和空行"></a>去除回车和空行</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> tableName <span class="keyword">SET</span> field <span class="operator">=</span> REPLACE(REPLACE(field, <span class="type">CHAR</span>(<span class="number">10</span>), <span class="string">&#x27;&#x27;</span>), <span class="type">CHAR</span>(<span class="number">13</span>), <span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="按照-1-1-1-2-版本号进行排序"><a href="#按照-1-1-1-2-版本号进行排序" class="headerlink" title="按照 1.1 1.2 版本号进行排序"></a>按照 1.1 1.2 版本号进行排序</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 当每一层值可以控制在0-9时，可直接使用如下方法  序号转成小数的形式即可实现排序</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">cast</span>(concat(<span class="keyword">left</span>(字段名,INSTR(字段名,<span class="string">&#x27;.&#x27;</span>)), replace(<span class="built_in">subString</span>(字段名,instr(字段名,<span class="string">&#x27;.&#x27;</span>)<span class="operator">+</span><span class="number">1</span>), <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;&#x27;</span>)) <span class="keyword">as</span> <span class="type">DECIMAL</span>(<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 当序号层数可以控制时，每一项值不可控时，可使用</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">order</span> <span class="keyword">by</span> SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(字段名, <span class="string">&#x27;.&#x27;</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">1</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">-1</span>)<span class="operator">+</span><span class="number">0</span>,SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(字段名, <span class="string">&#x27;.&#x27;</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">2</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">-1</span>)<span class="operator">+</span><span class="number">0</span>,SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(字段名, <span class="string">&#x27;.&#x27;</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">3</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">-1</span>)<span class="operator">+</span><span class="number">0</span>,SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(字段名, <span class="string">&#x27;.&#x27;</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">4</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">-1</span>)<span class="operator">+</span><span class="number">0</span>,SUBSTRING_INDEX(SUBSTRING_INDEX(CONCAT(字段名, <span class="string">&#x27;.&#x27;</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">5</span>), <span class="string">&#x27;.&#x27;</span>, <span class="number">-1</span>)<span class="operator">+</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="清除有外键的表数据"><a href="#清除有外键的表数据" class="headerlink" title="清除有外键的表数据"></a>清除有外键的表数据</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET FOREIGN_KEY_CHECKS = 0; </span><br><span class="line">TRUNCATE TABLE TABLE_NAME;</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br></pre></td></tr></table></figure>

<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven-下载源文件和-document"><a href="#Maven-下载源文件和-document" class="headerlink" title="Maven 下载源文件和 document"></a>Maven 下载源文件和 document</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn dependency:resolve -Dclassifier=sources</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>shell 正则</tag>
      </tags>
  </entry>
  <entry>
    <title>敏捷开发</title>
    <url>/MiracleDx/2023/03/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="瀑布模式"><a href="#瀑布模式" class="headerlink" title="瀑布模式"></a>瀑布模式</h1><p><strong>瀑布模式的定义</strong>：研发的整个工作流程都是按顺序进行的。为了应对变化，就增加了一系列流程，例如变更流程管理、文档审批等应对和限制变更<br>瀑布模式饱受诟病的三点：</p>
<ol>
<li>研发周期过长，研发跟不上业务发展的节奏</li>
<li>研发不能很好的响应需求，导致客户满意度低</li>
<li>不能很好的管控风险</li>
</ol>
<p><em>瀑布模式更适合确定性高的工作</em><br>VUCA 时代<br>    - 易变（volatility）<br>    - 不确定（uncertainty）<br>    - 复杂（complexity）<br>    - 模糊（ambiguity）</p>
<h1 id="敏捷模式"><a href="#敏捷模式" class="headerlink" title="敏捷模式"></a>敏捷模式</h1><p>敏捷 &#x3D; 价值观 + 原则 + 一系列符合价值观和原则的方法。</p>
<ol>
<li>单纯说敏捷是一种方法，肯定是片面的；</li>
<li>但只强调价值观和原则，而不重视方法也是不对的，因为那样敏捷就飘在空中，不能落地</li>
</ol>
<p>敏捷术语：</p>
<ul>
<li>史诗<ul>
<li>一个非常大的用户故事，可能需要数月才能完成</li>
<li>在适当的时候，可以被拆分为很多小的用户故事</li>
<li>理解史诗的两个关键点<ol>
<li>非常大</li>
<li>还没想清楚里面的细节</li>
</ol>
</li>
</ul>
</li>
<li>特性<ul>
<li>规模介于史诗和用户故事之间</li>
<li>是一组用户故事的集合，这些用户故事组成了一个完整的功能，通过特性将相关的用户故事连接起来</li>
<li>产品对外发布的时候，往往更关注特性的完成情况</li>
<li>理解特性的两个关键点<ol>
<li>比较大</li>
<li>已经想清楚里面的细节</li>
</ol>
</li>
</ul>
</li>
<li>故事<ul>
<li>核心在于从渴望新功能的人的角度对功能进行简短的描述</li>
<li>足够小，小到一个迭代周期内能够完成（0～3天）</li>
<li>关注的是交付给客户的最终价值</li>
<li>遵循模版：作为&lt;用户类型&gt;，我想要&lt;一些目标&gt;，以便&lt;一些原因&gt;</li>
</ul>
</li>
<li>任务<ul>
<li>通常是故事的具体拆分</li>
<li>完成用户需求的过程性的工作</li>
<li>表示用户故事开发任务的完成</li>
<li>关注于实现和交付由用户故事所体现出的客户价值的技术和底层细节</li>
</ul>
</li>
<li>缺陷<ul>
<li>主要针对测试中的缺陷或者已发布版本的缺陷</li>
</ul>
</li>
</ul>
<h2 id="理解敏捷"><a href="#理解敏捷" class="headerlink" title="理解敏捷"></a>理解敏捷</h2><h3 id="敏捷的价值观：正确理解敏捷的初心"><a href="#敏捷的价值观：正确理解敏捷的初心" class="headerlink" title="敏捷的价值观：正确理解敏捷的初心"></a>敏捷的价值观：正确理解敏捷的初心</h3><p><strong>5 条价值观：</strong></p>
<ol>
<li>个体和交互<strong>胜过</strong>过程和工具</li>
<li>可以工作的软件<strong>胜过</strong>面面俱到的文档<br>  <em>敏捷重视可工作的、有价值的软件，减少一切不必要的文档。不是所有文档</em></li>
<li>客户合作胜过合同谈判</li>
<li>响应变化<strong>胜过</strong>遵循计划</li>
<li>虽然右项有价值，但更重视左项<br>  <em>左面是敏捷更重视的，但不是停止做右面的内容</em><br>敏捷通过一系列方法来让研发工作更加灵活、有序和高效，所以它的价值观重视人的能动性，强调人与人之间的协作，也更重视对变化的应对，这些都是为了能够更好、更灵活地组织和管理研发工作</li>
</ol>
<h3 id="敏捷的原则：正确理解敏捷的基石"><a href="#敏捷的原则：正确理解敏捷的基石" class="headerlink" title="敏捷的原则：正确理解敏捷的基石"></a>敏捷的原则：正确理解敏捷的基石</h3><p><strong>12 条原则</strong></p>
<ol>
<li>我们最优先要做的是通过尽早的、持续的交付有价值的软件来使客户满意</li>
<li>即使到了开发的后期，也欢迎改变需求。敏捷过程利用变化来为客户创造竞争优势</li>
<li>经常性地交付可以工作的软件，交付的间隔可以从几个星期到几个月，交付的时间间隔越短越好</li>
<li>在整个项目开发期间，业务人员和开发人员必须天天都在一起工作</li>
<li>围绕被激励起来的个体来构建项目。给他们提供所需的环境和支持，并且信任他们能够完成工作</li>
<li>在团队内部，最具有效果并且富有效率的传递信息的方法，就是面对面的交谈</li>
<li>工作的软件是首要的进度度量标准</li>
<li>敏捷过程提倡可持续的开发速度。人、开发者和用户应该能够保持一个长期的、恒定的开发速度</li>
<li>不断地关注优秀的技能和好的设计会增强敏捷能力</li>
<li>简单——使未完成的工作最大化的艺术——是根本的</li>
<li>最好的构架、需求和设计出自于自组织的团队</li>
<li>每隔一定时间，团队会在如何才能更有效地工作方面进行反省，然后相应地对自己的行为进行调整<br><strong>敏捷中的“快”其实指的是反馈更快，反馈更及时</strong><br>如何才能保持“可持续的开发速度”？</li>
<li>在迭代开始的时候，不会过度承诺，也就是能完成多少工作，就承诺多少工作</li>
<li>严格遵守纪律。在迭代开始以后，原则上不会再增加需求，如果一定要往他们的迭代待办事项列表里增加其它需求，就要同时从中拿走等量的需求</li>
</ol>
<h3 id="敏捷的方法：正确落地敏捷的基础"><a href="#敏捷的方法：正确落地敏捷的基础" class="headerlink" title="敏捷的方法：正确落地敏捷的基础"></a>敏捷的方法：正确落地敏捷的基础</h3><p>一些敏捷方法：极限编程、Scrum、特征驱动开发、动态系统开发方法、自适应软件开发，以及水晶方法等<br>Scrum 在新软件开发中更好用，而看板在维护类的软件开发中更胜一筹<br>使用敏捷的不同方法前，自问 3 个问题：</p>
<ol>
<li>这个方法能解决什么样的问题？</li>
<li>有没有使用前提？</li>
<li>有没有相应的使用规则？</li>
</ol>
<h4 id="Scrum-框架的组成"><a href="#Scrum-框架的组成" class="headerlink" title="Scrum 框架的组成"></a>Scrum 框架的组成</h4><ul>
<li>3 个角色</li>
</ul>
<ol>
<li>产品负责人</li>
<li>团队</li>
<li>ScrumMaster</li>
</ol>
<ul>
<li>3 个工件</li>
</ul>
<ol>
<li>产品待办事项列表</li>
<li>迭代待办事项列表</li>
<li>产品增量</li>
</ol>
<ul>
<li>5 个会议</li>
</ul>
<ol>
<li>迭代计划会议</li>
<li>每日站会</li>
<li>迭代回顾会议</li>
<li>迭代评审会议</li>
<li>产品 Backlog 梳理会议</li>
</ol>
<ul>
<li>5 个价值<ol>
<li>承诺</li>
<li>专注</li>
<li>开放</li>
<li>尊重</li>
<li>勇气<br>Scrum 的约束条件（最重要的两条）：</li>
</ol>
</li>
</ul>
<ol>
<li>在迭代计划会议开始前，产品负责人需要准备好需求条目，使需求达到准入标准</li>
<li>Scrum 讲究时间盒，包括迭代的周期、各个会议，这些都要遵守时间盒的约定</li>
</ol>
<h2 id="推进敏捷"><a href="#推进敏捷" class="headerlink" title="推进敏捷"></a>推进敏捷</h2><p>敏捷推进的三个阶段</p>
<ol>
<li>做敏捷（doing agile）</li>
<li>思考敏捷（thinking agile）</li>
<li>思想敏捷（being agile）<br>从全局考虑推进：</li>
<li>在前期，要做好诊断和规划，在解决痛点的基础上导入适合的敏捷方法</li>
<li>推进过程可以分步进行，但要及时排查每一步中可能出现的新的障碍</li>
<li>要加强协作，打通研发管理的全链条，必要时要成立高层参与的督导团队，请高层领导帮忙推动</li>
<li>在整个实践过程中，都需要有能力的敏捷教练陪伴，并培养出适合团队的 Scrum Master</li>
</ol>
<h3 id="评估诊断"><a href="#评估诊断" class="headerlink" title="评估诊断"></a>评估诊断</h3><p>目的是在转型之前，让企业或者团队了解自己的现状、存在的问题和痛点<br>评估诊断的方法步骤：</p>
<ol>
<li>挑选代表性项目</li>
<li>访谈评估<br>  对项目团队成员进行访谈，从流程、组织、人员技能、度量和技术等维度，对项目进行深度评估</li>
<li>制定转型计划<br>  根据访谈评估中发现的具体问题和痛点，有针对性地做推进敏捷的计划，形成后面转型工作的蓝图</li>
<li>沟通<br>  实践前与相关干系人员，沟通评估结果和相应计划，以便整个团队达成一致意见</li>
</ol>
<h3 id="团队敏捷试点"><a href="#团队敏捷试点" class="headerlink" title="团队敏捷试点"></a>团队敏捷试点</h3><h4 id="试点前准备（迭代-0）"><a href="#试点前准备（迭代-0）" class="headerlink" title="试点前准备（迭代 0）"></a>试点前准备（迭代 0）</h4><p>调整好结构、组织好人员、划定好需求、搭建好架构、选择好方法和工具、布置好办公环境</p>
<ol>
<li>如何做好试点前的准备</li>
<li>选择试点团队</li>
<li>采纳敏捷的意愿相对强烈</li>
<li>业务价值高或采纳敏捷会在短期内给团队带来很大收益</li>
<li>前期准备工作细则</li>
</ol>
<ul>
<li>组织和人员<ul>
<li>人员：直接关乎了敏捷试点乃至整个敏捷推进工作能否成功</li>
<li>组织：高内聚，低耦合</li>
<li>高内聚指的是日常工作中，全功能小团队内、小团队内部成员之间的沟通合作更紧密</li>
<li>低耦合则指的是，团队之间的沟通协作要远比团队内部的少</li>
</ul>
</li>
<li>管控治理规则<br>架构和设计的治理规则，质量管理策略规则等</li>
<li>需求范围<ul>
<li>项目的高阶需求范围、高阶发布计划</li>
<li>高阶的史诗级故事</li>
<li>近期 2 个迭代要开发的用户故事，要有优先级排序</li>
</ul>
</li>
<li>架构<br>根据初始需求做架构建模</li>
<li>敏捷方法和工具<br>工作过程管理工具，主要指研发作业流程管理工具，比如 Jira 和 Trello 等，Jenkins 做持续集成，SonaQube 做代码扫描</li>
<li>办公环境设施<br>开放工位、物理看板</li>
</ul>
<h4 id="推进敏捷试点"><a href="#推进敏捷试点" class="headerlink" title="推进敏捷试点"></a>推进敏捷试点</h4><p>核心关键点：打造一支活力与战斗力并存的敏捷团队<br><strong>一起制定“社会契约（Social Contract）”</strong>，保证团队工作的有序和高效<br>指的就是团队里的行为公约，就是为了让团队中每个成员都能加强协作、发挥价值，一起来约定的一些基本准则<br><strong>回顾会议，引导团队的自主性</strong>，导团队成员自发思考，激发大家的自主性，使工作变得更顺畅<br>如何开展回顾会议：会议开始后，说明会议的目的，讨论三个条目</p>
<ol>
<li>团队工作中做得好的地方是什么</li>
<li>做得不好的地方又是什么</li>
<li>除此之外，有没有什么其它疑问<br>一起头脑风暴决定怎么去改善，并做一些行动计划<br><strong>成绩墙与错题集，记录团队敏捷的成长</strong>，记录团队的成长，总结敏捷实践中的经验<br>在推进敏捷的过程中记录自己的心情曲线，以及取得的成绩和犯下的错误，也记录着团队的成长</li>
</ol>
<h3 id="大规模推广"><a href="#大规模推广" class="headerlink" title="大规模推广"></a>大规模推广</h3><p>规模化推广≠直接复制试点经验<br>规模化推广的正确方法</p>
<ol>
<li>SaFe （Scaled Agile Framework）</li>
<li>LeSS（Large Scale Scrum）<br>从企业或团队的痛点切入：</li>
</ol>
<ul>
<li>选择合适的规模化推广策略</li>
<li>做好敏捷文化铺垫，培养好敏捷的中坚力量</li>
<li>搭建适合敏捷的工作环境，做好必要的工具和自动化准备</li>
<li>组织级别的敏捷度量以及持续改进</li>
<li>重视大型团队的敏捷导入与推广<br>只有业务敏捷，才能短时间内快速交付业务价值<br>大型团队敏捷的导入和推广，首先要打造端到端的、从需求到开发到测试到运维到运营的敏捷全生命周期，向业务敏捷靠拢</li>
</ul>
<h2 id="什么是真正的敏捷"><a href="#什么是真正的敏捷" class="headerlink" title="什么是真正的敏捷"></a>什么是真正的敏捷</h2><p>**真正的敏捷：</p>
<ol>
<li><strong>团队尽可能有效拆分需求，先完成最有价值、优先级最高的需求。进入到迭代的需求是多个独立的小需求。每个小需求都可以在很短的时间内完成，比如 2 ～ 3 天内，完成开发和测试，最多不超出一个迭代周期（两周）。开发人员写代码的时候，测试人员在同步写测试案例。在测试的同时，开发人员在开发下一个需求，形成良好循环</strong></li>
<li>做需求拆分的目的，都是把大需求拆成一个个能够独立开发测试的小需求</li>
<li><strong>团队只是套用敏捷流程，或是没有做好需求拆分，敏捷很容易变成“小瀑布”</strong></li>
<li><strong>敏捷工作的结束点不应该是把之前所有计划的工作做完，而是把客户需要的工作做完</strong></li>
<li>如何<strong>拆分用户故事</strong>是敏捷开发一个很关键的部分，而评估是否是一个好的用户故事标准就是<strong>能否独立进行上线</strong>，如果做不到独立上线，那这个还不叫用户故事，测试也没办法并行进行，也不是真正的敏捷开发</li>
<li>敏捷开发跟现在的微服务架构是相辅相成，敏捷开发非常适合微服务这种开发模式，微服务能够提高敏捷开发的效率</li>
<li><strong>敏捷开发的精髓是团队至上，小步快跑，快速迭代，拥抱变化</strong></li>
</ol>
<h2 id="内部敏捷教练为什么重要"><a href="#内部敏捷教练为什么重要" class="headerlink" title="内部敏捷教练为什么重要"></a>内部敏捷教练为什么重要</h2><p>敏捷教练：帮助组织或团队推进敏捷实践的人，需要具备4项能力。可归纳为<strong>懂敏捷、能“教练”</strong></p>
<ol>
<li>教授（Teaching）</li>
<li>引导（Facilitation）</li>
<li>辅导（Mentoring）</li>
<li>教练（Coaching）<br>懂敏捷指的是一名合格的敏捷教练，首先要有扎实、完备的敏捷知识，要有推进敏捷实践的经验和技术，这是能“教练”的基础<br>能“教练”指的是敏捷教练既要能教授团队什么是敏捷，给团队讲授基础的敏捷知识和这背后的意义；又要能给团队示范和辅导具体的实践怎么做，通过引导团队会议来引导团队推进敏捷；同时，还能用一定的技巧来引导和启发团队去主动思考，主动改良自己的工作<br>很多企业或团队在引进和推进敏捷时，由于内部很少有真正懂的人，一旦外部教练退场，再遇到问题，往往就失去了领头羊，导致在推进过程中缺少必要的持续性引导和辅助，最终只能走向失败<br><strong>如何培养内部敏捷教练</strong><br><strong>基础培训</strong><br>目的是通过一系列培训课程（基础培训、设计思维培训和产品负责人培训）了解足够多的敏捷知识<br>在培训里，会建立起敏捷的基本概念，了解敏捷和设计思维是什么以及应该怎么做；学习关于产品管理的一系列基础知识，以便能更好地与产品负责人沟通，帮助他们一起做敏捷。在培训之后，初级教练会自己去实践，有问题可以向同行或者高级教练请教<br><strong>安排实战工作坊</strong><br>实战工作坊只是个开始和模拟演练，初级教练会在后面的工作中，开展具体的实践，进一步掌握敏捷教练所需要的各种技能<br><strong>线上活动加力</strong><br>对于没有时间参加几整天实战工作坊的初级教练来说，是一个非常不错的补充<br><strong>一对一的教练服务</strong><br>一对一的专属教练服务会让初级教练更快地成长，也是他们成长为中高级教练更为专业的进阶方式<br>辅导过程可以设计成 4 步：</li>
<li>签署教练协议</li>
<li>进行评估</li>
<li>一对一的教练服务</li>
<li>成果展示</li>
</ol>
<h2 id="服务型领导"><a href="#服务型领导" class="headerlink" title="服务型领导"></a>服务型领导</h2><p>服务型领导的管理理念：理解员工并为员工服务，与员工精诚合作</p>
<ol>
<li>首先要是一个服务者，要为整个团队服务，拉近自己与员工的心理距离，这样才会取得团队的信任</li>
<li>从管理目标上来说，目标是和团队成员共同成长，所以做任何事的首要动机都是为团队中大多数人谋取利益，因此团队成员才更愿意努力工作并更好的完成工作</li>
</ol>
<h3 id="怎样成为服务型领导"><a href="#怎样成为服务型领导" class="headerlink" title="怎样成为服务型领导"></a>怎样成为服务型领导</h3><p><strong>给员工建立心理安全机制</strong></p>
<ul>
<li>信任是必不可少的。要支持员工和他们的决定，在工作和工作之外都照顾好团队成员</li>
<li>培养健康的分歧环境。允许分歧存在，在有分歧时虚心听取不同的意见</li>
<li>建立正确的失败文化。失败是可以接受的，只要从失败中吸取教训，能够改进就好<br><strong>掌握情境领导能力</strong><br>领导者能在不同的情境下运用不同的领导力来指导和支持团队成员完成目标或任务<br>领导者通常会面对 4 种不同的情境，或者说面对特定的任务，团队成员会有4 种状态</li>
<li>情境 1：热情的初学者</li>
<li>情境 2：幻灭的学习者</li>
<li>情境 3：有能力但谨慎的贡献者</li>
<li>情境 4：自力更生的成功者<br>每种情景中，团队成员有各自的特点</li>
<li>情境 1：能力低、承诺高<ul>
<li>对自己的任务很陌生，缺乏经验，甚至不了解自己的知识和工作盲区</li>
<li>但有很强的学习意愿，有好奇心并且愿意接受指导，也很自信自己能够学会怎么做</li>
</ul>
</li>
<li>情境 2：能力不是很高，承诺很低<ul>
<li>有一定的知识和技能，但还有所欠缺</li>
<li>学习意愿很差，随时都有气馁和沮丧的情绪，随时可能准备放弃</li>
</ul>
</li>
<li>情境 3：能力处于中上等、承诺很低<ul>
<li>对于某个特定的任务来说是有能力也有经验的</li>
<li>不是很自信，偶尔会犹豫不定，觉得自己的任务很无聊，甚至对能否完成任务漠不关心</li>
</ul>
</li>
<li>情境 4：能力高、承诺高<ul>
<li>有足够的能力，能够胜任工作任务</li>
<li>也非常自信，能鼓舞别人<br>作为管理者，需要能够识别出 4 种不同的情境，识别出来之后，再匹配不同的领导风格<br>领导风格在工作中是用领导行为来体现的：</li>
</ul>
</li>
<li>指导性行为：告诉其他人应该做什么，何时做，如何做，并经常提供结果反馈</li>
<li>支持性行为：鼓励、表扬他人自力更生解决问题，倾听意见，并让他人参与决策<br>针对每一种情境下的团队成员，应该使用的领导风格：</li>
<li>风格 1：指导。高指导行为和低支持行为<ul>
<li>通过讲述和展示，具体指导员工如何达成目标，并密切跟踪员工的表现，频繁地进行反馈和指导，让员工能够顺利地完成目标</li>
<li>目的是帮助情境 1 的员工建立起必备的工作技能</li>
</ul>
</li>
<li>风格 2：教练。高指导行为和高支持行为<ul>
<li>给员工解释工作任务，征求他们的意见，鼓励、引导并持续指导完成目标</li>
<li>目的是重新激发情境 2 的员工的工作热情，提高他们的工作能力</li>
</ul>
</li>
<li>风格 3：支持。低指导行为和高支持行为<ul>
<li>提出开放式问题来促进问题的解决，通常只是询问员工的做法，不多加干涉，倾听和鼓励员工的工作，引导员工一起参与做决定</li>
<li>目的是激发情境 3 员工的信心</li>
</ul>
</li>
<li>风格 4：授权。低指导行为和低支持行为<ul>
<li>认可员工的专业知识，鼓励员工的自主性，并邀请员工持续学习和不断创新</li>
<li>目的是珍视员工的贡献，最大限度地发挥员工的潜能<br>可以通过 3 点用好情境领导力：</li>
</ul>
</li>
</ul>
<ol>
<li>设定目标。要运用好目标管理，设立正确的目标，目标的设定要与需要做的事情保持一致</li>
<li>协同诊断。要会评估员工在特定任务上的能力和承诺，判断他们在这个任务上属于哪一种情境</li>
<li>学会匹配。根据员工所处的情境，匹配自己所需要运用的领导风格，帮助他们完成工作任务，也为他们个人提供需要的帮助</li>
</ol>
]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>敏捷开发</tag>
      </tags>
  </entry>
  <entry>
    <title>标签系统</title>
    <url>/MiracleDx/2019/01/17/%E6%A0%87%E7%AD%BE%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="标签分类"><a href="#标签分类" class="headerlink" title="标签分类"></a>标签分类</h1><h2 id="用户标签"><a href="#用户标签" class="headerlink" title="用户标签"></a>用户标签</h2><p><a href="https://ruby-china.org/topics/40481">如何实现一个信息架构友好的标签系统 · Ruby China</a></p>
<h3 id="属性标签"><a href="#属性标签" class="headerlink" title="属性标签"></a>属性标签</h3><p>数据来源是用户自身的属性</p>
<h3 id="行为标签"><a href="#行为标签" class="headerlink" title="行为标签"></a>行为标签</h3><p>数据来源是用户的行为数据</p>
<h2 id="信息架构标签"><a href="#信息架构标签" class="headerlink" title="信息架构标签"></a>信息架构标签</h2><p><a href="https://ruby-china.org/topics/40481">如何实现一个信息架构友好的标签系统 · Ruby China</a><br>通过搜索和标签过滤信息要素</p>
<ul>
<li>同义词环圈</li>
<li>优选术语</li>
</ul>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>领域驱动设计</title>
    <url>/MiracleDx/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="领域驱动设计-Domain-Drive-Design"><a href="#领域驱动设计-Domain-Drive-Design" class="headerlink" title="领域驱动设计 Domain Drive Design"></a>领域驱动设计 Domain Drive Design</h1><h1 id="一、什么是领域驱动设计"><a href="#一、什么是领域驱动设计" class="headerlink" title="一、什么是领域驱动设计"></a>一、什么是领域驱动设计</h1><p>DDD 是一种<strong>开展业务建模和软件设计的方法论</strong>。DDD 基于领域建模而非数据建模，它使业务逻辑高度内聚，与基础设施、框架解耦，清晰的领域边界解决微服务的拆分问题。<br>是一种设计思想，而非应用架构。<br>面向接口、以业务为核心驱动，自顶向下的进行业务领域划分的架构设计模式。</p>
<blockquote>
<p>DDD的架构能够有效的解决传统架构中的问题：</p>
<ul>
<li>高可维护性：当外部依赖变更时，内部代码只用变更跟外部对接的模块，其他业务逻辑不变。</li>
<li>高可扩展性：做新功能时，绝大部分的代码都能复用，仅需要增加核心业务逻辑即可。</li>
<li>高可测试性：每个拆分出来的模块都符合单一性原则，绝大部分不依赖框架，可以快速的单元测试，做到100%覆盖。</li>
<li>代码结构清晰：通过 POM module 可以解决模块间的依赖关系， 所有外接模块都可以单独独立成 Jar 包被复用。当团队形成规范后，可以快速的定位到相关代码。</li>
</ul>
</blockquote>
<h1 id="二、基础概念"><a href="#二、基础概念" class="headerlink" title="二、基础概念"></a>二、基础概念</h1><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/dc32e8e4a317fe00121ce18adc407c66.dc32e8e4.jpg" alt="img"><br>战略和战术设计是站在DDD的角度进行划分。</p>
<ul>
<li>战略设计侧重于高层次、宏观上去划分和集成限界上下文。</li>
<li>战术设计则关注更具体使用建模工具来细化上下文。</li>
</ul>
<h2 id="2-1、战略设计"><a href="#2-1、战略设计" class="headerlink" title="2.1、战略设计"></a>2.1、战略设计</h2><p>战略设计包括：限界上下文、通用语言、子域。<br>从业务出发，建立业务模型，划分业务边界。</p>
<h3 id="2-1-1、限界上下文-Context-Bounds"><a href="#2-1-1、限界上下文-Context-Bounds" class="headerlink" title="2.1.1、限界上下文 - Context Bounds"></a>2.1.1、限界上下文 - Context Bounds</h3><p>限界上下文就是软件对于问题域的一个特定的、有限的解决方案。<br>用来封装通用语言和领域对象，提供上下文环境，保证域内的一些术语、业务相关对象等有一个确切的含义，没有二义性。这个边界定义了模型的适用性范围。<br>是业务概念的边界，是业务问题最小粒度的划分。每一个限界上下文的内部必须是紧密组织的、职责明确的、具有较高的内聚性。<br>以子域为中心进行建模，绘制出一张一张的领域模型设计，被称为限界上下文。<br>是一个显式的语义和语境上的边界，领域模型便存在于边界之内。边界内，通用语言中的所有术语和词组都有特定的含义。<br>每个模型的应用范围，在每个Bounded Context中确保领域模型的一致性。不同的限界上下文中，领域模型可以不用保证一致性<br>一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义<br>一个给定的业务领域会包含多个限界上下文，想与一个限界上下文沟通，则需要通过显示边界进行通信。系统通过确定的限界上下文来进行解耦，而每一个上下文内部紧密组织，职责明确，具有较高的内聚性。<br>限定上下文定义领域边界。<br>限界上下文可以拆解为两个词：限界和上下文</p>
<ul>
<li>限界：领域的边界</li>
<li>上下文：语义环境<br>定义：用来封装通用语言和领域对象，提供上下文环境，保证在领域内的一些术语、业务相关对象（通用语言）等有一个确切的含义，没有二义性。边界确定了模型的适用范围，使团队内所有成员能够明确知道什么应该在模型中实现，什么不应该在模型中实现。</li>
</ul>
<h3 id="2-1-2、通用语言"><a href="#2-1-2、通用语言" class="headerlink" title="2.1.2、通用语言"></a>2.1.2、通用语言</h3><p>能够简单、清晰、准确描述业务含义和规则，让项目参与人员都能达成共识的语言。<br>通用语言定义上下文含义。</p>
<h3 id="2-1-3、领域"><a href="#2-1-3、领域" class="headerlink" title="2.1.3、领域"></a>2.1.3、领域</h3><p>领域是一个组织所做的事情以及其中包含的一切。每个公司或组织都有自己的业务范围，这个业务范围以及在其中所进行的活动就是领域。<br>DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，从而用代码实现该领域模型，解决相应的业务问题。<br>DDD 的领域就是边界内要解决的业务问题域。</p>
<h4 id="2-1-3-1、子域"><a href="#2-1-3-1、子域" class="headerlink" title="2.1.3.1、子域"></a>2.1.3.1、子域</h4><p>子域是更为细分的领域。可以把域划分为更多的子域。子域的集合就是领域。<br>在 DDD 中一个领域被分成若干小的域，这些小的域就被称为子域。通常在开发领域模型时，关注的都是子域的业务功能。<br>通过领域划分，区分不同子域的功能属性和重要性，从而在系统建设过程中，根据预算和资源，对不同类型的子域采取不同的关注度和资源投入策略。</p>
<h4 id="2-1-3-2、核心子域"><a href="#2-1-3-2、核心子域" class="headerlink" title="2.1.3.2、核心子域"></a>2.1.3.2、核心子域</h4><p>是整个业务系统的核心，所有的业务都要围绕着核心业务领域展开。<br>决定产品和公司核心竞争力的子域是核心域，是业务成功的主要因素和公司的核心竞争力。</p>
<h4 id="2-1-3-3、通用子域"><a href="#2-1-3-3、通用子域" class="headerlink" title="2.1.3.3、通用子域"></a>2.1.3.3、通用子域</h4><p>常见的、不同领域都可共用的领域。例如：认证、授权等。<br>没有太多个性化的诉求，同时被多个子域使用的具备通用功能的子域。</p>
<h4 id="2-1-3-4、支撑子域"><a href="#2-1-3-4、支撑子域" class="headerlink" title="2.1.3.4、支撑子域"></a>2.1.3.4、支撑子域</h4><p>非核心域、非通用子域，具有个性化需求，不包含核心竞争力的功能，也不包含通用的功能，但是是必须的支撑，用于支撑核心域运作。</p>
<h2 id="2-2、战术设计"><a href="#2-2、战术设计" class="headerlink" title="2.2、战术设计"></a>2.2、战术设计</h2><p>战术设计包括：聚合、实体、值对象、资源库、领域服务、领域事件、模块。<br>经过战略设计后，领域有了清晰的边界。需要对领域进行业务映射。<br>根据业务模型进行技术实现，完成微服务的设计、开发及落地。</p>
<h3 id="2-2-1、聚合-Aggregate"><a href="#2-2-1、聚合-Aggregate" class="headerlink" title="2.2.1、聚合 - Aggregate"></a>2.2.1、聚合 - Aggregate</h3><p>是领域对象的显示分组，用于支持领域模型的行为和不变形，同时充当一致性和事务性边界。<br>聚合 &#x3D; 关联性极强、生命周期一致的实体、值对象组合成的对象。<br>负责封装业务逻辑，内聚决策命令和领域事件，容纳实体、聚合根、值对象<br>聚合是一组相关对象的组合，做为一个整体被外界访问。<br>一个聚合就是一个包，里面包括:</p>
<ul>
<li>领域服务</li>
<li>工厂</li>
<li>资源库</li>
<li>聚合根</li>
<li>实体</li>
<li>值对象</li>
<li>领域事件<br>一个限界上下文可能包含多个聚合，但一个聚合只能存在于一个限界上下文<br>聚合用来确保实体和值对象在实现共同的业务逻辑时，能够保证数据的一致性，是由业务和逻辑紧密关联的实体和值对象组合而成的，是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。<br>聚合由一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，聚合之间的边界是松耦合的。<br>如何创建好的聚合？</li>
<li>边界内的内容具有一致性：在一个事务中只修改一个聚合实例。如果发现边界内很难接受强一致，不管是出于性能或产品需求的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。</li>
<li>设计小聚合：大部分的聚合都可以只包含根实体，而无需包含其他实体。即使一定要包含，可以考虑将其创建为值对象。</li>
<li>通过唯一标识来引用其他聚合或实体：当存在对象之间的关联时，建议引用其唯一标识而非引用其整体对象。如果是外部上下文中的实体，引用其唯一标识或将需要的属性构造值对象。 如果聚合创建复杂，推荐使用工厂方法来屏蔽内部复杂的创建逻辑。<br>聚合内部多个组成对象的关系可以用来指导数据库创建，但不可避免存在一定的抗阻。如聚合中存在 List&lt;值对象&gt;，那么在数据库中建立 1:N 的关联需要将值对象单独建表，此时是有 id 的，建议不要将该 id 暴露到资源库外部，对外隐蔽。</li>
</ul>
<h3 id="2-2-2、聚合根-Aggregate-Root"><a href="#2-2-2、聚合根-Aggregate-Root" class="headerlink" title="2.2.2、聚合根 - Aggregate Root"></a>2.2.2、聚合根 - Aggregate Root</h3><p>聚合根的目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。<br>聚合根不仅是实体，还是聚合的管理者。<br>聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。<br>是聚合中最具代表性的实体，是一个聚合的根节点<br>核心领域通常是用聚合来表达，聚合在技术上也有非常高的价值，可以指导详细设计。<br>聚合由根实体、实体、值对象组成。</p>
<ul>
<li>聚合根不能直接操作其它聚合根，聚合根与聚合根之间只能通过聚合根 ID 引用。</li>
<li>同限界上下文内的聚合之间的领域服务可以直接调用。</li>
<li>两个限界上下文的交互必须通过应用服务层抽离接口，通过防腐层适配。</li>
</ul>
<h3 id="2-2-3、实体-Entity"><a href="#2-2-3、实体-Entity" class="headerlink" title="2.2.3、实体 - Entity"></a>2.2.3、实体 - Entity</h3><p>由属性和行为组成，具有唯一标识且是可持续变化的。有自己的一整套生命周期，在生命周期内，无论怎么变化，仍旧是同一个实体。可变性反映了实体本身的状态和行为。<br>实体 &#x3D; 唯一身份标识 + 可变性 【状态 + 行为】<br>实体依附于聚合根，其生命周期由聚合根管理，一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象</p>
<h4 id="2-2-3-1、失血模型"><a href="#2-2-3-1、失血模型" class="headerlink" title="2.2.3.1、失血模型"></a>2.2.3.1、失血模型</h4><h4 id="2-2-3-2、贫血模型"><a href="#2-2-3-2、贫血模型" class="headerlink" title="2.2.3.2、贫血模型"></a>2.2.3.2、贫血模型</h4><h4 id="2-2-3-3、充血模型"><a href="#2-2-3-3、充血模型" class="headerlink" title="2.2.3.3、充血模型"></a>2.2.3.3、充血模型</h4><h4 id="2-2-3-4、胀血模型"><a href="#2-2-3-4、胀血模型" class="headerlink" title="2.2.3.4、胀血模型"></a>2.2.3.4、胀血模型</h4><h3 id="2-2-4、值对象-Value-Object"><a href="#2-2-4、值对象-Value-Object" class="headerlink" title="2.2.4、值对象 - Value Object"></a>2.2.4、值对象 - Value Object</h3><p>通过对象属性值来识别的对象，它将多个相关属性做为一个概念整体。<br>当只关心某个对象的属性时，该对象便可以做为一个值对象。<br>需要将值对象看成不变对象，值对象不具备任何身份标识，应该尽量避免像实体对象一样的复杂性。<br>值对象 &#x3D; 将值用对象的方式进行表述，表达一个具体的固定不变的概念<br>实体的附加业务概念，用于描述实体所包含的业务信息。没有唯一标识，具有可度量或者可描述的，并满足不变形的对象。<br>需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。<br>数据集被整体创建，整体读取，修改需求少时可以设计成值对象<br>值对象之间通过属性值判断相等性</p>
<blockquote>
<p>常见的 Value Object 的使用场景</p>
<ul>
<li>有格式限制的 String，比如 Name、PhoneNumber、Address 等</li>
<li>有限制的 Integer，如 OrderId（&gt; 0）、Percentage（0-100%） 等</li>
<li>可枚举的 int，比如 Status （因为反序列化问题一般不用 Enum ）</li>
<li>Double 或 BigDecimal，一般用到的 Double 或 BigDecimal 都是有业务含义的，比如 Money、Amount、Rating 等</li>
<li>复杂的数据结构，比如 <code>Map&lt;String, List&lt;Integer&gt;&gt;</code> 等，尽量把 Map 的所有操作包装，仅暴露必要行为</li>
</ul>
</blockquote>
<h3 id="2-2-5、资源库-Repository"><a href="#2-2-5、资源库-Repository" class="headerlink" title="2.2.5、资源库 - Repository"></a>2.2.5、资源库 - Repository</h3><p>是聚合根的容器，只提供持久化聚合根的操作（新增&#x2F;更新）以及提供根据 ID 获取聚合根的查询操作。资源库将聚合根的存储与存储中间件解耦，可以根据业务特性选择关系型数据库或者非关系型数据库存储聚合根。<br>在所有的领域对象中，只有聚合根才拥有 Repository，Repository 的职责是向领域模型提供聚合根。<br>在存储聚合根时，可能需要将聚合根及聚合根下的多个实体拆分到多个表存储，可能导致每次 Save 聚合根都需要执行多条 Update 语句。</p>
<blockquote>
<p>为了解决关系数据库做为聚合根容器导致的性能问题，有两种解决方式</p>
<ol>
<li>基于 Snapshot 方案：当数据从 DB 中取出来后，在内存中保存一份 Snapshot，然后在数据写入时和 Snapshot 比较。例如：Hibernate。</li>
<li>基于 Proxy 方案：当数据从 DB 中取出来后，通过 weaving 的方式将所有 Setter 都增加一个切面用于判断 Setter 是否被调用以及值是否变更，如果变更则标记为 Dirty，在保存时，根据 Dirty 判断是否需要更新。例如 Entity Framework。</li>
</ol>
</blockquote>
<h3 id="2-2-6、领域服务"><a href="#2-2-6、领域服务" class="headerlink" title="2.2.6、领域服务"></a>2.2.6、领域服务</h3><p>理想状况是没有领域服务<br>表示一个无状态的操作，用于实现特定于某个领域的任务。当某个操作不适合放在聚合和值对象上时，需要使用领域服务。<br>可以使用领域服务的情况：</p>
<ol>
<li>执行一个显著的业务操作</li>
<li>对领域对象进行转换</li>
<li>以多个领域对象作为参数进行计算，结果产生一个值对象</li>
</ol>
<h3 id="2-2-7、领域事件"><a href="#2-2-7、领域事件" class="headerlink" title="2.2.7、领域事件"></a>2.2.7、领域事件</h3><p>领域事件是对领域内发生的活动进行的建模<br>是一个领域模型中极其重要的部分，用来表示领域中发生的事件。在领域中发生的一些事件，通常将领域事件用于维护事件的一致性。<br>领域事件 &#x3D; 事件发布 + 事件存储 + 事件分发 + 事件处理</p>
<h3 id="2-2-8、工厂"><a href="#2-2-8、工厂" class="headerlink" title="2.2.8、工厂"></a>2.2.8、工厂</h3><p>工厂提供一个创建对象的接口，该接口封住了所有创建对象的复杂操作过程。</p>
<ul>
<li>领域模型中的工厂</li>
<li>将创建复杂对象和聚合的职责分配给一个单独的对象，并不承担领域模型中的职责，是领域设计中的一部分。</li>
<li>对于聚合来说，应该一次性的创建整个聚合，并且确保它的不变条件得到满足。</li>
<li>工厂只承担创建模型的工作，不具有其它领域行为。</li>
<li>一个含有工厂方法的聚合根的主要职责是完成它的聚合行为。</li>
<li>在聚合上使用工厂方法能更好的表达通用语言，这是使用构造函数不能表达的。</li>
<li>聚合根中的工厂方法</li>
<li>表现出了领域感念。</li>
<li>可以提供守卫措施。</li>
<li>领域服务中的工厂</li>
<li>在集成限界上下文时，领域服务做为工厂。</li>
<li>领域服务的接口放在领域模型内，实现放在基础设施层。</li>
</ul>
<h3 id="2-2-9、应用服务"><a href="#2-2-9、应用服务" class="headerlink" title="2.2.9、应用服务"></a>2.2.9、应用服务</h3><p>是用来表达用例和用户故事的主要手段<br>不处理业务逻辑，只负责对领域服务、聚合根方法的编排和转发，将要实现的功能委托给一个或多个领域对象来实现，本身只负责处理业务用例的执行顺序以及结果的拼装。</p>
<h2 id="2-3、CQE-模式"><a href="#2-3、CQE-模式" class="headerlink" title="2.3、CQE 模式"></a>2.3、CQE 模式</h2><p>CQE 即 Command、Query、Event。接收写请求使用 Command，接收查询请求使用 Query，消费事件使用 Event。<br>除 Event 外，所有写都使用 Command 接收参数，所有查询都是用 Query，只在参数只有一个 ID 的查询情况下，可以省略 Query。</p>
<h3 id="2-3-1、CQE-的规范"><a href="#2-3-1、CQE-的规范" class="headerlink" title="2.3.1、CQE 的规范"></a>2.3.1、CQE 的规范</h3><p>CQE 和 DTO 的区别</p>
<ul>
<li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其”正确性“。</li>
<li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。</li>
</ul>
<p><strong>规范：</strong>CQE 对象的校验应该前置，避免在 ApplicationService 里做参数的校验。可以通过 JSR303&#x2F;380 和 Spring Validation 来实现<br>从本质上来看，这几种对象都是 Value Object，但是从语义上来看有比较大的差异：</p>
<ul>
<li>Command 指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</li>
<li>Query 查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</li>
<li>Event 事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</li>
</ul>
<table>
<thead>
<tr>
<th>Command</th>
<th>Query</th>
<th>Event</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>语意</td>
<td>”希望“能触发的操作</td>
<td>各种条件的查询</td>
<td>已经发生过的事情</td>
</tr>
<tr>
<td>读&#x2F;写</td>
<td>写</td>
<td>只读</td>
<td>通常是写</td>
</tr>
<tr>
<td>返回值</td>
<td>DTO 或 Boolean</td>
<td>DTO 或 Collection</td>
<td>Void</td>
</tr>
</tbody></table>
<h2 id="2-4、CQRS-模式"><a href="#2-4、CQRS-模式" class="headerlink" title="2.4、CQRS 模式"></a>2.4、CQRS 模式</h2><p>CQRS （Command - QueryResponsibility Segregation）查询职责分离模式。将应用分为两部分：命令段（Command）和查询端（Query）。命令端处理程序创建、更新和删除请求，并在数据更改时发出事件。查询端通过执行查询来梳理查询，并且通过订阅数据更改时发出的事件流而保持最新。<br>CQRS 使用分离的接口将数据查询操作和数据修改操作分离开来，意味着查询和更新过程中使用的数据模型也是不一样的。<br>用途在于将领域模型与查询功能进行分离，让一些复杂的查询摆脱领域模型的限制，以更为简单的 DTO 形式展现查询结果。同时分离不同的数据存储结构。</p>
<ul>
<li><p>一个对象的一个方法修改了对象的状态，该方法便是一个命令（Command），不应该返回数据，声明为 void。</p>
</li>
<li><p>一个对象的一个方法如果返回了数据，该方法便是一个查询（Query），不应该通过直接或者间接的手段你修改对象状态。</p>
</li>
<li><p>聚合只有 Command 方法，没有 Query 方法。</p>
</li>
<li><p>资源库只有 add、save、find 方法。</p>
</li>
</ul>
<p>事件订阅更新查询模型。</p>
<h1 id="三、最佳实践"><a href="#三、最佳实践" class="headerlink" title="三、最佳实践"></a>三、最佳实践</h1><h2 id="3-1、代码组织结构"><a href="#3-1、代码组织结构" class="headerlink" title="3.1、代码组织结构"></a>3.1、代码组织结构</h2><p>模块（Module）是 DDD 中明确提到的一种控制限界上下文的手段，在工程中，一般尽量用一个模块来表示一个领域的限界上下文。<br>一般的工程中包的组织方式为{com.公司名.组织架构.业务.上下文.*}，这样的组织结构能够明确的将一个上下文限定在包的内部。<br>DDD 中一般的分层结构：</p>
<ul>
<li><p>Interfaces 层依赖 Application 层</p>
</li>
<li><p>Application 层依赖 Domain 层</p>
</li>
<li><p>Application 层依赖 Infrastructure 层</p>
</li>
<li><p>Infrastructure 层依赖 Domain 层</p>
</li>
<li><p>Rpc 看情况是否需要抽离,被 Application 层依赖</p>
</li>
</ul>
<blockquote>
<p>DDD 中不同模块的代码的演进速度是不一样的：</p>
<ul>
<li>Domain 层属于核心业务逻辑，属于经常被修改的地方。通过 Entity 能够解决基于单个对象的逻辑变更，通过 Domain Service 解决多个对象间的业务逻辑变更。</li>
<li>Application 层属于 Use Case（业务用例）。业务用例一般都是描述比较大方向的需求，接口相对稳定，特别是对外的接口一般不会频繁变更。添加业务用例可以通过新增 Application Service 或者新增接口实现功能的扩展。</li>
<li>Infrastructure 层属于最低频变更的。一般这个层的模块只有在外部依赖变更了之后才会跟着升级，而外部依赖的变更频率一般远低于业务逻辑的变更频率。</li>
</ul>
</blockquote>
<h3 id="3-1-1、接口层-interfaces"><a href="#3-1-1、接口层-interfaces" class="headerlink" title="3.1.1、接口层 - interfaces"></a>3.1.1、接口层 - interfaces</h3><p>Interfaces 层对外以各种协议提供服务，在该层需要明确定义支持的服务协议、契约等。<br>Interfaces 层提供的功能：</p>
<ul>
<li>职责：主要负责承接网络协议的转化、Session管理等</li>
<li>接口数量：避免所谓的统一 API，不必人为限制接口类的数量，每个&#x2F;每类业务对应一套接口即可，接口参数应该符合业务需求，避免大而全的入参。</li>
<li>接口出参：统一返回 Result。</li>
<li>异常处理：应该捕捉所有异常，避免异常信息的泄漏。可以通过 AOP 统一处理，避免代码里有大量重复代码。</li>
</ul>
<h3 id="3-1-2、应用层-Application"><a href="#3-1-2、应用层-Application" class="headerlink" title="3.1.2、应用层 - Application"></a>3.1.2、应用层 - Application</h3><p>Application 模块主要包含 Application Service 和一些相关的类，Application 模块依赖 Domain 模块。ApplicationService只负责业务流程串联，不负责业务逻辑，不是必须的一层，可以由 UI 层兼任。<br>Application 是很薄的一层，负责组合、编排和转发 domain 层的领域对象和基础设施层的公共组件，根据业务需求处理业务用例的执行顺序以及结果的拼装，以适应多变的业务需求，拼装完领域服务后以粗粒度的服务通过 API 对外暴露。也是与其它系统应用层进行交互的必要渠道。<br>应用层除了定义应用服务之外，在这层还可以进行安全认证，权限校验，持久化事务控制或向其他系统发送基于事件的消息通知。<br>DTO Assembler：在Application层，Entity 到DTO 的转化器有一个标准的名称叫 DTO Assembler。<br>DTO Assembler 的核心作用就是将 1 个或多个相关联的Entity 转化为 1 个或多个 DTO，不可以从 DTO 转 Entity VO（通常一个DTO 转化为 Entity 时是无法保证Entity 的准确性的）。<br>Application 层提供的功能：</p>
<ul>
<li>入参：具像化 Command、Query、Event 对象作为 ApplicationService 的入参，唯一可以的例外是单 ID 查询的场景。</li>
<li>CQE的语意化：CQE 对象有语意，不同用例之间语意不同，即使参数一样也要避免复用。</li>
<li>入参校验：基础校验通过 Bean Validation api 解决。Spring Validation 自带 Validation 的 AOP，也可以自己写 AOP。</li>
<li>出参：统一返回 DTO，而不是 Entity 或 DO。</li>
<li>DTO 转化：用 DTO Assembler 负责 Entity &#x2F; VO 到 DTO 的转化。</li>
<li>异常处理：不统一捕捉异常，可以随意抛异常。</li>
</ul>
<blockquote>
<p>Application Service的代码通常有类似的结构：ApplicationService 通常不做任何决策（Precondition 除外），仅仅是把所有决策交给 DomainService 或 Entity，把跟外部交互的交给 Infrastructure 接口，如 Repository 或防腐层。</p>
<p>一般的 “套路” 如下：</p>
<ul>
<li>准备数据：包括从外部服务或持久化源取出相对应的 Entity、VO 以及外部服务返回的 DTO。</li>
<li>执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。</li>
<li>持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。</li>
</ul>
</blockquote>
<h3 id="3-1-3、Types-层"><a href="#3-1-3、Types-层" class="headerlink" title="3.1.3、Types 层"></a>3.1.3、Types 层</h3><p>Types 模块是保存可以对外暴露的 Value Object 的地方。Value Object 因为是无状态的逻辑，可以对外暴露。经常被包含在对外的 API 接口中，需要单独称为模块。<br>Types 模块不依赖任何类库，属于纯 POJO。</p>
<h3 id="3-1-4、领域层-Domain"><a href="#3-1-4、领域层-Domain" class="headerlink" title="3.1.4、领域层 - Domain"></a>3.1.4、领域层 - Domain</h3><p>Domain 负责表达业务概念、业务状态信息以及业务规则。是最多变的一层，需要保证这一层是高内聚的。确保所有的业务逻辑都留在这一层，而不会遗漏到其他层。<br>Domian 层包含有状态的 Entity、领域服务 Domain Service、领域事件 Domian Event、以及各种外部依赖的接口类（比如 Repository、ACL、中间件等）。<br>Domain 模块的具体表现形式就是领域模型。<br>Domain 模块仅依赖 Types 模块，属于纯 POJO。<br>领域服务：当领域中，某个操作过程或转换过程不是实体或者值对象的指责时，应该将操作放在一个单独的接口中。一个聚合使用 DomainService 来保持业务的一致性，一个聚合只有一个 Domain Service。</p>
<h3 id="3-1-5、基础设施层-infrastructure"><a href="#3-1-5、基础设施层-infrastructure" class="headerlink" title="3.1.5、基础设施层 - infrastructure"></a>3.1.5、基础设施层 - infrastructure</h3><p>Infrastructure 模块包含了 Persistence、MessagIng、External 等模块。<br>infrastructure 向其他层提供通用的技术能力，供 controller、service、domain 层调用，比如：持久化相关组件、httpclent、validation、checkLogint、exceptionHandler、message resource 等。<br>Data Converter：在 Infrastructure 层，Entity 到 DO 的转化器没有一个标准名称，但是为了区分 Data Mapper，这种转化器被称为 Data Converter。<br>Data Converter 的核心作用是将 DO转化为 Entity。</p>
<h3 id="3-1-6、防腐层-ACL"><a href="#3-1-6、防腐层-ACL" class="headerlink" title="3.1.6、防腐层 - ACL"></a>3.1.6、防腐层 - ACL</h3><p>当被依赖的系统可能包含不合理的数据结构、API、协议或技术实现时，如果对外 系统强依赖，会导致系统被 “腐蚀”。这时，可以通过在系统间加入防腐层，能够有效隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能保持不变。<br>ACL 提供的功能：</p>
<ul>
<li>适配器：通过适配器模式，将外部依赖的数据转换逻辑封装到 ACL 内部，降低对业务代码的侵入，使入参、出参更符合标准</li>
<li>缓存：对于频繁调用且数据变更不频繁的外部依赖，在 ACL 中嵌入缓存逻辑，能够有效降低对外部依赖的请求压力。</li>
<li>兜底：外部依赖的稳定性较差，可以通过 ACL 做为兜底，在 ACL 中返回最近一次成功的缓存或者业务兜底数据。</li>
<li>易于测试：ACL 的接口可以很容易的实现 Mock 或 Stub，便于单元测试。</li>
<li>功能开关：可以在 ACL 配置功能开关实现在某些场景下开放或关闭某个接口的功能或者让某个接口返回特定的值。<blockquote>
<p>ACL 防腐层的简单原理如下：</p>
<ol>
<li>对于依赖的外部对象，抽取出所需要的字段，生成一个内部所需的 VO 或 DTO 类</li>
<li>构建一个新的 Facade，在 Facade 中封装调用链路，将外部类转化为内部类</li>
<li>针对外部系统调用，同样的用 Facade 方法封装外部调用链路</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="3-1-7、Start-Boostrap-模块"><a href="#3-1-7、Start-Boostrap-模块" class="headerlink" title="3.1.7、Start &#x2F; Boostrap 模块"></a>3.1.7、Start &#x2F; Boostrap 模块</h3><p>Start 、Boostrap 模块是 Spring Boot 的启动类。</p>
<h2 id="3-2、最佳实践-规范"><a href="#3-2、最佳实践-规范" class="headerlink" title="3.2、最佳实践&#x2F;规范"></a>3.2、最佳实践&#x2F;规范</h2><h3 id="3-2-1、Domain-规范"><a href="#3-2-1、Domain-规范" class="headerlink" title="3.2.1、Domain 规范"></a>3.2.1、Domain 规范</h3><ol>
<li>通过 Factory 模式来创建对象，可以降低一些重复性的入参。</li>
<li>尽量避免 public setter。通过方法名重新写为比较 “行为化 ”的命名，会增强其语意。</li>
<li>通过聚合根保证主子实体的一致性。</li>
<li>不可以强依赖其他聚合根实体或领域服务。</li>
</ol>
<ul>
<li>在稍微复杂一点的领域里，通常主实体会包含子实体，这时候主实体就需要起到聚合根的作用，即：</li>
<li>子实体不能单独存在，只能通过聚合根的方法获取到。任何外部的对象都不能直接保留子实体的引用。</li>
<li>子实体没有独立的 Repository，不可以单独保存和取出，必须要通过聚合根的 Repository 实例化。</li>
<li>子实体可以单独修改自身状态，但是多个子实体之间的状态一致性需要聚合根来保障。</li>
<li>正确的对外部依赖的方法有两种：</li>
<li>只保存外部实体的 ID：建议使用强类型的 ID 对象，而不是 Lon g型 ID。强类型的 ID 对象不单单能自我包含验证代码，保证 ID 值的正确性，同时还能确保各种入参不会因为参数顺序变化而出 bug。</li>
<li>针对于 “无副作用” 的外部依赖，通过方法入参的方式传入。如果方法对外部依赖有副作用，不能通过方法入参的方式，只能通过 Domain Service 解决。</li>
</ul>
<ol start="5">
<li>任何实体的行为不能有 “直接” 的 ”副作用“，即直接修改其他的实体类。</li>
<li>任何实体的行为只能直接影响到本实体（和其子实体）</li>
<li>当一个行为会直接修改多个实体时，不能再通过单一实体的方法作处理，而必须直接使用领域服务的方法来做操作。此时，领域服务更多的起到了跨对象事务的作用，确保多个实体的变更之间是有一致性的<blockquote>
<p>一个实体的原则是高内聚、低耦合，即一个实体类不能直接在内部直接依赖一个外部的实体或服务。这个原则和绝大多数 ORM 框架都有比较严重的冲突，所以在开发过程中需要特别注意。<br>这个原则的必要原因包括：对外部对象的依赖性会直接导致实体无法被单测；以及一个实体无法保证外部实体变更后不会影响本实体的一致性和正确性。</p>
</blockquote>
</li>
</ol>
<h3 id="3-2-2、Repository-规范"><a href="#3-2-2、Repository-规范" class="headerlink" title="3.2.2、Repository 规范"></a>3.2.2、Repository 规范</h3><p>在 Repository 的设计上，主要需要注意以下三点：</p>
<ol>
<li>接口名称不应该使用底层实现的语法：常见的 insert、select、update、delete 都属于SQL语法，使用这几个词相当于和 DB 底层实现做了绑定。相反，应该把 Repository 当成一个中性的类似 Collection 的接口，使用语法如 find、save、remove。</li>
<li>特别需要注意的是区分 insert &#x2F; add 和 update 本身也是一种和底层强绑定的逻辑，一些储存如缓存实际上不存在 insert 和 update 的差异，在这个 case 里，使用中性的 save 接口，然后在具体实现上根据情况调用 DAO 的 insert 或 update 接口。</li>
<li>出参入参不应该使用底层数据格式：需要记得的是 Repository 操作的是 Entity 对象（实际上应该是 Aggregate Root），而不应该直接操作底层的 DO 。更近一步，Repository 接口实际上应该存在于 Domain 层，根本看不到 DO 的实现。这个也是为了避免底层实现逻辑渗透到业务代码中的强保障。</li>
<li>应该避免所谓的“通用 ”Repository“ 模式：很多 ORM 框架都提供一个 “通用” 的 Repository 接口，然后框架通过注解自动实现接口，比较典型的例子是 Spring Data、Entity Framework 等，这种框架的好处是在简单场景下很容易通过配置实现，但是坏处是基本上无扩展的可能性（比如加定制缓存逻辑），在未来有可能还是会被推翻重做。</li>
</ol>
<h3 id="3-2-3、Interface-层规范"><a href="#3-2-3、Interface-层规范" class="headerlink" title="3.2.3、Interface 层规范"></a>3.2.3、Interface 层规范</h3><p>一个Interface层的类应该是 “小而美” 的，应该是面向 “一个单一的业务” 或 “一类同样需求的业务” ，需要尽量避免用同一个类承接不同类型业务的需求。</p>
<ol>
<li>Interface 层的 HTTP 和 RPC 接口，返回值为 Result，捕捉所有异常。</li>
<li>Application 层的所有接口返回值为 DTO，不负责处理异常。</li>
</ol>
<h3 id="3-2-4、Application-层规范"><a href="#3-2-4、Application-层规范" class="headerlink" title="3.2.4、Application 层规范"></a>3.2.4、Application 层规范</h3><p>ApplicationService 的接口入参只能是一个 Command、Query 或 Event 对象，CQE 对象需要能代表当前方法的语意。唯一可以的例外是根据单一 ID 查询的情况，可以省略掉一个 Query 对象的创建。<br>因为 CQE 是有 “意图” 和 “语意” 的，需要尽量避免 CQE 对象的复用，哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象。</p>
<blockquote>
<p>ApplicationService 的返回值应该永远返回 DTO 而不是 Entity</p>
<ol>
<li>构建领域边界：ApplicationService 的入参是 CQE 对象，出参是 DTO，这些基本上都属于简单的 POJO，来确保 Application 层的内外互相不影响。</li>
<li>降低规则依赖：Entity 里面通常会包含业务规则，如果 ApplicationService 返回 Entity，则会导致调用方直接依赖业务规则。如果内部规则变更可能直接影响到外部</li>
<li>通过 DTO 组合降低成本：Entity 是有限的，DTO 可以是多个 Entity、VO 的自由组合，一次性封装成复杂 DTO，或者有选择的抽取部分参数封装成 DTO 可以降低对外的成本。</li>
</ol>
</blockquote>
<h3 id="3-2-5、异常处理"><a href="#3-2-5、异常处理" class="headerlink" title="3.2.5、异常处理"></a>3.2.5、异常处理</h3><p>在 Application 层、Domain 层，以及 Infrastructure 层，遇到错误直接抛异常是最合理的方法。</p>
<h1 id="四、常见误区"><a href="#四、常见误区" class="headerlink" title="四、常见误区"></a>四、常见误区</h1><h2 id="6-1、Application-Service-和-domain-Service-的区别"><a href="#6-1、Application-Service-和-domain-Service-的区别" class="headerlink" title="6.1、Application Service 和 domain Service 的区别"></a>6.1、Application Service 和 domain Service 的区别</h2><p>应用服务：是各种方法的编排，不处理任何业务逻辑。业务的逻辑体现在聚合根中，应用服务只负责调用。<br>领域服务：聚合根本身无法完全处理该逻辑。</p>
<h2 id="6-2、聚合和实体的区别"><a href="#6-2、聚合和实体的区别" class="headerlink" title="6.2、聚合和实体的区别"></a>6.2、聚合和实体的区别</h2><h2 id="6-3、实体和值对象的区别"><a href="#6-3、实体和值对象的区别" class="headerlink" title="6.3、实体和值对象的区别"></a>6.3、实体和值对象的区别</h2><p>实体和值对象的目的都是抽象聚合若干属性以简化设计和沟通。</p>
<ol>
<li>实体和值对象都经过属性聚类形成，实体有唯一性，值对象没有。</li>
<li>实体着重唯一性和延续性，不在意属性的变化；值对象着重描述性，对属性的变化很敏感。</li>
<li>实体和值对象也有可能随着系统业务关注点的不同而更换位置。</li>
</ol>
<h2 id="6-4、聚合根定义的业务边界是什么"><a href="#6-4、聚合根定义的业务边界是什么" class="headerlink" title="6.4、聚合根定义的业务边界是什么"></a>6.4、聚合根定义的业务边界是什么</h2><p>不以表结构数据进行业务逻辑的划分，一个业务体为一块业务。以实体与值对象的方式在聚合内进行定义。</p>
<h2 id="6-5、应用服务层如果调用-RPC-是否必须使用-adapter"><a href="#6-5、应用服务层如果调用-RPC-是否必须使用-adapter" class="headerlink" title="6.5、应用服务层如果调用 RPC 是否必须使用 adapter"></a>6.5、应用服务层如果调用 RPC 是否必须使用 adapter</h2><p>必须使用，需要屏蔽外部依赖对应当前业务逻辑影响。</p>
<h2 id="6-6、返回的结果数据为多个接口组成，是否在应用服务层直接组合"><a href="#6-6、返回的结果数据为多个接口组成，是否在应用服务层直接组合" class="headerlink" title="6.6、返回的结果数据为多个接口组成，是否在应用服务层直接组合"></a>6.6、返回的结果数据为多个接口组成，是否在应用服务层直接组合</h2><p>不可以，需要定义一个 assember，单独对外部依赖的各种数据进行处理。</p>
<h2 id="6-7、save-方法做完-insert-和-update-所有操作么"><a href="#6-7、save-方法做完-insert-和-update-所有操作么" class="headerlink" title="6.7、save 方法做完 insert 和 update 所有操作么"></a>6.7、save 方法做完 insert 和 update 所有操作么</h2><p>insert 和 update 方法理论上是需要保持统一方法的。</p>
<h2 id="6-8、逻辑处理的-service-放在哪里"><a href="#6-8、逻辑处理的-service-放在哪里" class="headerlink" title="6.8、逻辑处理的 service 放在哪里"></a>6.8、逻辑处理的 service 放在哪里</h2><p>如果该逻辑只为某个聚合使用，则放置在对应的领域服务中，如果逻辑处理会被多个聚合使用，则将其单独定义一个 service，做为一个工具类。</p>
<h2 id="6-9、DO、Entity、DTO-的区别"><a href="#6-9、DO、Entity、DTO-的区别" class="headerlink" title="6.9、DO、Entity、DTO 的区别"></a>6.9、DO、Entity、DTO 的区别</h2><table>
<thead>
<tr>
<th></th>
<th align="left">DO</th>
<th align="left">Entity</th>
<th align="left">DTO</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td align="left">数据库表映射</td>
<td align="left">业务逻辑</td>
<td align="left">适配业务场景</td>
</tr>
<tr>
<td><strong>代码层级</strong></td>
<td align="left">Infrastructure</td>
<td align="left">Domain</td>
<td align="left">Application</td>
</tr>
<tr>
<td><strong>命名规范</strong></td>
<td align="left">XxxDO</td>
<td align="left">Xxx</td>
<td align="left">XxxDTO、XxxCommand、XxxRequest等</td>
</tr>
<tr>
<td><strong>字段名称标准</strong></td>
<td align="left">数据库表字段名</td>
<td align="left">业务语言</td>
<td align="left">和调用方商定</td>
</tr>
<tr>
<td><strong>字段数据类型</strong></td>
<td align="left">数据库字段类型</td>
<td align="left">尽量是有业务含义的类型，比如DP</td>
<td align="left">和调用方商定</td>
</tr>
<tr>
<td><strong>是否需要序列化</strong></td>
<td align="left">不需要</td>
<td align="left">不需要</td>
<td align="left">需要</td>
</tr>
<tr>
<td><strong>转化器</strong></td>
<td align="left">Data Converter</td>
<td align="left">Data Converter DTO Assembler</td>
<td align="left">DTO Assembler</td>
</tr>
</tbody></table>
<h2 id="6-10、如何判断是否业务流程"><a href="#6-10、如何判断是否业务流程" class="headerlink" title="6.10、如何判断是否业务流程"></a>6.10、如何判断是否业务流程</h2><ol>
<li>不要有 if&#x2F;else 分支逻辑：也就是说代码的 Cyclomatic Complexity（循环复杂度）应该尽量等于 1</li>
<li>通常有分支逻辑的，都代表一些业务判断，应该将逻辑封装到 DomainService 或者 Entity 里。但不代表完全不能有 if 逻辑，比如，对某个业务返回值的判断的异常处理仅仅代表了中断条件.</li>
<li>不要有任何计算</li>
<li>一些数据的转化可以交给其他对象来做：比如 DTO Assembler，将对象间转化的逻辑沉淀在单独的类中，降低 ApplicationService 的复杂度</li>
</ol>
<h2 id="6-11、DDD-和-微服务的区别"><a href="#6-11、DDD-和-微服务的区别" class="headerlink" title="6.11、DDD 和 微服务的区别"></a>6.11、DDD 和 微服务的区别</h2><p>DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。<br>微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。</p>
<h1 id="五、-业务流程设计模式"><a href="#五、-业务流程设计模式" class="headerlink" title="五、 业务流程设计模式"></a>五、 业务流程设计模式</h1><p>没有最好的模式，取决于业务场景、依赖关系、以及是否有业务“负责人”。避免拿着锤子找钉子。</p>
<ol>
<li>Orchestration：指令驱动，依赖方是上游，需要感知到下游的能力和返回值</li>
<li>Choreography：事件驱动，依赖方是下游，需要感知到上游的事件</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Orchestration</th>
<th>Choreography</th>
</tr>
</thead>
<tbody><tr>
<td>驱动力</td>
<td>指令驱动 Command-Driven</td>
<td>事件驱动 Event-Driven</td>
</tr>
<tr>
<td>调用依赖</td>
<td>上游强依赖下游</td>
<td>无直接调用依赖但是有代码依赖可以认为是下游依赖上游</td>
</tr>
<tr>
<td>灵活性</td>
<td>较差</td>
<td>较高</td>
</tr>
<tr>
<td>业务职责</td>
<td>上游为业务负责</td>
<td>无全局责任人</td>
</tr>
</tbody></table>
<ul>
<li><strong>从代码依赖关系来看：</strong><br>Orchestration：涉及到一个服务调用到另外的服务，对于调用方来说，是强依赖的服务提供方。<br>Choreography：每一个服务只是做好自己的事，然后通过事件触发其他的服务，服务之间没有直接调用上的依赖。但要注意的是下游还是会依赖上游的代码（比如事件类），所以可以认为是下游对上游有依赖。</li>
<li><strong>从代码灵活性来看：</strong><br>Orchestration：因为服务间的依赖关系是写死的，增加新的业务流程必然需要修改代码。<br>Choreography：因为服务间没有直接调用关系，可以增加或替换服务，而不需要改上游代码。</li>
<li>从调用链路来看：<br>Orchestration：是从一个服务主动调用另一个服务，所以是Command-Driven指令驱动的。<br>Choreography：是每个服务被动的被外部事件触发，所以是 Event-Driven 事件驱动的。</li>
<li><strong>从业务职责来看：</strong><br>Orchestration：有主动的调用方（比如：下单服务）。无论下游的依赖是谁，主动的调用方都需要为整个业务流程和结果负责。<br>Choreography：没有主动调用方，每个服务只关心自己的触发条件和结果，没有任何一个服务会为整个业务链路负责</li>
</ul>
<h1 id="六、DDD-适合什么系统"><a href="#六、DDD-适合什么系统" class="headerlink" title="六、DDD 适合什么系统"></a>六、DDD 适合什么系统</h1><ul>
<li>DDD 的结构不像 MVC 结构那么简单，分层更加复杂。</li>
<li>消除信息不对称的成本比较大，需要多方人员协作讨论业务模型。</li>
<li>迭代快的小系统不如直接使用 MVC 做好代码规范能够更快地上线。<br><strong>因此，不适配 DDD 的系统是什么呢？</strong></li>
<li>中小规模的系统，本身业务体量小，功能单一，选择 MVC 架构无疑是最好的。</li>
<li>项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能（这种本身业务需求边界就不清晰，功能的可持续迭代性就很差，而且这种系统一般就是一口价买卖），这种也最好选择 MVC。<br>那相反地，适配 DDD 的系统是什么呢？<strong>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</strong><br>总而言之就是：</li>
<li>你还不了解 DDD 或者你们系统功能简单，就选择 MVC；</li>
<li>你不知道选用什么技术架构做开发，处于业务探索阶段，选用 MVC；</li>
<li>其他时候就酌情考虑 DDD。</li>
</ul>
<h1 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h1><p>以下链接，仅做记录，与学习顺序无关。<br><a href="https://zhuanlan.zhihu.com/p/434443923?utm_id=0">DDD架构使用Mapstruct - 知乎</a></p>
<p><a href="https://blog.csdn.net/kiwangruikyo/article/details/115252155">DDD—快速理解聚合根、实体、值对象的区别和联系_XXmaoxiaoXX的博客-CSDN博客_聚合根和实体</a></p>
<p><a href="https://blog.csdn.net/weixin_57907028/article/details/125451904">DDD概念复杂难懂，实际落地如何设计代码实现模型？_敲代码的程序狗的博客-CSDN博客_ddd代码落地</a></p>
<p><a href="https://space.bilibili.com/1578320/channel/collectiondetail?sid=313946&ctype=0">寒食君的个人空间_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.51cto.com/article/691070.html">DDD落地，如何持久化聚合-51CTO.COM</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/342826364">领域驱动设计在爱奇艺打赏业务的实践 - 知乎</a></p>
<p><a href="https://www.modb.pro/db/106275">DDD第七篇：资源库Repository的性能优化 - 墨天轮</a></p>
<p><a href="https://www.arcblock.io/blog/zh/post/2018/10/30/cqrs-commaded">浅谈查询职责分离(CQRS)模式</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/91525839">DDD 模式从天书到实践 - 知乎</a></p>
<p><a href="https://www.cnblogs.com/daoqidelv/p/7492322.html">【DDD】使用领域驱动设计思想实现业务系统 - 倒骑的驴 - 博客园</a></p>
<p><a href="https://www.cnblogs.com/Zachary-Fan/p/5991674.html">如何一步一步用DDD设计一个电商网站（一）—— 先理解核心概念 - Zachary_Fan - 博客园</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403892&idx=1&sn=a91fa477392e80f9420a8ca4d26bcace&chksm=83953c2cb4e2b53a6af3b5a82c3b7d7ed932bfe83f59877a935445ae89edd0ff4ee1c4e82fba&scene=21#wechat_redirect">阿里技术专家详解 DDD 系列- Domain Primitive</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650404060&idx=1&sn=cacf40d19528f6c2d9fd165151d6e8b4&chksm=83953cc4b4e2b5d2bd4426e0d2103f2e95715b682f3b7ff333dbb123eaa79d3e5ad24f64beac&scene=21#wechat_redirect">阿里技术专家详解DDD系列 第二弹 - 应用架构</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650406692&idx=1&sn=4a4ac4168299d8ca1905a4f457ae4c59&chksm=8395373cb4e2be2a2d066a5ea4e631fd6270e969ce61883b488f61c1ce33fbc0b362ec9cbf7b&scene=21#wechat_redirect">阿里技术专家详解DDD系列 第三讲 - Repository模式</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650414919&idx=1&sn=0ad1df1a1b0e2488f7faa21008fdbdd0&chksm=8396d75fb4e15e49341b07022780dcb8dca66a0efb7f129d4de86a5ef5d8a890f6e0d2fd6432&scene=21#wechat_redirect">DDD系列第四讲：领域层设计规范</a></p>
<p><a href="https://mp.weixin.qq.com/s/1rdnkROdcNw5ro4ct99SqQ">DDD系列第五讲：聊聊如何避免写流水账代码</a></p>
<p><a href="https://mp.weixin.qq.com/s/r-3D6unri7ZxIlxkpIGYZg">详解DDD“洋葱架构”</a></p>
<p><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html?utm_source=wechat_session&utm_medium=social&utm_oi=698166473230680064">领域驱动设计在互联网业务开发中的实践 - 美团技术团队</a></p>
<p><a href="https://zq99299.github.io/note-book2/ddd/00/#%E5%9F%BA%E7%A1%80%E7%AF%87">开篇 | 学好了 DDD，你能做什么？ | NOTE-BOOK2</a></p>
<p><a href="https://github.com/alibaba/COLA">alibaba&#x2F;COLA: 🥤 COLA: Clean Object-oriented &amp; Layered Architecture</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1791310">DDD领域驱动设计实战-理解聚合(Aggregate)和聚合根(AggregateRoot) - 腾讯云开发者社区-腾讯云</a></p>
<p><a href="https://space.bilibili.com/386239614/channel/collectiondetail?sid=677400">b_lorne的个人空间_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.bilibili.com/video/BV1jt4y1j73j?p=7">DDD：课前介绍_哔哩哔哩_bilibili</a></p>
<p><a href="https://mp.weixin.qq.com/s/HMLpjcE0UENUTfMK0Z9n8A">领域驱动设计DDD｜从入门到代码实践</a></p>
<h1 id="八、云原生架构"><a href="#八、云原生架构" class="headerlink" title="八、云原生架构"></a>八、云原生架构</h1><p>基于微服务原理而开发的应用，以容器方式打包。在运行时，容器由运行于云基础设施之上的平台进行调度。应用开发采用持续交付和 DevOps 实践。</p>
]]></content>
      <categories>
        <category>系统设计</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 核心编程思想笔记</title>
    <url>/MiracleDx/2022/05/21/Spring%20%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<ol>
<li>什么是 Spring Framework<br>《Spring 核心编程思想》第 12 讲</li>
<li>Spring Framework 有哪些核心模块</li>
</ol>
<ul>
<li>spring-core: Spring 基础 API 模块，如资源查找，泛型处理</li>
<li>spring-beans: Spring Bean 相关，如依赖查找，依赖注入</li>
<li>spring-aop: Spring AOP 处理，如动态代理，AOP 字节码提升</li>
<li>spring-context: 事件驱动、注解驱动，模块驱动等</li>
<li>spring-expression: Spring 表达式语言模块</li>
</ul>
<ol start="3">
<li>Spring Framework 的优势和不足是什么<br>《Spring 核心编程思想》全篇贯穿</li>
<li>IoC 编程思路有哪些实现方式</li>
</ol>
<ul>
<li>依赖查找（有侵入性，性能低）</li>
<li>依赖注入（侵入性小，性能高）</li>
<li>构造器注入</li>
<li>参数注入</li>
<li>Getter、Setter 注入</li>
<li>interface 注入</li>
<li>上下文依赖查询</li>
<li>模版方法设计模式（传统方式需要自己调用）</li>
<li>策略模式</li>
</ul>
<ol start="5">
<li>IoC 容器都有哪些职责</li>
</ol>
<h6 id="通用职责"><a href="#通用职责" class="headerlink" title="通用职责"></a>通用职责</h6><ul>
<li>依赖处理</li>
<li>依赖查找</li>
<li>依赖注入</li>
<li>生命周期管理</li>
<li>容器（容器自身的启动、停止等）</li>
<li>托管的资源（Java Beans 或其它资源 – 例：Spring 中的事件监听器、XML、properties等）</li>
<li>配置</li>
<li>容器（例：定时任务 – 容器通知什么时候执行）</li>
<li>外部化配置（属性配置 – 例：XML）</li>
<li>托管的资源（同上）<br>-Spring Boot 通过嵌入式的方式由 Spring 上下文影响到容器<br>-Spring MVC 是容器影响到 Spring MVC</li>
</ul>
<ol start="6">
<li>IoC 容器有哪些实现</li>
</ol>
<h6 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h6><ul>
<li>Java SE</li>
<li>Java Beans</li>
<li>Java ServiceLoader SPI</li>
<li>JNDI（Java Naming and Directory Interface）</li>
<li>Java EE</li>
<li>EJB（Enterpise Java Beans）</li>
<li>Servlet</li>
<li>开源</li>
<li>Apache Avalon</li>
<li>PicoContainer</li>
<li>Google Guice</li>
<li>Spring Framework</li>
</ul>
<ol start="7">
<li>Spring 中的容器应该怎么理解，有哪些类型的容器<br>容器指运行时启动的基础设施，比如传统 Spring MVC 在 Tomcat 容器或者 EJB 容器</li>
<li>传统 IoC 容器的实现</li>
</ol>
<h6 id="Java-Beans-作为IoC容器"><a href="#Java-Beans-作为IoC容器" class="headerlink" title="Java Beans 作为IoC容器"></a>Java Beans 作为IoC容器</h6><ul>
<li>特性</li>
<li>依赖查找</li>
<li>生命周期管理</li>
<li>配置元信息</li>
<li>事件</li>
<li>自定义</li>
<li>资源管理</li>
<li>持久化</li>
<li>规范</li>
<li>JavaBeans</li>
<li>BeanContext</li>
</ul>
<ol start="9">
<li>什么是 IoC<br> 简单的说，IoC 是反转控制，类似于好莱坞原则，主要有依赖查找和依赖注入实现</li>
<li>依赖查找和依赖注入的区别<br> 依赖查找是主动或手动的依赖查找方式，通常需要依赖容器或标准 API 实现<br> 依赖注入是手动或自动依赖绑定的方式，无需依赖特定的容器和 API 实现<br>11.Spring 作为 IoC 容器有什么优势<br> Spring 作为典型的 IoC 容器，具有依赖查找和依赖注入的功能。它还具有 AOP 抽象、事务抽象、事件机制、SPI 扩展、强大的第三方整合、易测试性、更好的面向对象<br>12.Spring IoC 依赖查找都有哪些方式</li>
</ol>
<ul>
<li>根据 Bean 名称查找</li>
<li>实时查找</li>
<li>延时查找</li>
<li>根据 Bean 类型查找</li>
<li>单个 Bean 对象</li>
<li>集合 Bean 对象</li>
<li>根据 Bean 名称 + 类型查找</li>
<li>根据 Java 注解查找</li>
<li>单个 Bean 对象</li>
<li>集合 Bean 对象<br>13.Spring Ioc 依赖注入</li>
<li>根据 Bean 名称注入</li>
<li>根据 Bean 类型注入</li>
<li>单个 Bean 对象</li>
<li>集合 Bean 对象</li>
<li>注入容器内建 Bean 对象</li>
<li>注入非容器内建 Bean 对象</li>
<li>注入类型</li>
<li>实时注入</li>
<li>延迟注入<br>14.Spring 容器依赖的三个来源</li>
<li>自定义 Bean，可以通过 getBean 方法获取</li>
<li>容器内建依赖的 Bean，如课程中的 useRepository 中的 BeanFactory，无法通过 getBean 方法获取，是通过 AutowireCapableFactory中的 resolveDependency 方法注册</li>
<li>依赖，被组合的对象</li>
<li>容器内建 Bean，如 Envrionment、BeanDefinitions 和 Singleton Objects 可以通过 getBean 获取</li>
<li>内建（Built-in），是由 Spring IoC 容器内部生成的 Bean 或组件<br>15.Spring IoC 配置元信息</li>
<li>Bean 定义配置</li>
<li>基于 XML 文件</li>
<li>基于 Properties 文件</li>
<li>基于 Java 注解</li>
<li>基于 Java API</li>
<li>基于 Groovy</li>
<li>IoC 容器配置</li>
<li>基于 XML 文件</li>
<li>基于 Java 注解</li>
<li>基于 Java API</li>
<li>外部化属性配置</li>
<li>基于 Java 注解<br>16.BeanFactory 和 ApplicationContext 有什么区别</li>
<li>ApplicationContext 是 BeanFactory的子接口</li>
<li>BeanFactory 是一个底层的 IoC 容器，提供了 IoC 容器的基本实现。而 ApplicationContext 是 BeanFactory 的超集，提供了丰富的企业级特性</li>
<li>ApplicationContext 委托 DefaultListableBeanFacory 实现 Bean 的依赖查找和依赖注入<br>17.AbstractApplicationContext#prepareBeanFactory 中指明 beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory)，说明当 byType 是 BeanFactory.class的时候，获取到的是 ApplicationContext 中的 DefaultListableBeanFactory 对象<br>18.什么是 Spring IoC 容器？<br>19.BeanFactory 和 Factory 有什么区别？<br> 1.BeanFactory 是 IoC 底层容器<br> 2.FactoryBean 是创建 Bean 的一种方式，帮助实现复杂的初始化逻辑<br> Spring Bean 的两种实现方式</li>
<li>普通 Bean</li>
<li>工厂 Bean (FactoryBean)<br> pojo 继承 FactoryBean，并实现其方法，当容器通过 getBean() 获取Bean 时，返回的是实现的 getObject() 方法返回的对象，该对象通过 getObjectType() 方法决定哪个对象被容器调用，当对象类型相同时再通过 isSingleton() 方法判断是不是同一个对象<br>20.Spring IoC 容器启动时做了哪些准备？<br> 1.IoC 配置元信息读取和解析<br> 2.IoC 容器生命周期<br> 3.Spring 事件发布<br> 4.国际化等</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表 - 1</title>
    <url>/MiracleDx/2019/08/19/Linked%20List/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表，判断链表中是否有环。</span><br><span class="line">为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p>示例3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p>进阶：<br>你能用 *O(1)*（即，常量）内存解决此问题吗？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义Set哈希表，存储所有经过的节点</li>
<li>如果哈希表中存在这个节点，则说明有环</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：-双指针"><a href="#方法二：-双指针" class="headerlink" title="方法二： 双指针"></a>方法二： 双指针</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义快慢指针，快指针每次进 1，慢指针每次进 2</li>
<li>当快慢指针的值相等时，说明有环</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>环形链表 - 2</title>
    <url>/MiracleDx/2019/08/20/Linked%20List/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141.环形链表"></a>141.环形链表</h1><p><strong>难度：中等</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><br><span class="line">为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</span><br><span class="line">说明：不允许修改给定的链表。</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p>示例 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p>示例 3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p>进阶：<br>你是否可以不用额外空间解决此题？</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-哈希表"><a href="#方法一：-哈希表" class="headerlink" title="方法一： 哈希表"></a>方法一： 哈希表</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义Set哈希表，存储所有经过的节点</li>
<li>如果哈希表中存在这个节点，则说明有环，返回该节点</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">       Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">       <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (set.contains(head)) &#123;</span><br><span class="line">               <span class="keyword">return</span> head;</span><br><span class="line">           &#125;</span><br><span class="line">           set.add(head);</span><br><span class="line">           head = head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义快慢指针，快指针每次进 1，慢指针每次进 2</li>
<li>当快慢指针的值相等时，说明有环</li>
<li>当出现环时，快慢指针可能不是在环点，所以将慢指针移回 head，使快慢指针步长一致</li>
<li>当快慢指针再次相遇时，即为环点</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序链表</title>
    <url>/MiracleDx/2019/07/02/Linked%20List/21.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21.合并两个有序链表"></a>21.合并两个有序链表</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-迭代"><a href="#方法一：-迭代" class="headerlink" title="方法一： 迭代"></a>方法一： 迭代</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义 prev 做为新链表头，定义 res 做为结果链表</li>
<li>判断 l1 和 l2 的值，将 prev.next 的指针指向数值小的值</li>
<li>跳出循环后，说明 l1 或者 l2 中有一个链表为空，则将 prev.next 指向剩下不为空的链表</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">                prev.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prev.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(m + n)，m 和 n 分别为 l1 和 l2 的长度</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>​	将两个链表中较小节点的数进行 merge</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(m + n)，m 和 n 分别为 l1 和 l2 的长度</li>
<li>空间复杂度：O(m + n)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转链表</title>
    <url>/MiracleDx/2019/08/31/Linked%20List/206.%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反转一个单链表。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-迭代"><a href="#方法一：-迭代" class="headerlink" title="方法一： 迭代"></a>方法一： 迭代</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>通过新构建一个链表完成反转</li>
<li>初始化一个空的 Linked List 头 prev</li>
<li>将当前节点的下一个节点指向 prev</li>
<li>将 prev 的指针指向新的翻转过的节点</li>
<li>将当前节点指向下一个要进行反转的节点</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head.next;</span><br><span class="line">            head.next = prev;</span><br><span class="line">            prev = head;</span><br><span class="line">            head = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>通过新构建一个链表完成反转</li>
<li>初始化一个空的 Linked List 头 prev</li>
<li>依次将 next 节点指向 prev</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverse(<span class="literal">null</span>, head);</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode prev, ListNode cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> prev;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = prev;</span><br><span class="line">        <span class="keyword">return</span> reverse(cur, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两两交换链表中的节点</title>
    <url>/MiracleDx/2019/08/11/Linked%20List/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><p><strong>难度：中等</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><br><span class="line">你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-迭代"><a href="#方法一：-迭代" class="headerlink" title="方法一： 迭代"></a>方法一： 迭代</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义一个 prev 做为反转后的链表， 定义 res 用于记录最后的结果</li>
<li>将 prev 的下一个节点指向头节点的下一个节点</li>
<li>将 head 的下一个节点指向下下个节点</li>
<li>再讲 prev 的下下个节点指向头节点</li>
<li>以上完成前两个元素的交换</li>
<li>将 prev 指针移动到交换后的第二个元素位置</li>
<li>将 head 指针移动到下一个元素位置</li>
<li>开始下一轮交换</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span> &amp;&amp; head.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            prev.next = head.next;</span><br><span class="line">            head.next = head.next.next;</span><br><span class="line">            prev.next.next = head;</span><br><span class="line">            prev = prev.next.next;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>将第一， 第二的指针互调</li>
<li>递归第三个节点的指针</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> head;</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> head.next;</span><br><span class="line">       first.next = swapPairs(head.next.next);</span><br><span class="line">       second.next = first;</span><br><span class="line">       <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>K个一组翻转链表</title>
    <url>/MiracleDx/2019/08/11/Linked%20List/25.K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><p><strong>难度：困难</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个链表，每k个节点一组进行翻转，请你返回翻转后的链表。</span><br><span class="line">k是一个正整数，它的值小于或等于链表的长度。</span><br><span class="line">如果节点总数不是k的整数倍，那么请将最后剩余的节点保持原有顺序。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line">当k= 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line">当k= 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li>你的算法只能使用常数的额外空间。</li>
<li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>声明一个 tail 链表 用于记录需要翻转的 k 个元素</li>
<li>当 tail &#x3D;&#x3D; null 时说明不够 k 个元素，直接返回其余元素</li>
<li>翻转 head 到 tail 之间的元素</li>
<li>递归寻找下一组元素，将翻转后的链表指向下一组元素，下一组元素的头部即是 tail 链表</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> head;</span><br><span class="line">            &#125;</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> revese(head, tail);</span><br><span class="line">        head.next = reverseKGroup(tail, k);</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode <span class="title function_">revese</span><span class="params">(ListNode cur, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/MiracleDx/2019/03/12/Array/1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><p>**难度：简单 **</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-暴力破解-双重循环"><a href="#方法一：-暴力破解-双重循环" class="headerlink" title="方法一： 暴力破解-双重循环"></a>方法一： 暴力破解-双重循环</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>通过双重循环取得满足 nums[i] + nums[j] = target 的下标
</code></pre>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n^2)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：哈希表-双重循环"><a href="#方法二：哈希表-双重循环" class="headerlink" title="方法二：哈希表-双重循环"></a>方法二：哈希表-双重循环</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>先循环一次将所有数值存入哈希表中，key 为值，value 为所在数组下标</li>
<li>再循环一次，查看符合条件的数值是否存在哈希表中，存在即可返回</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.get(result) != <span class="literal">null</span> &amp;&amp; map.get(result) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, map.get(result)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：哈希表-单循环"><a href="#方法二：哈希表-单循环" class="headerlink" title="方法二：哈希表-单循环"></a>方法二：哈希表-单循环</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><ol>
<li>循环的同时将数值存入哈希表中，key 为值，value 为所在数组下标</li>
<li>同时判断符合条件的数值是否存在哈希表中，存在即可返回</li>
<li>由于先符合的数值的下标存储在哈希表中，所以返回时先返回哈希表中存储的数值</li>
</ol>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.get(result) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(result), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>盛水最多的容器</title>
    <url>/MiracleDx/2019/03/19/Array/11.%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h1 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11.盛水最多的容器"></a>11.盛水最多的容器</h1><p><strong>难度：中等</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>    说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-暴力破解法"><a href="#方法一：-暴力破解法" class="headerlink" title="方法一： 暴力破解法"></a>方法一： 暴力破解法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>容纳最多的水实际为求容器的最大面积，且该面积取决于宽不变的情况下，最短的高的长度。即<strong>面积&#x3D;数组索引值的差（宽） * 最小数组索引值（左右高度的最小值）</strong></li>
<li>通过双重循环，及变量max，求得最大面积</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">               max = Math.max((j - i) * Math.min(height[j], height[i]), max);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n^2)，双重循环需要遍历两遍height数组</li>
<li>空间复杂度：O(1)，没有使用额外的内存空间</li>
</ol>
<h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>通过双指针分别从起始位置，和结束位置向中间步进</li>
<li>由于宽度不变的情况下，取决于高的长度，即每次移动最小高度的指针</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.length -<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> (j - i) * Math.min(height[i], height[j]);</span><br><span class="line">           max = Math.max(area, max);</span><br><span class="line">           <span class="keyword">if</span> (height[i] &lt; height[j]) &#123;</span><br><span class="line">               i++;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               j--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.length -<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">minHeight</span> <span class="operator">=</span>  height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">           <span class="comment">// 由于上一行的 ++ 和 -- 操作导致宽度减少 需要在这里补回</span></span><br><span class="line">           max = Math.max((j - i + <span class="number">1</span>) * minHeight, max);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)，只需要遍历一次height数组</li>
<li>空间复杂度：O(1)，没有使用额外的内存空间</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>三数之和</title>
    <url>/MiracleDx/2019/03/27/Array/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15.三数之和"></a>15.三数之和</h1><p><strong>难度：中等</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>答案中不可以包含重复的三元组。</p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-暴力破解法-三重循环"><a href="#方法一：-暴力破解法-三重循环" class="headerlink" title="方法一： 暴力破解法-三重循环"></a>方法一： 暴力破解法-三重循环</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>​	通过三重循环，取出所有符合条件的答案</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">##### 复杂度分析</span><br><span class="line"><span class="number">1.</span> 时间复杂度：O(n^<span class="number">3</span>)</span><br><span class="line"><span class="number">2.</span> 空间复杂度：O(<span class="number">1</span>)</span><br><span class="line">#### 方法二：双指针遍历</span><br><span class="line">##### 思路</span><br><span class="line"> 	<span class="number">1.</span> 先将数组进行排序</span><br><span class="line"> 	<span class="number">2.</span> 将最小数固定指针，分别使用快慢指针从数组起始位置 + <span class="number">1</span>和终点位置向中进行遍历</span><br><span class="line"> 	<span class="number">3.</span> 寻找满足 nums[k] + nums[i] + nums[j] = <span class="number">0</span> 的组合</span><br><span class="line">##### 代码</span><br><span class="line">```java</span><br></pre></td></tr></table></figure>
<p>简化后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：</li>
<li>空间复杂度：</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组</title>
    <url>/MiracleDx/2019/05/08/Array/189.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189.旋转数组"></a>189.旋转数组</h1><p><strong>难度：中等</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p>示例 2:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<ol>
<li><p>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</p>
</li>
<li><p>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</p>
</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-暴力破解法"><a href="#方法一：-暴力破解法" class="headerlink" title="方法一： 暴力破解法"></a>方法一： 暴力破解法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>​	依次和最后一个位置的元素交换位置</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[nums.length - <span class="number">1</span>];</span><br><span class="line">                nums[nums.length - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进阶</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">swap</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = swap;</span><br><span class="line">                swap = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n * k)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：k次反转"><a href="#方法二：k次反转" class="headerlink" title="方法二：k次反转"></a>方法二：k次反转</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><pre><code>1. 三次旋转
 2. 先将整个数组旋转
 3. 将前k个元素旋转
 4. 将剩余元素旋转
</code></pre>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k %= nums.length;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start] = nums[end];</span><br><span class="line">            nums[end] = temp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序数组中的重复项</title>
    <url>/MiracleDx/2019/04/05/Array/26.%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26.删除排序数组中的重复项"></a>26.删除排序数组中的重复项</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</span><br><span class="line">不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1,1,2], </span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p>说明:<br>为什么返回数值是整数，但输出的答案是数组呢?<br>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。<br>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>定义 i 和 j 的快慢指针， i 为慢指针， j 为快指针</li>
<li>当 nums[i] 和 nums[j] 相等时，慢指针不动，快指针继续前进</li>
<li>当 nums[i] 和 nums[j] 不相等时，更新慢指针的下一个值</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[j]) &#123;</span><br><span class="line">                nums[++i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/MiracleDx/2019/06/11/Array/283.%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283.移动零"></a>283.移动零</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-双迭代法"><a href="#方法一：-双迭代法" class="headerlink" title="方法一： 双迭代法"></a>方法一： 双迭代法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>先通过一次循环确定非零元素，并将非零元素全部赋值到前部</li>
<li>再通过一次循环，将剩余的元素置零</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">               nums[j++] = nums[i];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> j; i &lt; nums.length; i++) &#123;</span><br><span class="line">           nums[i] = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：双指针-快慢指针"><a href="#方法二：双指针-快慢指针" class="headerlink" title="方法二：双指针-快慢指针"></a>方法二：双指针-快慢指针</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>由于只需要保证考虑非零元素的顺序，所以可以定义一个慢指针记录非零元素的位置</li>
<li>当快指针经过非零元素的时候，将值赋值给慢指针，同时将快指针所处的位置置0</li>
<li>慢指针在快指针经过非0元素时，进1</li>
<li>由于存在快慢指针存在同一下标的情况，所以当快慢指针不相等时，才操作数组</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">           <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (i != j) &#123;</span><br><span class="line">                   nums[j] = nums[i];</span><br><span class="line">                   nums[i] = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               j++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>整数数组加一</title>
    <url>/MiracleDx/2019/04/12/Array/66.%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<h1 id="Leetcode"><a href="#Leetcode" class="headerlink" title="Leetcode"></a>Leetcode</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</span><br><span class="line">最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><br><span class="line">你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>逆序遍历数组，数值 + 1 只有两种情况<ol>
<li>大于 10 需要进 1 处理前一位的数值</li>
<li>小于 10 ，可以直接返回</li>
</ol>
</li>
<li>当数组数值全部为 9 时，需要对数组进行扩容</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            digits[i]++;</span><br><span class="line">            digits[i] %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="title class_">int</span>[digits.length + <span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>爬楼梯</title>
    <url>/MiracleDx/2019/04/21/Array/70.%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line">注意：给定 n 是一个正整数。</span><br></pre></td></tr></table></figure>
<p>示例1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-递归"><a href="#方法一：-递归" class="headerlink" title="方法一： 递归"></a>方法一： 递归</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>每次可以爬一阶或者两阶，说明不论有多少楼梯，最后爬的一定是一阶或者二阶</li>
<li>那么爬第三阶楼梯的时候，只能是爬一阶或者爬两阶</li>
<li>爬一阶的时候，之前已经爬过了两阶；爬二阶之前已经爬过了一阶，即：爬三阶 &#x3D; 爬二阶的方法 + 爬一阶的方法</li>
<li>那么爬四阶楼梯的时候，爬四阶 &#x3D; 爬三阶的方法 + 爬二阶的方法</li>
<li>依次类推，可以得到递推公式 f(n) &#x3D; f(n - 1) + f(n - 2)</li>
<li>根据递推公式可知，该题目实际为求<strong>斐波那契数列</strong></li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(2^n)，由于每次递归都会导致之前计算过的方法被重新计算</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：递归加强版（求最小重复子问题）"><a href="#方法二：递归加强版（求最小重复子问题）" class="headerlink" title="方法二：递归加强版（求最小重复子问题）"></a>方法二：递归加强版（求最小重复子问题）</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>​	由于递归会导致重复计算，所以可以使用一个容器存储已经计算过的方法</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> climb(record, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">climb</span><span class="params">(<span class="type">int</span>[] record, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[n] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> record[n];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        record[n] = climb(record, n - <span class="number">1</span>) + climb(record, n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> record[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，只用了常数个变量作为辅助空间</li>
</ol>
<h4 id="方法三：动态规划"><a href="#方法三：动态规划" class="headerlink" title="方法三：动态规划"></a>方法三：动态规划</h4><h5 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h5><p>​	由以上分析可知，该题目的动态转移方程为：dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)，只用了常数个变量作为辅助空间</li>
</ol>
<h4 id="方法四：迭代"><a href="#方法四：迭代" class="headerlink" title="方法四：迭代"></a>方法四：迭代</h4><h5 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h5><p>​	使用迭代的方式，滚动赋值给前一阶和前两阶的数值</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> n;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> l1 + l2;</span><br><span class="line">           l1 = l2;</span><br><span class="line">           l2 = result;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>合并两个有序数组</title>
    <url>/MiracleDx/2019/04/29/Array/88.%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><p><strong>难度：简单</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span><br><span class="line">说明:</span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：-利用库函数"><a href="#方法一：-利用库函数" class="headerlink" title="方法一： 利用库函数"></a>方法一： 利用库函数</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>先将两个数组合并</li>
<li>利用库函数进行排序</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">		System.arraycopy(nums2, <span class="number">0</span>, nums1, m, n);</span><br><span class="line">    	Arrays.sort(nums1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
<h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><ol>
<li>两个指针 i 和 j 分别逆序遍历 nums1 和 nums2 数组，从大到小依次逆序插入到 nums1 中</li>
<li>l 用于记录 nums1 插入数值的位置</li>
<li>当 nums2 遍历完成时，说明已经将 nums2 的元素全部插入到 nums1 中</li>
<li>插入哪个 nums 数组的数据就将对应 nums 数组的指针相应 -1， 同时 l 也相应 -1</li>
</ol>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">                nums1[l] = nums1[i];</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[l] = nums2[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            l--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[l--] = i &gt;= <span class="number">0</span>  &amp;&amp; nums1[i] &gt;= nums2[j] ? nums1[i--] : nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进一步简化：将 i 和 j 的值 由 m 和 n 代替</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> m-- + n-- - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[l--] = (m &gt;= <span class="number">0</span>  &amp;&amp; nums1[m] &gt;= nums2[n]) ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终极版：n– - 1 的实际效果 等于 –n</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> m-- + --n;</span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[l--] = (m &gt;= <span class="number">0</span>  &amp;&amp; nums1[m] &gt;= nums2[n]) ? nums1[m--] : nums2[n--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ol>
<li>时间复杂度：O(n)</li>
<li>空间复杂度：O(1)</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
