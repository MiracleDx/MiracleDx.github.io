<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>领域驱动设计 | wecode</title><meta name="author" content="Dongx"><meta name="copyright" content="Dongx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="领域驱动设计 Domain Drive Design一、什么是领域驱动设计DDD 是一种开展业务建模和软件设计的方法论。DDD 基于领域建模而非数据建模，它使业务逻辑高度内聚，与基础设施、框架解耦，清晰的领域边界解决微服务的拆分问题。是一种设计思想，而非应用架构。面向接口、以业务为核心驱动，自顶向下的进行业务领域划分的架构设计模式。  DDD的架构能够有效的解决传统架构中的问题：  高可维护性：当">
<meta property="og:type" content="article">
<meta property="og:title" content="领域驱动设计">
<meta property="og:url" content="https://github.com/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/index.html">
<meta property="og:site_name" content="wecode">
<meta property="og:description" content="领域驱动设计 Domain Drive Design一、什么是领域驱动设计DDD 是一种开展业务建模和软件设计的方法论。DDD 基于领域建模而非数据建模，它使业务逻辑高度内聚，与基础设施、框架解耦，清晰的领域边界解决微服务的拆分问题。是一种设计思想，而非应用架构。面向接口、以业务为核心驱动，自顶向下的进行业务领域划分的架构设计模式。  DDD的架构能够有效的解决传统架构中的问题：  高可维护性：当">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/images/avatar.jpg">
<meta property="article:published_time" content="2024-01-16T16:00:00.000Z">
<meta property="article:modified_time" content="2024-01-16T16:00:00.000Z">
<meta property="article:author" content="Dongx">
<meta property="article:tag" content="DDD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/images/avatar.jpg"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="canonical" href="https://github.com/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":5,"languages":{"author":"作者: Dongx","link":"链接: ","source":"来源: wecode","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '领域驱动设计',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-17 00:00:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><script src="/styles/fish.js"></script><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><link rel="stylesheet" href="/styles/main.css"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 7.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/avatar.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="wecode"><span class="site-name">wecode</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">领域驱动设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-16T16:00:00.000Z" title="发表于 2024-01-17 00:00:00">2024-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-16T16:00:00.000Z" title="更新于 2024-01-17 00:00:00">2024-01-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="领域驱动设计"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="领域驱动设计-Domain-Drive-Design"><a href="#领域驱动设计-Domain-Drive-Design" class="headerlink" title="领域驱动设计 Domain Drive Design"></a>领域驱动设计 Domain Drive Design</h1><h1 id="一、什么是领域驱动设计"><a href="#一、什么是领域驱动设计" class="headerlink" title="一、什么是领域驱动设计"></a>一、什么是领域驱动设计</h1><p>DDD 是一种<strong>开展业务建模和软件设计的方法论</strong>。DDD 基于领域建模而非数据建模，它使业务逻辑高度内聚，与基础设施、框架解耦，清晰的领域边界解决微服务的拆分问题。<br>是一种设计思想，而非应用架构。<br>面向接口、以业务为核心驱动，自顶向下的进行业务领域划分的架构设计模式。</p>
<blockquote>
<p>DDD的架构能够有效的解决传统架构中的问题：</p>
<ul>
<li>高可维护性：当外部依赖变更时，内部代码只用变更跟外部对接的模块，其他业务逻辑不变。</li>
<li>高可扩展性：做新功能时，绝大部分的代码都能复用，仅需要增加核心业务逻辑即可。</li>
<li>高可测试性：每个拆分出来的模块都符合单一性原则，绝大部分不依赖框架，可以快速的单元测试，做到100%覆盖。</li>
<li>代码结构清晰：通过 POM module 可以解决模块间的依赖关系， 所有外接模块都可以单独独立成 Jar 包被复用。当团队形成规范后，可以快速的定位到相关代码。</li>
</ul>
</blockquote>
<h1 id="二、基础概念"><a href="#二、基础概念" class="headerlink" title="二、基础概念"></a>二、基础概念</h1><p><img src="https://cdn.jsdelivr.net/gh/MiracleDx/images_repo@main/dc32e8e4a317fe00121ce18adc407c66.dc32e8e4.jpg" alt="img"><br>战略和战术设计是站在DDD的角度进行划分。</p>
<ul>
<li>战略设计侧重于高层次、宏观上去划分和集成限界上下文。</li>
<li>战术设计则关注更具体使用建模工具来细化上下文。</li>
</ul>
<h2 id="2-1、战略设计"><a href="#2-1、战略设计" class="headerlink" title="2.1、战略设计"></a>2.1、战略设计</h2><p>战略设计包括：限界上下文、通用语言、子域。<br>从业务出发，建立业务模型，划分业务边界。</p>
<h3 id="2-1-1、限界上下文-Context-Bounds"><a href="#2-1-1、限界上下文-Context-Bounds" class="headerlink" title="2.1.1、限界上下文 - Context Bounds"></a>2.1.1、限界上下文 - Context Bounds</h3><p>限界上下文就是软件对于问题域的一个特定的、有限的解决方案。<br>用来封装通用语言和领域对象，提供上下文环境，保证域内的一些术语、业务相关对象等有一个确切的含义，没有二义性。这个边界定义了模型的适用性范围。<br>是业务概念的边界，是业务问题最小粒度的划分。每一个限界上下文的内部必须是紧密组织的、职责明确的、具有较高的内聚性。<br>以子域为中心进行建模，绘制出一张一张的领域模型设计，被称为限界上下文。<br>是一个显式的语义和语境上的边界，领域模型便存在于边界之内。边界内，通用语言中的所有术语和词组都有特定的含义。<br>每个模型的应用范围，在每个Bounded Context中确保领域模型的一致性。不同的限界上下文中，领域模型可以不用保证一致性<br>一个由显示边界限定的特定职责。领域模型便存在于这个边界之内。在边界内，每一个模型概念，包括它的属性和操作，都具有特殊的含义<br>一个给定的业务领域会包含多个限界上下文，想与一个限界上下文沟通，则需要通过显示边界进行通信。系统通过确定的限界上下文来进行解耦，而每一个上下文内部紧密组织，职责明确，具有较高的内聚性。<br>限定上下文定义领域边界。<br>限界上下文可以拆解为两个词：限界和上下文</p>
<ul>
<li>限界：领域的边界</li>
<li>上下文：语义环境<br>定义：用来封装通用语言和领域对象，提供上下文环境，保证在领域内的一些术语、业务相关对象（通用语言）等有一个确切的含义，没有二义性。边界确定了模型的适用范围，使团队内所有成员能够明确知道什么应该在模型中实现，什么不应该在模型中实现。</li>
</ul>
<h3 id="2-1-2、通用语言"><a href="#2-1-2、通用语言" class="headerlink" title="2.1.2、通用语言"></a>2.1.2、通用语言</h3><p>能够简单、清晰、准确描述业务含义和规则，让项目参与人员都能达成共识的语言。<br>通用语言定义上下文含义。</p>
<h3 id="2-1-3、领域"><a href="#2-1-3、领域" class="headerlink" title="2.1.3、领域"></a>2.1.3、领域</h3><p>领域是一个组织所做的事情以及其中包含的一切。每个公司或组织都有自己的业务范围，这个业务范围以及在其中所进行的活动就是领域。<br>DDD 会将问题范围限定在特定的边界内，在这个边界内建立领域模型，从而用代码实现该领域模型，解决相应的业务问题。<br>DDD 的领域就是边界内要解决的业务问题域。</p>
<h4 id="2-1-3-1、子域"><a href="#2-1-3-1、子域" class="headerlink" title="2.1.3.1、子域"></a>2.1.3.1、子域</h4><p>子域是更为细分的领域。可以把域划分为更多的子域。子域的集合就是领域。<br>在 DDD 中一个领域被分成若干小的域，这些小的域就被称为子域。通常在开发领域模型时，关注的都是子域的业务功能。<br>通过领域划分，区分不同子域的功能属性和重要性，从而在系统建设过程中，根据预算和资源，对不同类型的子域采取不同的关注度和资源投入策略。</p>
<h4 id="2-1-3-2、核心子域"><a href="#2-1-3-2、核心子域" class="headerlink" title="2.1.3.2、核心子域"></a>2.1.3.2、核心子域</h4><p>是整个业务系统的核心，所有的业务都要围绕着核心业务领域展开。<br>决定产品和公司核心竞争力的子域是核心域，是业务成功的主要因素和公司的核心竞争力。</p>
<h4 id="2-1-3-3、通用子域"><a href="#2-1-3-3、通用子域" class="headerlink" title="2.1.3.3、通用子域"></a>2.1.3.3、通用子域</h4><p>常见的、不同领域都可共用的领域。例如：认证、授权等。<br>没有太多个性化的诉求，同时被多个子域使用的具备通用功能的子域。</p>
<h4 id="2-1-3-4、支撑子域"><a href="#2-1-3-4、支撑子域" class="headerlink" title="2.1.3.4、支撑子域"></a>2.1.3.4、支撑子域</h4><p>非核心域、非通用子域，具有个性化需求，不包含核心竞争力的功能，也不包含通用的功能，但是是必须的支撑，用于支撑核心域运作。</p>
<h2 id="2-2、战术设计"><a href="#2-2、战术设计" class="headerlink" title="2.2、战术设计"></a>2.2、战术设计</h2><p>战术设计包括：聚合、实体、值对象、资源库、领域服务、领域事件、模块。<br>经过战略设计后，领域有了清晰的边界。需要对领域进行业务映射。<br>根据业务模型进行技术实现，完成微服务的设计、开发及落地。</p>
<h3 id="2-2-1、聚合-Aggregate"><a href="#2-2-1、聚合-Aggregate" class="headerlink" title="2.2.1、聚合 - Aggregate"></a>2.2.1、聚合 - Aggregate</h3><p>是领域对象的显示分组，用于支持领域模型的行为和不变形，同时充当一致性和事务性边界。<br>聚合 &#x3D; 关联性极强、生命周期一致的实体、值对象组合成的对象。<br>负责封装业务逻辑，内聚决策命令和领域事件，容纳实体、聚合根、值对象<br>聚合是一组相关对象的组合，做为一个整体被外界访问。<br>一个聚合就是一个包，里面包括:</p>
<ul>
<li>领域服务</li>
<li>工厂</li>
<li>资源库</li>
<li>聚合根</li>
<li>实体</li>
<li>值对象</li>
<li>领域事件<br>一个限界上下文可能包含多个聚合，但一个聚合只能存在于一个限界上下文<br>聚合用来确保实体和值对象在实现共同的业务逻辑时，能够保证数据的一致性，是由业务和逻辑紧密关联的实体和值对象组合而成的，是数据修改和持久化的基本单元，每一个聚合对应一个仓储，实现数据的持久化。<br>聚合由一个聚合根和上下文边界，这个边界根据业务单一职责和高内聚原则，定义了聚合内部应该包含哪些实体和值对象，聚合之间的边界是松耦合的。<br>如何创建好的聚合？</li>
<li>边界内的内容具有一致性：在一个事务中只修改一个聚合实例。如果发现边界内很难接受强一致，不管是出于性能或产品需求的考虑，应该考虑剥离出独立的聚合，采用最终一致的方式。</li>
<li>设计小聚合：大部分的聚合都可以只包含根实体，而无需包含其他实体。即使一定要包含，可以考虑将其创建为值对象。</li>
<li>通过唯一标识来引用其他聚合或实体：当存在对象之间的关联时，建议引用其唯一标识而非引用其整体对象。如果是外部上下文中的实体，引用其唯一标识或将需要的属性构造值对象。 如果聚合创建复杂，推荐使用工厂方法来屏蔽内部复杂的创建逻辑。<br>聚合内部多个组成对象的关系可以用来指导数据库创建，但不可避免存在一定的抗阻。如聚合中存在 List&lt;值对象&gt;，那么在数据库中建立 1:N 的关联需要将值对象单独建表，此时是有 id 的，建议不要将该 id 暴露到资源库外部，对外隐蔽。</li>
</ul>
<h3 id="2-2-2、聚合根-Aggregate-Root"><a href="#2-2-2、聚合根-Aggregate-Root" class="headerlink" title="2.2.2、聚合根 - Aggregate Root"></a>2.2.2、聚合根 - Aggregate Root</h3><p>聚合根的目的是为了避免由于复杂数据模型缺少统一的业务规则控制，而导致聚合、实体之间数据不一致性的问题。<br>聚合根不仅是实体，还是聚合的管理者。<br>聚合根在聚合内对实体和值对象采用直接对象引用的方式进行组织和协调，聚合根与聚合根之间通过 ID 关联的方式实现聚合之间的协同。<br>是聚合中最具代表性的实体，是一个聚合的根节点<br>核心领域通常是用聚合来表达，聚合在技术上也有非常高的价值，可以指导详细设计。<br>聚合由根实体、实体、值对象组成。</p>
<ul>
<li>聚合根不能直接操作其它聚合根，聚合根与聚合根之间只能通过聚合根 ID 引用。</li>
<li>同限界上下文内的聚合之间的领域服务可以直接调用。</li>
<li>两个限界上下文的交互必须通过应用服务层抽离接口，通过防腐层适配。</li>
</ul>
<h3 id="2-2-3、实体-Entity"><a href="#2-2-3、实体-Entity" class="headerlink" title="2.2.3、实体 - Entity"></a>2.2.3、实体 - Entity</h3><p>由属性和行为组成，具有唯一标识且是可持续变化的。有自己的一整套生命周期，在生命周期内，无论怎么变化，仍旧是同一个实体。可变性反映了实体本身的状态和行为。<br>实体 &#x3D; 唯一身份标识 + 可变性 【状态 + 行为】<br>实体依附于聚合根，其生命周期由聚合根管理，一般会持久化，但与数据库持久化对象不一定是一对一的关系。实体可以引用聚合内的聚合根、实体和值对象</p>
<h4 id="2-2-3-1、失血模型"><a href="#2-2-3-1、失血模型" class="headerlink" title="2.2.3.1、失血模型"></a>2.2.3.1、失血模型</h4><h4 id="2-2-3-2、贫血模型"><a href="#2-2-3-2、贫血模型" class="headerlink" title="2.2.3.2、贫血模型"></a>2.2.3.2、贫血模型</h4><h4 id="2-2-3-3、充血模型"><a href="#2-2-3-3、充血模型" class="headerlink" title="2.2.3.3、充血模型"></a>2.2.3.3、充血模型</h4><h4 id="2-2-3-4、胀血模型"><a href="#2-2-3-4、胀血模型" class="headerlink" title="2.2.3.4、胀血模型"></a>2.2.3.4、胀血模型</h4><h3 id="2-2-4、值对象-Value-Object"><a href="#2-2-4、值对象-Value-Object" class="headerlink" title="2.2.4、值对象 - Value Object"></a>2.2.4、值对象 - Value Object</h3><p>通过对象属性值来识别的对象，它将多个相关属性做为一个概念整体。<br>当只关心某个对象的属性时，该对象便可以做为一个值对象。<br>需要将值对象看成不变对象，值对象不具备任何身份标识，应该尽量避免像实体对象一样的复杂性。<br>值对象 &#x3D; 将值用对象的方式进行表述，表达一个具体的固定不变的概念<br>实体的附加业务概念，用于描述实体所包含的业务信息。没有唯一标识，具有可度量或者可描述的，并满足不变形的对象。<br>需要保证值对象创建后就不能被修改，即不允许外部再修改其属性。<br>数据集被整体创建，整体读取，修改需求少时可以设计成值对象<br>值对象之间通过属性值判断相等性</p>
<blockquote>
<p>常见的 Value Object 的使用场景</p>
<ul>
<li>有格式限制的 String，比如 Name、PhoneNumber、Address 等</li>
<li>有限制的 Integer，如 OrderId（&gt; 0）、Percentage（0-100%） 等</li>
<li>可枚举的 int，比如 Status （因为反序列化问题一般不用 Enum ）</li>
<li>Double 或 BigDecimal，一般用到的 Double 或 BigDecimal 都是有业务含义的，比如 Money、Amount、Rating 等</li>
<li>复杂的数据结构，比如 <code>Map&lt;String, List&lt;Integer&gt;&gt;</code> 等，尽量把 Map 的所有操作包装，仅暴露必要行为</li>
</ul>
</blockquote>
<h3 id="2-2-5、资源库-Repository"><a href="#2-2-5、资源库-Repository" class="headerlink" title="2.2.5、资源库 - Repository"></a>2.2.5、资源库 - Repository</h3><p>是聚合根的容器，只提供持久化聚合根的操作（新增&#x2F;更新）以及提供根据 ID 获取聚合根的查询操作。资源库将聚合根的存储与存储中间件解耦，可以根据业务特性选择关系型数据库或者非关系型数据库存储聚合根。<br>在所有的领域对象中，只有聚合根才拥有 Repository，Repository 的职责是向领域模型提供聚合根。<br>在存储聚合根时，可能需要将聚合根及聚合根下的多个实体拆分到多个表存储，可能导致每次 Save 聚合根都需要执行多条 Update 语句。</p>
<blockquote>
<p>为了解决关系数据库做为聚合根容器导致的性能问题，有两种解决方式</p>
<ol>
<li>基于 Snapshot 方案：当数据从 DB 中取出来后，在内存中保存一份 Snapshot，然后在数据写入时和 Snapshot 比较。例如：Hibernate。</li>
<li>基于 Proxy 方案：当数据从 DB 中取出来后，通过 weaving 的方式将所有 Setter 都增加一个切面用于判断 Setter 是否被调用以及值是否变更，如果变更则标记为 Dirty，在保存时，根据 Dirty 判断是否需要更新。例如 Entity Framework。</li>
</ol>
</blockquote>
<h3 id="2-2-6、领域服务"><a href="#2-2-6、领域服务" class="headerlink" title="2.2.6、领域服务"></a>2.2.6、领域服务</h3><p>理想状况是没有领域服务<br>表示一个无状态的操作，用于实现特定于某个领域的任务。当某个操作不适合放在聚合和值对象上时，需要使用领域服务。<br>可以使用领域服务的情况：</p>
<ol>
<li>执行一个显著的业务操作</li>
<li>对领域对象进行转换</li>
<li>以多个领域对象作为参数进行计算，结果产生一个值对象</li>
</ol>
<h3 id="2-2-7、领域事件"><a href="#2-2-7、领域事件" class="headerlink" title="2.2.7、领域事件"></a>2.2.7、领域事件</h3><p>领域事件是对领域内发生的活动进行的建模<br>是一个领域模型中极其重要的部分，用来表示领域中发生的事件。在领域中发生的一些事件，通常将领域事件用于维护事件的一致性。<br>领域事件 &#x3D; 事件发布 + 事件存储 + 事件分发 + 事件处理</p>
<h3 id="2-2-8、工厂"><a href="#2-2-8、工厂" class="headerlink" title="2.2.8、工厂"></a>2.2.8、工厂</h3><p>工厂提供一个创建对象的接口，该接口封住了所有创建对象的复杂操作过程。</p>
<ul>
<li>领域模型中的工厂</li>
<li>将创建复杂对象和聚合的职责分配给一个单独的对象，并不承担领域模型中的职责，是领域设计中的一部分。</li>
<li>对于聚合来说，应该一次性的创建整个聚合，并且确保它的不变条件得到满足。</li>
<li>工厂只承担创建模型的工作，不具有其它领域行为。</li>
<li>一个含有工厂方法的聚合根的主要职责是完成它的聚合行为。</li>
<li>在聚合上使用工厂方法能更好的表达通用语言，这是使用构造函数不能表达的。</li>
<li>聚合根中的工厂方法</li>
<li>表现出了领域感念。</li>
<li>可以提供守卫措施。</li>
<li>领域服务中的工厂</li>
<li>在集成限界上下文时，领域服务做为工厂。</li>
<li>领域服务的接口放在领域模型内，实现放在基础设施层。</li>
</ul>
<h3 id="2-2-9、应用服务"><a href="#2-2-9、应用服务" class="headerlink" title="2.2.9、应用服务"></a>2.2.9、应用服务</h3><p>是用来表达用例和用户故事的主要手段<br>不处理业务逻辑，只负责对领域服务、聚合根方法的编排和转发，将要实现的功能委托给一个或多个领域对象来实现，本身只负责处理业务用例的执行顺序以及结果的拼装。</p>
<h2 id="2-3、CQE-模式"><a href="#2-3、CQE-模式" class="headerlink" title="2.3、CQE 模式"></a>2.3、CQE 模式</h2><p>CQE 即 Command、Query、Event。接收写请求使用 Command，接收查询请求使用 Query，消费事件使用 Event。<br>除 Event 外，所有写都使用 Command 接收参数，所有查询都是用 Query，只在参数只有一个 ID 的查询情况下，可以省略 Query。</p>
<h3 id="2-3-1、CQE-的规范"><a href="#2-3-1、CQE-的规范" class="headerlink" title="2.3.1、CQE 的规范"></a>2.3.1、CQE 的规范</h3><p>CQE 和 DTO 的区别</p>
<ul>
<li>CQE：CQE对象是ApplicationService的输入，是有明确的”意图“的，所以这个对象必须保证其”正确性“。</li>
<li>DTO：DTO对象只是数据容器，只是为了和外部交互，所以本身不包含任何逻辑，只是贫血对象。</li>
</ul>
<p><strong>规范：</strong>CQE 对象的校验应该前置，避免在 ApplicationService 里做参数的校验。可以通过 JSR303&#x2F;380 和 Spring Validation 来实现<br>从本质上来看，这几种对象都是 Value Object，但是从语义上来看有比较大的差异：</p>
<ul>
<li>Command 指令：指调用方明确想让系统操作的指令，其预期是对一个系统有影响，也就是写操作。通常来讲指令需要有一个明确的返回值（如同步的操作结果，或异步的指令已经被接受）。</li>
<li>Query 查询：指调用方明确想查询的东西，包括查询参数、过滤、分页等条件，其预期是对一个系统的数据完全不影响的，也就是只读操作。</li>
<li>Event 事件：指一件已经发生过的既有事实，需要系统根据这个事实作出改变或者响应的，通常事件处理都会有一定的写操作。事件处理器不会有返回值。这里需要注意一下的是，Application层的Event概念和Domain层的DomainEvent是类似的概念，但不一定是同一回事，这里的Event更多是外部一种通知机制而已。</li>
</ul>
<table>
<thead>
<tr>
<th>Command</th>
<th>Query</th>
<th>Event</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>语意</td>
<td>”希望“能触发的操作</td>
<td>各种条件的查询</td>
<td>已经发生过的事情</td>
</tr>
<tr>
<td>读&#x2F;写</td>
<td>写</td>
<td>只读</td>
<td>通常是写</td>
</tr>
<tr>
<td>返回值</td>
<td>DTO 或 Boolean</td>
<td>DTO 或 Collection</td>
<td>Void</td>
</tr>
</tbody></table>
<h2 id="2-4、CQRS-模式"><a href="#2-4、CQRS-模式" class="headerlink" title="2.4、CQRS 模式"></a>2.4、CQRS 模式</h2><p>CQRS （Command - QueryResponsibility Segregation）查询职责分离模式。将应用分为两部分：命令段（Command）和查询端（Query）。命令端处理程序创建、更新和删除请求，并在数据更改时发出事件。查询端通过执行查询来梳理查询，并且通过订阅数据更改时发出的事件流而保持最新。<br>CQRS 使用分离的接口将数据查询操作和数据修改操作分离开来，意味着查询和更新过程中使用的数据模型也是不一样的。<br>用途在于将领域模型与查询功能进行分离，让一些复杂的查询摆脱领域模型的限制，以更为简单的 DTO 形式展现查询结果。同时分离不同的数据存储结构。</p>
<ul>
<li><p>一个对象的一个方法修改了对象的状态，该方法便是一个命令（Command），不应该返回数据，声明为 void。</p>
</li>
<li><p>一个对象的一个方法如果返回了数据，该方法便是一个查询（Query），不应该通过直接或者间接的手段你修改对象状态。</p>
</li>
<li><p>聚合只有 Command 方法，没有 Query 方法。</p>
</li>
<li><p>资源库只有 add、save、find 方法。</p>
</li>
</ul>
<p>事件订阅更新查询模型。</p>
<h1 id="三、最佳实践"><a href="#三、最佳实践" class="headerlink" title="三、最佳实践"></a>三、最佳实践</h1><h2 id="3-1、代码组织结构"><a href="#3-1、代码组织结构" class="headerlink" title="3.1、代码组织结构"></a>3.1、代码组织结构</h2><p>模块（Module）是 DDD 中明确提到的一种控制限界上下文的手段，在工程中，一般尽量用一个模块来表示一个领域的限界上下文。<br>一般的工程中包的组织方式为{com.公司名.组织架构.业务.上下文.*}，这样的组织结构能够明确的将一个上下文限定在包的内部。<br>DDD 中一般的分层结构：</p>
<ul>
<li><p>Interfaces 层依赖 Application 层</p>
</li>
<li><p>Application 层依赖 Domain 层</p>
</li>
<li><p>Application 层依赖 Infrastructure 层</p>
</li>
<li><p>Infrastructure 层依赖 Domain 层</p>
</li>
<li><p>Rpc 看情况是否需要抽离,被 Application 层依赖</p>
</li>
</ul>
<blockquote>
<p>DDD 中不同模块的代码的演进速度是不一样的：</p>
<ul>
<li>Domain 层属于核心业务逻辑，属于经常被修改的地方。通过 Entity 能够解决基于单个对象的逻辑变更，通过 Domain Service 解决多个对象间的业务逻辑变更。</li>
<li>Application 层属于 Use Case（业务用例）。业务用例一般都是描述比较大方向的需求，接口相对稳定，特别是对外的接口一般不会频繁变更。添加业务用例可以通过新增 Application Service 或者新增接口实现功能的扩展。</li>
<li>Infrastructure 层属于最低频变更的。一般这个层的模块只有在外部依赖变更了之后才会跟着升级，而外部依赖的变更频率一般远低于业务逻辑的变更频率。</li>
</ul>
</blockquote>
<h3 id="3-1-1、接口层-interfaces"><a href="#3-1-1、接口层-interfaces" class="headerlink" title="3.1.1、接口层 - interfaces"></a>3.1.1、接口层 - interfaces</h3><p>Interfaces 层对外以各种协议提供服务，在该层需要明确定义支持的服务协议、契约等。<br>Interfaces 层提供的功能：</p>
<ul>
<li>职责：主要负责承接网络协议的转化、Session管理等</li>
<li>接口数量：避免所谓的统一 API，不必人为限制接口类的数量，每个&#x2F;每类业务对应一套接口即可，接口参数应该符合业务需求，避免大而全的入参。</li>
<li>接口出参：统一返回 Result。</li>
<li>异常处理：应该捕捉所有异常，避免异常信息的泄漏。可以通过 AOP 统一处理，避免代码里有大量重复代码。</li>
</ul>
<h3 id="3-1-2、应用层-Application"><a href="#3-1-2、应用层-Application" class="headerlink" title="3.1.2、应用层 - Application"></a>3.1.2、应用层 - Application</h3><p>Application 模块主要包含 Application Service 和一些相关的类，Application 模块依赖 Domain 模块。ApplicationService只负责业务流程串联，不负责业务逻辑，不是必须的一层，可以由 UI 层兼任。<br>Application 是很薄的一层，负责组合、编排和转发 domain 层的领域对象和基础设施层的公共组件，根据业务需求处理业务用例的执行顺序以及结果的拼装，以适应多变的业务需求，拼装完领域服务后以粗粒度的服务通过 API 对外暴露。也是与其它系统应用层进行交互的必要渠道。<br>应用层除了定义应用服务之外，在这层还可以进行安全认证，权限校验，持久化事务控制或向其他系统发送基于事件的消息通知。<br>DTO Assembler：在Application层，Entity 到DTO 的转化器有一个标准的名称叫 DTO Assembler。<br>DTO Assembler 的核心作用就是将 1 个或多个相关联的Entity 转化为 1 个或多个 DTO，不可以从 DTO 转 Entity VO（通常一个DTO 转化为 Entity 时是无法保证Entity 的准确性的）。<br>Application 层提供的功能：</p>
<ul>
<li>入参：具像化 Command、Query、Event 对象作为 ApplicationService 的入参，唯一可以的例外是单 ID 查询的场景。</li>
<li>CQE的语意化：CQE 对象有语意，不同用例之间语意不同，即使参数一样也要避免复用。</li>
<li>入参校验：基础校验通过 Bean Validation api 解决。Spring Validation 自带 Validation 的 AOP，也可以自己写 AOP。</li>
<li>出参：统一返回 DTO，而不是 Entity 或 DO。</li>
<li>DTO 转化：用 DTO Assembler 负责 Entity &#x2F; VO 到 DTO 的转化。</li>
<li>异常处理：不统一捕捉异常，可以随意抛异常。</li>
</ul>
<blockquote>
<p>Application Service的代码通常有类似的结构：ApplicationService 通常不做任何决策（Precondition 除外），仅仅是把所有决策交给 DomainService 或 Entity，把跟外部交互的交给 Infrastructure 接口，如 Repository 或防腐层。</p>
<p>一般的 “套路” 如下：</p>
<ul>
<li>准备数据：包括从外部服务或持久化源取出相对应的 Entity、VO 以及外部服务返回的 DTO。</li>
<li>执行操作：包括新对象的创建、赋值，以及调用领域对象的方法对其进行操作。需要注意的是这个时候通常都是纯内存操作，非持久化。</li>
<li>持久化：将操作结果持久化，或操作外部系统产生相应的影响，包括发消息等异步操作。</li>
</ul>
</blockquote>
<h3 id="3-1-3、Types-层"><a href="#3-1-3、Types-层" class="headerlink" title="3.1.3、Types 层"></a>3.1.3、Types 层</h3><p>Types 模块是保存可以对外暴露的 Value Object 的地方。Value Object 因为是无状态的逻辑，可以对外暴露。经常被包含在对外的 API 接口中，需要单独称为模块。<br>Types 模块不依赖任何类库，属于纯 POJO。</p>
<h3 id="3-1-4、领域层-Domain"><a href="#3-1-4、领域层-Domain" class="headerlink" title="3.1.4、领域层 - Domain"></a>3.1.4、领域层 - Domain</h3><p>Domain 负责表达业务概念、业务状态信息以及业务规则。是最多变的一层，需要保证这一层是高内聚的。确保所有的业务逻辑都留在这一层，而不会遗漏到其他层。<br>Domian 层包含有状态的 Entity、领域服务 Domain Service、领域事件 Domian Event、以及各种外部依赖的接口类（比如 Repository、ACL、中间件等）。<br>Domain 模块的具体表现形式就是领域模型。<br>Domain 模块仅依赖 Types 模块，属于纯 POJO。<br>领域服务：当领域中，某个操作过程或转换过程不是实体或者值对象的指责时，应该将操作放在一个单独的接口中。一个聚合使用 DomainService 来保持业务的一致性，一个聚合只有一个 Domain Service。</p>
<h3 id="3-1-5、基础设施层-infrastructure"><a href="#3-1-5、基础设施层-infrastructure" class="headerlink" title="3.1.5、基础设施层 - infrastructure"></a>3.1.5、基础设施层 - infrastructure</h3><p>Infrastructure 模块包含了 Persistence、MessagIng、External 等模块。<br>infrastructure 向其他层提供通用的技术能力，供 controller、service、domain 层调用，比如：持久化相关组件、httpclent、validation、checkLogint、exceptionHandler、message resource 等。<br>Data Converter：在 Infrastructure 层，Entity 到 DO 的转化器没有一个标准名称，但是为了区分 Data Mapper，这种转化器被称为 Data Converter。<br>Data Converter 的核心作用是将 DO转化为 Entity。</p>
<h3 id="3-1-6、防腐层-ACL"><a href="#3-1-6、防腐层-ACL" class="headerlink" title="3.1.6、防腐层 - ACL"></a>3.1.6、防腐层 - ACL</h3><p>当被依赖的系统可能包含不合理的数据结构、API、协议或技术实现时，如果对外 系统强依赖，会导致系统被 “腐蚀”。这时，可以通过在系统间加入防腐层，能够有效隔离外部依赖和内部逻辑，无论外部如何变更，内部代码可以尽可能保持不变。<br>ACL 提供的功能：</p>
<ul>
<li>适配器：通过适配器模式，将外部依赖的数据转换逻辑封装到 ACL 内部，降低对业务代码的侵入，使入参、出参更符合标准</li>
<li>缓存：对于频繁调用且数据变更不频繁的外部依赖，在 ACL 中嵌入缓存逻辑，能够有效降低对外部依赖的请求压力。</li>
<li>兜底：外部依赖的稳定性较差，可以通过 ACL 做为兜底，在 ACL 中返回最近一次成功的缓存或者业务兜底数据。</li>
<li>易于测试：ACL 的接口可以很容易的实现 Mock 或 Stub，便于单元测试。</li>
<li>功能开关：可以在 ACL 配置功能开关实现在某些场景下开放或关闭某个接口的功能或者让某个接口返回特定的值。<blockquote>
<p>ACL 防腐层的简单原理如下：</p>
<ol>
<li>对于依赖的外部对象，抽取出所需要的字段，生成一个内部所需的 VO 或 DTO 类</li>
<li>构建一个新的 Facade，在 Facade 中封装调用链路，将外部类转化为内部类</li>
<li>针对外部系统调用，同样的用 Facade 方法封装外部调用链路</li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="3-1-7、Start-Boostrap-模块"><a href="#3-1-7、Start-Boostrap-模块" class="headerlink" title="3.1.7、Start &#x2F; Boostrap 模块"></a>3.1.7、Start &#x2F; Boostrap 模块</h3><p>Start 、Boostrap 模块是 Spring Boot 的启动类。</p>
<h2 id="3-2、最佳实践-规范"><a href="#3-2、最佳实践-规范" class="headerlink" title="3.2、最佳实践&#x2F;规范"></a>3.2、最佳实践&#x2F;规范</h2><h3 id="3-2-1、Domain-规范"><a href="#3-2-1、Domain-规范" class="headerlink" title="3.2.1、Domain 规范"></a>3.2.1、Domain 规范</h3><ol>
<li>通过 Factory 模式来创建对象，可以降低一些重复性的入参。</li>
<li>尽量避免 public setter。通过方法名重新写为比较 “行为化 ”的命名，会增强其语意。</li>
<li>通过聚合根保证主子实体的一致性。</li>
<li>不可以强依赖其他聚合根实体或领域服务。</li>
</ol>
<ul>
<li>在稍微复杂一点的领域里，通常主实体会包含子实体，这时候主实体就需要起到聚合根的作用，即：</li>
<li>子实体不能单独存在，只能通过聚合根的方法获取到。任何外部的对象都不能直接保留子实体的引用。</li>
<li>子实体没有独立的 Repository，不可以单独保存和取出，必须要通过聚合根的 Repository 实例化。</li>
<li>子实体可以单独修改自身状态，但是多个子实体之间的状态一致性需要聚合根来保障。</li>
<li>正确的对外部依赖的方法有两种：</li>
<li>只保存外部实体的 ID：建议使用强类型的 ID 对象，而不是 Lon g型 ID。强类型的 ID 对象不单单能自我包含验证代码，保证 ID 值的正确性，同时还能确保各种入参不会因为参数顺序变化而出 bug。</li>
<li>针对于 “无副作用” 的外部依赖，通过方法入参的方式传入。如果方法对外部依赖有副作用，不能通过方法入参的方式，只能通过 Domain Service 解决。</li>
</ul>
<ol start="5">
<li>任何实体的行为不能有 “直接” 的 ”副作用“，即直接修改其他的实体类。</li>
<li>任何实体的行为只能直接影响到本实体（和其子实体）</li>
<li>当一个行为会直接修改多个实体时，不能再通过单一实体的方法作处理，而必须直接使用领域服务的方法来做操作。此时，领域服务更多的起到了跨对象事务的作用，确保多个实体的变更之间是有一致性的<blockquote>
<p>一个实体的原则是高内聚、低耦合，即一个实体类不能直接在内部直接依赖一个外部的实体或服务。这个原则和绝大多数 ORM 框架都有比较严重的冲突，所以在开发过程中需要特别注意。<br>这个原则的必要原因包括：对外部对象的依赖性会直接导致实体无法被单测；以及一个实体无法保证外部实体变更后不会影响本实体的一致性和正确性。</p>
</blockquote>
</li>
</ol>
<h3 id="3-2-2、Repository-规范"><a href="#3-2-2、Repository-规范" class="headerlink" title="3.2.2、Repository 规范"></a>3.2.2、Repository 规范</h3><p>在 Repository 的设计上，主要需要注意以下三点：</p>
<ol>
<li>接口名称不应该使用底层实现的语法：常见的 insert、select、update、delete 都属于SQL语法，使用这几个词相当于和 DB 底层实现做了绑定。相反，应该把 Repository 当成一个中性的类似 Collection 的接口，使用语法如 find、save、remove。</li>
<li>特别需要注意的是区分 insert &#x2F; add 和 update 本身也是一种和底层强绑定的逻辑，一些储存如缓存实际上不存在 insert 和 update 的差异，在这个 case 里，使用中性的 save 接口，然后在具体实现上根据情况调用 DAO 的 insert 或 update 接口。</li>
<li>出参入参不应该使用底层数据格式：需要记得的是 Repository 操作的是 Entity 对象（实际上应该是 Aggregate Root），而不应该直接操作底层的 DO 。更近一步，Repository 接口实际上应该存在于 Domain 层，根本看不到 DO 的实现。这个也是为了避免底层实现逻辑渗透到业务代码中的强保障。</li>
<li>应该避免所谓的“通用 ”Repository“ 模式：很多 ORM 框架都提供一个 “通用” 的 Repository 接口，然后框架通过注解自动实现接口，比较典型的例子是 Spring Data、Entity Framework 等，这种框架的好处是在简单场景下很容易通过配置实现，但是坏处是基本上无扩展的可能性（比如加定制缓存逻辑），在未来有可能还是会被推翻重做。</li>
</ol>
<h3 id="3-2-3、Interface-层规范"><a href="#3-2-3、Interface-层规范" class="headerlink" title="3.2.3、Interface 层规范"></a>3.2.3、Interface 层规范</h3><p>一个Interface层的类应该是 “小而美” 的，应该是面向 “一个单一的业务” 或 “一类同样需求的业务” ，需要尽量避免用同一个类承接不同类型业务的需求。</p>
<ol>
<li>Interface 层的 HTTP 和 RPC 接口，返回值为 Result，捕捉所有异常。</li>
<li>Application 层的所有接口返回值为 DTO，不负责处理异常。</li>
</ol>
<h3 id="3-2-4、Application-层规范"><a href="#3-2-4、Application-层规范" class="headerlink" title="3.2.4、Application 层规范"></a>3.2.4、Application 层规范</h3><p>ApplicationService 的接口入参只能是一个 Command、Query 或 Event 对象，CQE 对象需要能代表当前方法的语意。唯一可以的例外是根据单一 ID 查询的情况，可以省略掉一个 Query 对象的创建。<br>因为 CQE 是有 “意图” 和 “语意” 的，需要尽量避免 CQE 对象的复用，哪怕所有的参数都一样，只要他们的语意不同，尽量还是要用不同的对象。</p>
<blockquote>
<p>ApplicationService 的返回值应该永远返回 DTO 而不是 Entity</p>
<ol>
<li>构建领域边界：ApplicationService 的入参是 CQE 对象，出参是 DTO，这些基本上都属于简单的 POJO，来确保 Application 层的内外互相不影响。</li>
<li>降低规则依赖：Entity 里面通常会包含业务规则，如果 ApplicationService 返回 Entity，则会导致调用方直接依赖业务规则。如果内部规则变更可能直接影响到外部</li>
<li>通过 DTO 组合降低成本：Entity 是有限的，DTO 可以是多个 Entity、VO 的自由组合，一次性封装成复杂 DTO，或者有选择的抽取部分参数封装成 DTO 可以降低对外的成本。</li>
</ol>
</blockquote>
<h3 id="3-2-5、异常处理"><a href="#3-2-5、异常处理" class="headerlink" title="3.2.5、异常处理"></a>3.2.5、异常处理</h3><p>在 Application 层、Domain 层，以及 Infrastructure 层，遇到错误直接抛异常是最合理的方法。</p>
<h1 id="四、常见误区"><a href="#四、常见误区" class="headerlink" title="四、常见误区"></a>四、常见误区</h1><h2 id="6-1、Application-Service-和-domain-Service-的区别"><a href="#6-1、Application-Service-和-domain-Service-的区别" class="headerlink" title="6.1、Application Service 和 domain Service 的区别"></a>6.1、Application Service 和 domain Service 的区别</h2><p>应用服务：是各种方法的编排，不处理任何业务逻辑。业务的逻辑体现在聚合根中，应用服务只负责调用。<br>领域服务：聚合根本身无法完全处理该逻辑。</p>
<h2 id="6-2、聚合和实体的区别"><a href="#6-2、聚合和实体的区别" class="headerlink" title="6.2、聚合和实体的区别"></a>6.2、聚合和实体的区别</h2><h2 id="6-3、实体和值对象的区别"><a href="#6-3、实体和值对象的区别" class="headerlink" title="6.3、实体和值对象的区别"></a>6.3、实体和值对象的区别</h2><p>实体和值对象的目的都是抽象聚合若干属性以简化设计和沟通。</p>
<ol>
<li>实体和值对象都经过属性聚类形成，实体有唯一性，值对象没有。</li>
<li>实体着重唯一性和延续性，不在意属性的变化；值对象着重描述性，对属性的变化很敏感。</li>
<li>实体和值对象也有可能随着系统业务关注点的不同而更换位置。</li>
</ol>
<h2 id="6-4、聚合根定义的业务边界是什么"><a href="#6-4、聚合根定义的业务边界是什么" class="headerlink" title="6.4、聚合根定义的业务边界是什么"></a>6.4、聚合根定义的业务边界是什么</h2><p>不以表结构数据进行业务逻辑的划分，一个业务体为一块业务。以实体与值对象的方式在聚合内进行定义。</p>
<h2 id="6-5、应用服务层如果调用-RPC-是否必须使用-adapter"><a href="#6-5、应用服务层如果调用-RPC-是否必须使用-adapter" class="headerlink" title="6.5、应用服务层如果调用 RPC 是否必须使用 adapter"></a>6.5、应用服务层如果调用 RPC 是否必须使用 adapter</h2><p>必须使用，需要屏蔽外部依赖对应当前业务逻辑影响。</p>
<h2 id="6-6、返回的结果数据为多个接口组成，是否在应用服务层直接组合"><a href="#6-6、返回的结果数据为多个接口组成，是否在应用服务层直接组合" class="headerlink" title="6.6、返回的结果数据为多个接口组成，是否在应用服务层直接组合"></a>6.6、返回的结果数据为多个接口组成，是否在应用服务层直接组合</h2><p>不可以，需要定义一个 assember，单独对外部依赖的各种数据进行处理。</p>
<h2 id="6-7、save-方法做完-insert-和-update-所有操作么"><a href="#6-7、save-方法做完-insert-和-update-所有操作么" class="headerlink" title="6.7、save 方法做完 insert 和 update 所有操作么"></a>6.7、save 方法做完 insert 和 update 所有操作么</h2><p>insert 和 update 方法理论上是需要保持统一方法的。</p>
<h2 id="6-8、逻辑处理的-service-放在哪里"><a href="#6-8、逻辑处理的-service-放在哪里" class="headerlink" title="6.8、逻辑处理的 service 放在哪里"></a>6.8、逻辑处理的 service 放在哪里</h2><p>如果该逻辑只为某个聚合使用，则放置在对应的领域服务中，如果逻辑处理会被多个聚合使用，则将其单独定义一个 service，做为一个工具类。</p>
<h2 id="6-9、DO、Entity、DTO-的区别"><a href="#6-9、DO、Entity、DTO-的区别" class="headerlink" title="6.9、DO、Entity、DTO 的区别"></a>6.9、DO、Entity、DTO 的区别</h2><table>
<thead>
<tr>
<th></th>
<th align="left">DO</th>
<th align="left">Entity</th>
<th align="left">DTO</th>
</tr>
</thead>
<tbody><tr>
<td><strong>目的</strong></td>
<td align="left">数据库表映射</td>
<td align="left">业务逻辑</td>
<td align="left">适配业务场景</td>
</tr>
<tr>
<td><strong>代码层级</strong></td>
<td align="left">Infrastructure</td>
<td align="left">Domain</td>
<td align="left">Application</td>
</tr>
<tr>
<td><strong>命名规范</strong></td>
<td align="left">XxxDO</td>
<td align="left">Xxx</td>
<td align="left">XxxDTO、XxxCommand、XxxRequest等</td>
</tr>
<tr>
<td><strong>字段名称标准</strong></td>
<td align="left">数据库表字段名</td>
<td align="left">业务语言</td>
<td align="left">和调用方商定</td>
</tr>
<tr>
<td><strong>字段数据类型</strong></td>
<td align="left">数据库字段类型</td>
<td align="left">尽量是有业务含义的类型，比如DP</td>
<td align="left">和调用方商定</td>
</tr>
<tr>
<td><strong>是否需要序列化</strong></td>
<td align="left">不需要</td>
<td align="left">不需要</td>
<td align="left">需要</td>
</tr>
<tr>
<td><strong>转化器</strong></td>
<td align="left">Data Converter</td>
<td align="left">Data Converter DTO Assembler</td>
<td align="left">DTO Assembler</td>
</tr>
</tbody></table>
<h2 id="6-10、如何判断是否业务流程"><a href="#6-10、如何判断是否业务流程" class="headerlink" title="6.10、如何判断是否业务流程"></a>6.10、如何判断是否业务流程</h2><ol>
<li>不要有 if&#x2F;else 分支逻辑：也就是说代码的 Cyclomatic Complexity（循环复杂度）应该尽量等于 1</li>
<li>通常有分支逻辑的，都代表一些业务判断，应该将逻辑封装到 DomainService 或者 Entity 里。但不代表完全不能有 if 逻辑，比如，对某个业务返回值的判断的异常处理仅仅代表了中断条件.</li>
<li>不要有任何计算</li>
<li>一些数据的转化可以交给其他对象来做：比如 DTO Assembler，将对象间转化的逻辑沉淀在单独的类中，降低 ApplicationService 的复杂度</li>
</ol>
<h2 id="6-11、DDD-和-微服务的区别"><a href="#6-11、DDD-和-微服务的区别" class="headerlink" title="6.11、DDD 和 微服务的区别"></a>6.11、DDD 和 微服务的区别</h2><p>DDD 主要关注：从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。<br>微服务主要关注：运行时的进程间通信、容错和故障隔离，实现去中心化数据管理和去中心化服务治理，关注微服务的独立开发、测试、构建和部署。</p>
<h1 id="五、-业务流程设计模式"><a href="#五、-业务流程设计模式" class="headerlink" title="五、 业务流程设计模式"></a>五、 业务流程设计模式</h1><p>没有最好的模式，取决于业务场景、依赖关系、以及是否有业务“负责人”。避免拿着锤子找钉子。</p>
<ol>
<li>Orchestration：指令驱动，依赖方是上游，需要感知到下游的能力和返回值</li>
<li>Choreography：事件驱动，依赖方是下游，需要感知到上游的事件</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>Orchestration</th>
<th>Choreography</th>
</tr>
</thead>
<tbody><tr>
<td>驱动力</td>
<td>指令驱动 Command-Driven</td>
<td>事件驱动 Event-Driven</td>
</tr>
<tr>
<td>调用依赖</td>
<td>上游强依赖下游</td>
<td>无直接调用依赖但是有代码依赖可以认为是下游依赖上游</td>
</tr>
<tr>
<td>灵活性</td>
<td>较差</td>
<td>较高</td>
</tr>
<tr>
<td>业务职责</td>
<td>上游为业务负责</td>
<td>无全局责任人</td>
</tr>
</tbody></table>
<ul>
<li><strong>从代码依赖关系来看：</strong><br>Orchestration：涉及到一个服务调用到另外的服务，对于调用方来说，是强依赖的服务提供方。<br>Choreography：每一个服务只是做好自己的事，然后通过事件触发其他的服务，服务之间没有直接调用上的依赖。但要注意的是下游还是会依赖上游的代码（比如事件类），所以可以认为是下游对上游有依赖。</li>
<li><strong>从代码灵活性来看：</strong><br>Orchestration：因为服务间的依赖关系是写死的，增加新的业务流程必然需要修改代码。<br>Choreography：因为服务间没有直接调用关系，可以增加或替换服务，而不需要改上游代码。</li>
<li>从调用链路来看：<br>Orchestration：是从一个服务主动调用另一个服务，所以是Command-Driven指令驱动的。<br>Choreography：是每个服务被动的被外部事件触发，所以是 Event-Driven 事件驱动的。</li>
<li><strong>从业务职责来看：</strong><br>Orchestration：有主动的调用方（比如：下单服务）。无论下游的依赖是谁，主动的调用方都需要为整个业务流程和结果负责。<br>Choreography：没有主动调用方，每个服务只关心自己的触发条件和结果，没有任何一个服务会为整个业务链路负责</li>
</ul>
<h1 id="六、DDD-适合什么系统"><a href="#六、DDD-适合什么系统" class="headerlink" title="六、DDD 适合什么系统"></a>六、DDD 适合什么系统</h1><ul>
<li>DDD 的结构不像 MVC 结构那么简单，分层更加复杂。</li>
<li>消除信息不对称的成本比较大，需要多方人员协作讨论业务模型。</li>
<li>迭代快的小系统不如直接使用 MVC 做好代码规范能够更快地上线。<br><strong>因此，不适配 DDD 的系统是什么呢？</strong></li>
<li>中小规模的系统，本身业务体量小，功能单一，选择 MVC 架构无疑是最好的。</li>
<li>项目化交付的系统，研发周期短，一天到晚按照甲方的需求定制功能（这种本身业务需求边界就不清晰，功能的可持续迭代性就很差，而且这种系统一般就是一口价买卖），这种也最好选择 MVC。<br>那相反地，适配 DDD 的系统是什么呢？<strong>中大规模系统，产品化模式，业务可持续迭代，可预见的业务逻辑复杂性的系统。</strong><br>总而言之就是：</li>
<li>你还不了解 DDD 或者你们系统功能简单，就选择 MVC；</li>
<li>你不知道选用什么技术架构做开发，处于业务探索阶段，选用 MVC；</li>
<li>其他时候就酌情考虑 DDD。</li>
</ul>
<h1 id="七、参考文献"><a href="#七、参考文献" class="headerlink" title="七、参考文献"></a>七、参考文献</h1><p>以下链接，仅做记录，与学习顺序无关。<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/434443923?utm_id=0">DDD架构使用Mapstruct - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/kiwangruikyo/article/details/115252155">DDD—快速理解聚合根、实体、值对象的区别和联系_XXmaoxiaoXX的博客-CSDN博客_聚合根和实体</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_57907028/article/details/125451904">DDD概念复杂难懂，实际落地如何设计代码实现模型？_敲代码的程序狗的博客-CSDN博客_ddd代码落地</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/1578320/channel/collectiondetail?sid=313946&ctype=0">寒食君的个人空间_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/691070.html">DDD落地，如何持久化聚合-51CTO.COM</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/342826364">领域驱动设计在爱奇艺打赏业务的实践 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.modb.pro/db/106275">DDD第七篇：资源库Repository的性能优化 - 墨天轮</a></p>
<p><a target="_blank" rel="noopener" href="https://www.arcblock.io/blog/zh/post/2018/10/30/cqrs-commaded">浅谈查询职责分离(CQRS)模式</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/91525839">DDD 模式从天书到实践 - 知乎</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/daoqidelv/p/7492322.html">【DDD】使用领域驱动设计思想实现业务系统 - 倒骑的驴 - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Zachary-Fan/p/5991674.html">如何一步一步用DDD设计一个电商网站（一）—— 先理解核心概念 - Zachary_Fan - 博客园</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650403892&idx=1&sn=a91fa477392e80f9420a8ca4d26bcace&chksm=83953c2cb4e2b53a6af3b5a82c3b7d7ed932bfe83f59877a935445ae89edd0ff4ee1c4e82fba&scene=21#wechat_redirect">阿里技术专家详解 DDD 系列- Domain Primitive</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650404060&idx=1&sn=cacf40d19528f6c2d9fd165151d6e8b4&chksm=83953cc4b4e2b5d2bd4426e0d2103f2e95715b682f3b7ff333dbb123eaa79d3e5ad24f64beac&scene=21#wechat_redirect">阿里技术专家详解DDD系列 第二弹 - 应用架构</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650406692&idx=1&sn=4a4ac4168299d8ca1905a4f457ae4c59&chksm=8395373cb4e2be2a2d066a5ea4e631fd6270e969ce61883b488f61c1ce33fbc0b362ec9cbf7b&scene=21#wechat_redirect">阿里技术专家详解DDD系列 第三讲 - Repository模式</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650414919&idx=1&sn=0ad1df1a1b0e2488f7faa21008fdbdd0&chksm=8396d75fb4e15e49341b07022780dcb8dca66a0efb7f129d4de86a5ef5d8a890f6e0d2fd6432&scene=21#wechat_redirect">DDD系列第四讲：领域层设计规范</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/1rdnkROdcNw5ro4ct99SqQ">DDD系列第五讲：聊聊如何避免写流水账代码</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/r-3D6unri7ZxIlxkpIGYZg">详解DDD“洋葱架构”</a></p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html?utm_source=wechat_session&utm_medium=social&utm_oi=698166473230680064">领域驱动设计在互联网业务开发中的实践 - 美团技术团队</a></p>
<p><a target="_blank" rel="noopener" href="https://zq99299.github.io/note-book2/ddd/00/#%E5%9F%BA%E7%A1%80%E7%AF%87">开篇 | 学好了 DDD，你能做什么？ | NOTE-BOOK2</a></p>
<p><a href="https://github.com/alibaba/COLA">alibaba&#x2F;COLA: 🥤 COLA: Clean Object-oriented &amp; Layered Architecture</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1791310">DDD领域驱动设计实战-理解聚合(Aggregate)和聚合根(AggregateRoot) - 腾讯云开发者社区-腾讯云</a></p>
<p><a target="_blank" rel="noopener" href="https://space.bilibili.com/386239614/channel/collectiondetail?sid=677400">b_lorne的个人空间_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jt4y1j73j?p=7">DDD：课前介绍_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HMLpjcE0UENUTfMK0Z9n8A">领域驱动设计DDD｜从入门到代码实践</a></p>
<h1 id="八、云原生架构"><a href="#八、云原生架构" class="headerlink" title="八、云原生架构"></a>八、云原生架构</h1><p>基于微服务原理而开发的应用，以容器方式打包。在运行时，容器由运行于云基础设施之上的平台进行调度。应用开发采用持续交付和 DevOps 实践。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://github.com">Dongx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://github.com/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/">https://github.com/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://github.com" target="_blank">wecode</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/DDD/">DDD</a></div><div class="post_share"><div class="social-share" data-image="/images/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/12/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="常用指令"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常用指令</div></div></a></div><div class="next-post pull-right"><a href="/2023/11/07/Docker/" title="常用Dockerfile"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常用Dockerfile</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="comment-switch"><span class="first-comment">Valine</span><span id="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Dongx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">29</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" href="https://github.com/MiracleDx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Dongx's Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1-Domain-Drive-Design"><span class="toc-number">1.</span> <span class="toc-text">领域驱动设计 Domain Drive Design</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">一、什么是领域驱动设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">二、基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E6%88%98%E7%95%A5%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">2.1、战略设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1%E3%80%81%E9%99%90%E7%95%8C%E4%B8%8A%E4%B8%8B%E6%96%87-Context-Bounds"><span class="toc-number">3.1.1.</span> <span class="toc-text">2.1.1、限界上下文 - Context Bounds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2%E3%80%81%E9%80%9A%E7%94%A8%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.2.</span> <span class="toc-text">2.1.2、通用语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3%E3%80%81%E9%A2%86%E5%9F%9F"><span class="toc-number">3.1.3.</span> <span class="toc-text">2.1.3、领域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-1%E3%80%81%E5%AD%90%E5%9F%9F"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">2.1.3.1、子域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-2%E3%80%81%E6%A0%B8%E5%BF%83%E5%AD%90%E5%9F%9F"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">2.1.3.2、核心子域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-3%E3%80%81%E9%80%9A%E7%94%A8%E5%AD%90%E5%9F%9F"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">2.1.3.3、通用子域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-4%E3%80%81%E6%94%AF%E6%92%91%E5%AD%90%E5%9F%9F"><span class="toc-number">3.1.3.4.</span> <span class="toc-text">2.1.3.4、支撑子域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E6%88%98%E6%9C%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.</span> <span class="toc-text">2.2、战术设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1%E3%80%81%E8%81%9A%E5%90%88-Aggregate"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1、聚合 - Aggregate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2%E3%80%81%E8%81%9A%E5%90%88%E6%A0%B9-Aggregate-Root"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2、聚合根 - Aggregate Root</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3%E3%80%81%E5%AE%9E%E4%BD%93-Entity"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3、实体 - Entity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-1%E3%80%81%E5%A4%B1%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">2.2.3.1、失血模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-2%E3%80%81%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">2.2.3.2、贫血模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-3%E3%80%81%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">2.2.3.3、充血模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-4%E3%80%81%E8%83%80%E8%A1%80%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.3.4.</span> <span class="toc-text">2.2.3.4、胀血模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4%E3%80%81%E5%80%BC%E5%AF%B9%E8%B1%A1-Value-Object"><span class="toc-number">3.2.4.</span> <span class="toc-text">2.2.4、值对象 - Value Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5%E3%80%81%E8%B5%84%E6%BA%90%E5%BA%93-Repository"><span class="toc-number">3.2.5.</span> <span class="toc-text">2.2.5、资源库 - Repository</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6%E3%80%81%E9%A2%86%E5%9F%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.2.6.</span> <span class="toc-text">2.2.6、领域服务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7%E3%80%81%E9%A2%86%E5%9F%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.2.7.</span> <span class="toc-text">2.2.7、领域事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-8%E3%80%81%E5%B7%A5%E5%8E%82"><span class="toc-number">3.2.8.</span> <span class="toc-text">2.2.8、工厂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-9%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.2.9.</span> <span class="toc-text">2.2.9、应用服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3%E3%80%81CQE-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">2.3、CQE 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1%E3%80%81CQE-%E7%9A%84%E8%A7%84%E8%8C%83"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.3.1、CQE 的规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E3%80%81CQRS-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.</span> <span class="toc-text">2.4、CQRS 模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">三、最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">3.1、代码组织结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E3%80%81%E6%8E%A5%E5%8F%A3%E5%B1%82-interfaces"><span class="toc-number">4.1.1.</span> <span class="toc-text">3.1.1、接口层 - interfaces</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E3%80%81%E5%BA%94%E7%94%A8%E5%B1%82-Application"><span class="toc-number">4.1.2.</span> <span class="toc-text">3.1.2、应用层 - Application</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E3%80%81Types-%E5%B1%82"><span class="toc-number">4.1.3.</span> <span class="toc-text">3.1.3、Types 层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E3%80%81%E9%A2%86%E5%9F%9F%E5%B1%82-Domain"><span class="toc-number">4.1.4.</span> <span class="toc-text">3.1.4、领域层 - Domain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5%E3%80%81%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E5%B1%82-infrastructure"><span class="toc-number">4.1.5.</span> <span class="toc-text">3.1.5、基础设施层 - infrastructure</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6%E3%80%81%E9%98%B2%E8%85%90%E5%B1%82-ACL"><span class="toc-number">4.1.6.</span> <span class="toc-text">3.1.6、防腐层 - ACL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-7%E3%80%81Start-Boostrap-%E6%A8%A1%E5%9D%97"><span class="toc-number">4.1.7.</span> <span class="toc-text">3.1.7、Start &#x2F; Boostrap 模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E3%80%81%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-%E8%A7%84%E8%8C%83"><span class="toc-number">4.2.</span> <span class="toc-text">3.2、最佳实践&#x2F;规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E3%80%81Domain-%E8%A7%84%E8%8C%83"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1、Domain 规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E3%80%81Repository-%E8%A7%84%E8%8C%83"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2、Repository 规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E3%80%81Interface-%E5%B1%82%E8%A7%84%E8%8C%83"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3、Interface 层规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E3%80%81Application-%E5%B1%82%E8%A7%84%E8%8C%83"><span class="toc-number">4.2.4.</span> <span class="toc-text">3.2.4、Application 层规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5%E3%80%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">4.2.5.</span> <span class="toc-text">3.2.5、异常处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">5.</span> <span class="toc-text">四、常见误区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1%E3%80%81Application-Service-%E5%92%8C-domain-Service-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">6.1、Application Service 和 domain Service 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2%E3%80%81%E8%81%9A%E5%90%88%E5%92%8C%E5%AE%9E%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.</span> <span class="toc-text">6.2、聚合和实体的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3%E3%80%81%E5%AE%9E%E4%BD%93%E5%92%8C%E5%80%BC%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">6.3、实体和值对象的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4%E3%80%81%E8%81%9A%E5%90%88%E6%A0%B9%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%9A%E5%8A%A1%E8%BE%B9%E7%95%8C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">5.4.</span> <span class="toc-text">6.4、聚合根定义的业务边界是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5%E3%80%81%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%B1%82%E5%A6%82%E6%9E%9C%E8%B0%83%E7%94%A8-RPC-%E6%98%AF%E5%90%A6%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-adapter"><span class="toc-number">5.5.</span> <span class="toc-text">6.5、应用服务层如果调用 RPC 是否必须使用 adapter</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6%E3%80%81%E8%BF%94%E5%9B%9E%E7%9A%84%E7%BB%93%E6%9E%9C%E6%95%B0%E6%8D%AE%E4%B8%BA%E5%A4%9A%E4%B8%AA%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90%EF%BC%8C%E6%98%AF%E5%90%A6%E5%9C%A8%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%B1%82%E7%9B%B4%E6%8E%A5%E7%BB%84%E5%90%88"><span class="toc-number">5.6.</span> <span class="toc-text">6.6、返回的结果数据为多个接口组成，是否在应用服务层直接组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7%E3%80%81save-%E6%96%B9%E6%B3%95%E5%81%9A%E5%AE%8C-insert-%E5%92%8C-update-%E6%89%80%E6%9C%89%E6%93%8D%E4%BD%9C%E4%B9%88"><span class="toc-number">5.7.</span> <span class="toc-text">6.7、save 方法做完 insert 和 update 所有操作么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8%E3%80%81%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86%E7%9A%84-service-%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">5.8.</span> <span class="toc-text">6.8、逻辑处理的 service 放在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-9%E3%80%81DO%E3%80%81Entity%E3%80%81DTO-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.</span> <span class="toc-text">6.9、DO、Entity、DTO 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-10%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">5.10.</span> <span class="toc-text">6.10、如何判断是否业务流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-11%E3%80%81DDD-%E5%92%8C-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.11.</span> <span class="toc-text">6.11、DDD 和 微服务的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81-%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">五、 业务流程设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81DDD-%E9%80%82%E5%90%88%E4%BB%80%E4%B9%88%E7%B3%BB%E7%BB%9F"><span class="toc-number">7.</span> <span class="toc-text">六、DDD 适合什么系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"><span class="toc-number">8.</span> <span class="toc-text">七、参考文献</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E4%BA%91%E5%8E%9F%E7%94%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">9.</span> <span class="toc-text">八、云原生架构</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/03/12/%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/" title="常用指令">常用指令</a><time datetime="2024-03-12T09:21:00.000Z" title="发表于 2024-03-12 17:21:00">2024-03-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/" title="领域驱动设计">领域驱动设计</a><time datetime="2024-01-16T16:00:00.000Z" title="发表于 2024-01-17 00:00:00">2024-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/11/07/Docker/" title="常用Dockerfile">常用Dockerfile</a><time datetime="2023-11-06T16:00:00.000Z" title="发表于 2023-11-07 00:00:00">2023-11-07</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/18/Llama2%20%E9%83%A8%E7%BD%B2/" title="Llama2 部署">Llama2 部署</a><time datetime="2023-10-18T01:46:00.000Z" title="发表于 2023-10-18 09:46:00">2023-10-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/12/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/" title="敏捷开发">敏捷开发</a><time datetime="2023-03-12T09:21:00.000Z" title="发表于 2023-03-12 17:21:00">2023-03-12</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Dongx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="/js/tw_cn.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'NjZ1ZhagcxnTjJaqQdauL0tL-gzGzoHsz',
      appKey: 'SdxgkdEbeu87Z5a85ck2mg4k',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !true) {
    if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script><script>(() => {
  const disqus_config = function () {
    this.page.url = 'https://github.com/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/'
    this.page.identifier = '/2024/01/17/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/'
    this.page.title = '领域驱动设计'
  }

  const disqusReset = () => {
    window.DISQUS && window.DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  btf.addGlobalFn('themeChange', disqusReset, 'disqus')

  const loadDisqus = () =>{
    if (window.DISQUS) disqusReset()
    else {
      const script = document.createElement('script')
      script.src = 'https://.disqus.com/embed.js'
      script.setAttribute('data-timestamp', +new Date())
      document.head.appendChild(script)
    }
  }

  const getCount = async() => {
    try {
      const eleGroup = document.querySelector('#post-meta .disqus-comment-count')
      if (!eleGroup) return
      const cleanedLinks = eleGroup.href.replace(/#post-comment$/, '')

      const res = await fetch(`https://disqus.com/api/3.0/threads/set.json?forum=&api_key=&thread:link=${cleanedLinks}`,{
        method: 'GET'
      })
      const result = await res.json()

      const count = result.response.length ? result.response[0].posts : 0
      eleGroup.textContent = count
    } catch (err) {
      console.error(err)
    }
  }

  if ('Valine' === 'Disqus' || !true) {
    if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
    else {
      loadDisqus()
      GLOBAL_CONFIG_SITE.isPost && getCount()
    }
  } else {
    window.loadOtherComment = loadDisqus
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fishes.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>